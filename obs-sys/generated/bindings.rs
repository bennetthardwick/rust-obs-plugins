/* automatically generated by rust-bindgen 0.68.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const GS_MAX_TEXTURES: u32 = 8;
pub const GS_BUILD_MIPMAPS: u32 = 1;
pub const GS_DYNAMIC: u32 = 2;
pub const GS_RENDER_TARGET: u32 = 4;
pub const GS_GL_DUMMYTEX: u32 = 8;
pub const GS_DUP_BUFFER: u32 = 16;
pub const GS_SHARED_TEX: u32 = 32;
pub const GS_SHARED_KM_TEX: u32 = 64;
pub const GS_SUCCESS: u32 = 0;
pub const GS_ERROR_FAIL: i32 = -1;
pub const GS_ERROR_MODULE_NOT_FOUND: i32 = -2;
pub const GS_ERROR_NOT_SUPPORTED: i32 = -3;
pub const GS_DEVICE_OPENGL: u32 = 1;
pub const GS_DEVICE_DIRECT3D_11: u32 = 2;
pub const GS_FLIP_U: u32 = 1;
pub const GS_FLIP_V: u32 = 2;
pub const GS_CLEAR_COLOR: u32 = 1;
pub const GS_CLEAR_DEPTH: u32 = 2;
pub const GS_CLEAR_STENCIL: u32 = 4;
pub const GS_USE_DEBUG_MARKERS: u32 = 0;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const LARGE_EPSILON: f64 = 0.01;
pub const EPSILON: f64 = 0.0001;
pub const TINY_EPSILON: f64 = 0.00001;
pub const HEDLEY_VERSION: u32 = 14;
pub const SIMDE_VERSION_MAJOR: u32 = 0;
pub const SIMDE_VERSION_MINOR: u32 = 7;
pub const SIMDE_VERSION_MICRO: u32 = 1;
pub const SIMDE_DETECT_CLANG_H: u32 = 1;
pub const SIMDE_DETECT_CLANG_VERSION: u32 = 120000;
pub const SIMDE_ARCH_AMD64: u32 = 1000;
pub const SIMDE_ARCH_X86_MMX: u32 = 1;
pub const SIMDE_ARCH_X86_SSE: u32 = 1;
pub const SIMDE_ARCH_X86_SSE2: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const SIMDE_NATURAL_VECTOR_SIZE: u32 = 128;
pub const SIMDE_MATH_PI: f64 = 3.141592653589793;
pub const SIMDE_MATH_PI_OVER_180: f64 = 0.017453292519943295;
pub const SIMDE_MATH_PI_OVER_180F: f64 = 0.017453292519943295;
pub const SIMDE_MATH_180_OVER_PI: f64 = 57.29577951308232;
pub const SIMDE_MATH_180_OVER_PIF: f64 = 57.29577951308232;
pub const SIMDE_ALIGN_64_: u32 = 64;
pub const SIMDE_ALIGN_32_: u32 = 32;
pub const SIMDE_ALIGN_16_: u32 = 16;
pub const SIMDE_ALIGN_8_: u32 = 8;
pub const SIMDE_ENDIAN_LITTLE: u32 = 1234;
pub const SIMDE_ENDIAN_BIG: u32 = 4321;
pub const SIMDE_ENDIAN_ORDER: u32 = 1234;
pub const SIMDE_ACCURACY_PREFERENCE: u32 = 1;
pub const _FENV_H: u32 = 1;
pub const FE_INVALID: u32 = 1;
pub const FE_DIVBYZERO: u32 = 4;
pub const FE_OVERFLOW: u32 = 8;
pub const FE_UNDERFLOW: u32 = 16;
pub const FE_INEXACT: u32 = 32;
pub const FE_ALL_EXCEPT: u32 = 61;
pub const FE_TONEAREST: u32 = 0;
pub const FE_DOWNWARD: u32 = 1024;
pub const FE_UPWARD: u32 = 2048;
pub const FE_TOWARDZERO: u32 = 3072;
pub const SIMDE_NDEBUG: u32 = 1;
pub const SIMDE_SIZE_MODIFIER: &[u8; 2] = b"z\0";
pub const SIMDE_CHAR_MODIFIER: &[u8; 3] = b"hh\0";
pub const SIMDE_SHORT_MODIFIER: &[u8; 2] = b"h\0";
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const SIMDE_MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const SIMDE_MM_FROUND_TO_NEG_INF: u32 = 1;
pub const SIMDE_MM_FROUND_TO_POS_INF: u32 = 2;
pub const SIMDE_MM_FROUND_TO_ZERO: u32 = 3;
pub const SIMDE_MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const SIMDE_MM_FROUND_RAISE_EXC: u32 = 0;
pub const SIMDE_MM_FROUND_NO_EXC: u32 = 8;
pub const SIMDE_MM_FROUND_NINT: u32 = 0;
pub const SIMDE_MM_FROUND_FLOOR: u32 = 1;
pub const SIMDE_MM_FROUND_CEIL: u32 = 2;
pub const SIMDE_MM_FROUND_TRUNC: u32 = 3;
pub const SIMDE_MM_FROUND_RINT: u32 = 4;
pub const SIMDE_MM_FROUND_NEARBYINT: u32 = 12;
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const SIMDE_MM_HINT_NTA: u32 = 0;
pub const SIMDE_MM_HINT_T0: u32 = 1;
pub const SIMDE_MM_HINT_T1: u32 = 2;
pub const SIMDE_MM_HINT_T2: u32 = 3;
pub const SIMDE_MM_HINT_ENTA: u32 = 4;
pub const SIMDE_MM_HINT_ET0: u32 = 5;
pub const SIMDE_MM_HINT_ET1: u32 = 6;
pub const SIMDE_MM_HINT_ET2: u32 = 7;
pub const SIMDE_MM_EXCEPT_INVALID: u32 = 1;
pub const SIMDE_MM_EXCEPT_DENORM: u32 = 2;
pub const SIMDE_MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const SIMDE_MM_EXCEPT_OVERFLOW: u32 = 8;
pub const SIMDE_MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const SIMDE_MM_EXCEPT_INEXACT: u32 = 32;
pub const SIMDE_MM_EXCEPT_MASK: u32 = 63;
pub const SIMDE_MM_MASK_INVALID: u32 = 128;
pub const SIMDE_MM_MASK_DENORM: u32 = 256;
pub const SIMDE_MM_MASK_DIV_ZERO: u32 = 512;
pub const SIMDE_MM_MASK_OVERFLOW: u32 = 1024;
pub const SIMDE_MM_MASK_UNDERFLOW: u32 = 2048;
pub const SIMDE_MM_MASK_INEXACT: u32 = 4096;
pub const SIMDE_MM_MASK_MASK: u32 = 8064;
pub const SIMDE_MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const SIMDE_MM_FLUSH_ZERO_ON: u32 = 32768;
pub const SIMDE_MM_FLUSH_ZERO_OFF: u32 = 0;
pub const MAX_AV_PLANES: u32 = 8;
pub const MAX_AUDIO_MIXES: u32 = 6;
pub const MAX_AUDIO_CHANNELS: u32 = 8;
pub const AUDIO_OUTPUT_FRAMES: u32 = 1024;
pub const AUDIO_OUTPUT_SUCCESS: u32 = 0;
pub const AUDIO_OUTPUT_INVALIDPARAM: i32 = -1;
pub const AUDIO_OUTPUT_FAIL: i32 = -2;
pub const VIDEO_OUTPUT_SUCCESS: u32 = 0;
pub const VIDEO_OUTPUT_INVALIDPARAM: i32 = -1;
pub const VIDEO_OUTPUT_FAIL: i32 = -2;
pub const CALL_PARAM_IN: u32 = 1;
pub const CALL_PARAM_OUT: u32 = 2;
pub const LIBOBS_API_MAJOR_VER: u32 = 29;
pub const LIBOBS_API_MINOR_VER: u32 = 1;
pub const LIBOBS_API_PATCH_VER: u32 = 3;
pub const OBS_VERSION: &[u8; 8] = b"unknown\0";
pub const OBS_DATA_PATH: &[u8; 11] = b"../../data\0";
pub const OBS_INSTALL_PREFIX: &[u8; 1] = b"\0";
pub const OBS_PLUGIN_DESTINATION: &[u8; 12] = b"obs-plugins\0";
pub const OBS_RELATIVE_PREFIX: &[u8; 7] = b"../../\0";
pub const OBS_RELEASE_CANDIDATE_MAJOR: u32 = 0;
pub const OBS_RELEASE_CANDIDATE_MINOR: u32 = 0;
pub const OBS_RELEASE_CANDIDATE_PATCH: u32 = 0;
pub const OBS_RELEASE_CANDIDATE_VER: u32 = 0;
pub const OBS_RELEASE_CANDIDATE: u32 = 0;
pub const OBS_BETA_MAJOR: u32 = 0;
pub const OBS_BETA_MINOR: u32 = 0;
pub const OBS_BETA_PATCH: u32 = 0;
pub const OBS_BETA_VER: u32 = 0;
pub const OBS_BETA: u32 = 0;
pub const OBS_INSTALL_DATA_PATH: &[u8; 11] = b"../../data\0";
pub const MAX_CHANNELS: u32 = 64;
pub const OBS_ALIGN_CENTER: u32 = 0;
pub const OBS_ALIGN_LEFT: u32 = 1;
pub const OBS_ALIGN_RIGHT: u32 = 2;
pub const OBS_ALIGN_TOP: u32 = 4;
pub const OBS_ALIGN_BOTTOM: u32 = 8;
pub const MODULE_SUCCESS: u32 = 0;
pub const MODULE_ERROR: i32 = -1;
pub const MODULE_FILE_NOT_FOUND: i32 = -2;
pub const MODULE_MISSING_EXPORTS: i32 = -3;
pub const MODULE_INCOMPATIBLE_VER: i32 = -4;
pub const MODULE_HARDCODED_SKIP: i32 = -5;
pub const OBS_OUTPUT_SUCCESS: u32 = 0;
pub const OBS_OUTPUT_BAD_PATH: i32 = -1;
pub const OBS_OUTPUT_CONNECT_FAILED: i32 = -2;
pub const OBS_OUTPUT_INVALID_STREAM: i32 = -3;
pub const OBS_OUTPUT_ERROR: i32 = -4;
pub const OBS_OUTPUT_DISCONNECTED: i32 = -5;
pub const OBS_OUTPUT_UNSUPPORTED: i32 = -6;
pub const OBS_OUTPUT_NO_SPACE: i32 = -7;
pub const OBS_OUTPUT_ENCODE_ERROR: i32 = -8;
pub const OBS_OUTPUT_HDR_DISABLED: i32 = -9;
pub const OBS_VIDEO_SUCCESS: u32 = 0;
pub const OBS_VIDEO_FAIL: i32 = -1;
pub const OBS_VIDEO_NOT_SUPPORTED: i32 = -2;
pub const OBS_VIDEO_INVALID_PARAM: i32 = -3;
pub const OBS_VIDEO_CURRENTLY_ACTIVE: i32 = -4;
pub const OBS_VIDEO_MODULE_NOT_FOUND: i32 = -5;
pub const OBS_UI_SUCCESS: u32 = 0;
pub const OBS_UI_CANCEL: i32 = -1;
pub const OBS_UI_NOTFOUND: i32 = -2;
pub const OBS_PROPERTIES_DEFER_UPDATE: u32 = 1;
pub const OBS_FONT_BOLD: u32 = 1;
pub const OBS_FONT_ITALIC: u32 = 2;
pub const OBS_FONT_UNDERLINE: u32 = 4;
pub const OBS_FONT_STRIKEOUT: u32 = 8;
pub const OBS_SOURCE_VIDEO: u32 = 1;
pub const OBS_SOURCE_AUDIO: u32 = 2;
pub const OBS_SOURCE_ASYNC: u32 = 4;
pub const OBS_SOURCE_ASYNC_VIDEO: u32 = 5;
pub const OBS_SOURCE_CUSTOM_DRAW: u32 = 8;
pub const OBS_SOURCE_INTERACTION: u32 = 32;
pub const OBS_SOURCE_COMPOSITE: u32 = 64;
pub const OBS_SOURCE_DO_NOT_DUPLICATE: u32 = 128;
pub const OBS_SOURCE_DEPRECATED: u32 = 256;
pub const OBS_SOURCE_DO_NOT_SELF_MONITOR: u32 = 512;
pub const OBS_SOURCE_CAP_DISABLED: u32 = 1024;
pub const OBS_SOURCE_CAP_OBSOLETE: u32 = 1024;
pub const OBS_SOURCE_MONITOR_BY_DEFAULT: u32 = 2048;
pub const OBS_SOURCE_SUBMIX: u32 = 4096;
pub const OBS_SOURCE_CONTROLLABLE_MEDIA: u32 = 8192;
pub const OBS_SOURCE_CEA_708: u32 = 16384;
pub const OBS_SOURCE_SRGB: u32 = 32768;
pub const OBS_SOURCE_CAP_DONT_SHOW_PROPERTIES: u32 = 65536;
pub const OBS_ENCODER_CAP_DEPRECATED: u32 = 1;
pub const OBS_ENCODER_CAP_PASS_TEXTURE: u32 = 2;
pub const OBS_ENCODER_CAP_DYN_BITRATE: u32 = 4;
pub const OBS_ENCODER_CAP_INTERNAL: u32 = 8;
pub const OBS_OUTPUT_VIDEO: u32 = 1;
pub const OBS_OUTPUT_AUDIO: u32 = 2;
pub const OBS_OUTPUT_AV: u32 = 3;
pub const OBS_OUTPUT_ENCODED: u32 = 4;
pub const OBS_OUTPUT_SERVICE: u32 = 8;
pub const OBS_OUTPUT_MULTI_TRACK: u32 = 16;
pub const OBS_OUTPUT_CAN_PAUSE: u32 = 32;
pub const MAX_OUTPUT_AUDIO_ENCODERS: u32 = 6;
pub const XINPUT_MOUSE_LEN: u32 = 33;
pub const OBS_MOUSE_BUTTON_DEFAULT: u32 = 1;
pub const OBS_SOURCE_FRAME_LINEAR_ALPHA: u32 = 1;
pub const OBS_SOURCE_FLAG_UNUSED_1: u32 = 1;
pub const OBS_SOURCE_FLAG_FORCE_MONO: u32 = 2;
pub const OBS_OUTPUT_DELAY_PRESERVE: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
#[doc = " Use if there's a problem that can potentially affect the program,\n but isn't enough to require termination of the program.\n\n Use in creation functions and core subsystem functions.  Places that\n should definitely not fail."]
pub const LOG_ERROR: _bindgen_ty_1 = 100;
#[doc = " Use if a problem occurs that doesn't affect the program and is\n recoverable.\n\n Use in places where failure isn't entirely unexpected, and can\n be handled safely."]
pub const LOG_WARNING: _bindgen_ty_1 = 200;
#[doc = " Informative message to be displayed in the log."]
pub const LOG_INFO: _bindgen_ty_1 = 300;
#[doc = " Debug message to be used mostly by developers."]
pub const LOG_DEBUG: _bindgen_ty_1 = 400;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type log_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        lvl: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
        p: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn base_get_log_handler(
        handler: *mut log_handler_t,
        param: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn base_set_log_handler(handler: log_handler_t, param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn base_set_crash_handler(
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut __va_list_tag,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn blogva(
        log_level: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn blog(log_level: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn bcrash(format: *const ::std::os::raw::c_char, ...) -> !;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mbstate_t = __mbstate_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslcpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn wcslcat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn wcscoll_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(
        __wcs: *const ::std::os::raw::c_int,
        __wc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(
        __s: *const ::std::os::raw::c_int,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemmove(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> u128;
}
extern "C" {
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize) -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(
        __ws: *mut wchar_t,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: usize,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct base_allocator {
    pub malloc:
        ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_base_allocator() {
    const UNINIT: ::std::mem::MaybeUninit<base_allocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<base_allocator>(),
        24usize,
        concat!("Size of: ", stringify!(base_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<base_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(base_allocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(base_allocator),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(base_allocator),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(base_allocator),
            "::",
            stringify!(free)
        )
    );
}
extern "C" {
    pub fn base_set_allocator(defs: *mut base_allocator);
}
extern "C" {
    pub fn bmalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn brealloc(ptr: *mut ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bfree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn base_get_alignment() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bnum_allocs() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bmemdup(ptr: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct darray {
    pub array: *mut ::std::os::raw::c_void,
    pub num: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_darray() {
    const UNINIT: ::std::mem::MaybeUninit<darray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<darray>(),
        24usize,
        concat!("Size of: ", stringify!(darray))
    );
    assert_eq!(
        ::std::mem::align_of::<darray>(),
        8usize,
        concat!("Alignment of ", stringify!(darray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(darray),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(darray),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(darray),
            "::",
            stringify!(capacity)
        )
    );
}
impl Default for darray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_snapshot {
    _unused: [u8; 0],
}
pub type profiler_snapshot_t = profiler_snapshot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_snapshot_entry {
    _unused: [u8; 0],
}
pub type profiler_snapshot_entry_t = profiler_snapshot_entry;
pub type profiler_time_entry_t = profiler_time_entry;
extern "C" {
    pub fn profile_register_root(
        name: *const ::std::os::raw::c_char,
        expected_time_between_calls: u64,
    );
}
extern "C" {
    pub fn profile_start(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn profile_end(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn profile_reenable_thread();
}
extern "C" {
    pub fn profiler_start();
}
extern "C" {
    pub fn profiler_stop();
}
extern "C" {
    pub fn profiler_print(snap: *mut profiler_snapshot_t);
}
extern "C" {
    pub fn profiler_print_time_between_calls(snap: *mut profiler_snapshot_t);
}
extern "C" {
    pub fn profiler_free();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_name_store {
    _unused: [u8; 0],
}
pub type profiler_name_store_t = profiler_name_store;
extern "C" {
    pub fn profiler_name_store_create() -> *mut profiler_name_store_t;
}
extern "C" {
    pub fn profiler_name_store_free(store: *mut profiler_name_store_t);
}
extern "C" {
    pub fn profile_store_name(
        store: *mut profiler_name_store_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct profiler_time_entry {
    pub time_delta: u64,
    pub count: u64,
}
#[test]
fn bindgen_test_layout_profiler_time_entry() {
    const UNINIT: ::std::mem::MaybeUninit<profiler_time_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<profiler_time_entry>(),
        16usize,
        concat!("Size of: ", stringify!(profiler_time_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<profiler_time_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(profiler_time_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_delta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entry),
            "::",
            stringify!(time_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entry),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union profiler_time_entries_t {
    pub da: darray,
    pub __bindgen_anon_1: profiler_time_entries_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_time_entries_t__bindgen_ty_1 {
    pub array: *mut profiler_time_entry_t,
    pub num: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_profiler_time_entries_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<profiler_time_entries_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<profiler_time_entries_t__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(profiler_time_entries_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<profiler_time_entries_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(profiler_time_entries_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entries_t__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entries_t__bindgen_ty_1),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entries_t__bindgen_ty_1),
            "::",
            stringify!(capacity)
        )
    );
}
impl Default for profiler_time_entries_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_profiler_time_entries_t() {
    const UNINIT: ::std::mem::MaybeUninit<profiler_time_entries_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<profiler_time_entries_t>(),
        24usize,
        concat!("Size of: ", stringify!(profiler_time_entries_t))
    );
    assert_eq!(
        ::std::mem::align_of::<profiler_time_entries_t>(),
        8usize,
        concat!("Alignment of ", stringify!(profiler_time_entries_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).da) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entries_t),
            "::",
            stringify!(da)
        )
    );
}
impl Default for profiler_time_entries_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type profiler_entry_enum_func = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        entry: *mut profiler_snapshot_entry_t,
    ) -> bool,
>;
extern "C" {
    pub fn profile_snapshot_create() -> *mut profiler_snapshot_t;
}
extern "C" {
    pub fn profile_snapshot_free(snap: *mut profiler_snapshot_t);
}
extern "C" {
    pub fn profiler_snapshot_dump_csv(
        snap: *const profiler_snapshot_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn profiler_snapshot_dump_csv_gz(
        snap: *const profiler_snapshot_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn profiler_snapshot_num_roots(snap: *mut profiler_snapshot_t) -> usize;
}
extern "C" {
    pub fn profiler_snapshot_enumerate_roots(
        snap: *mut profiler_snapshot_t,
        func: profiler_entry_enum_func,
        context: *mut ::std::os::raw::c_void,
    );
}
pub type profiler_name_filter_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        remove: *mut bool,
    ) -> bool,
>;
extern "C" {
    pub fn profiler_snapshot_filter_roots(
        snap: *mut profiler_snapshot_t,
        func: profiler_name_filter_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn profiler_snapshot_num_children(entry: *mut profiler_snapshot_entry_t) -> usize;
}
extern "C" {
    pub fn profiler_snapshot_enumerate_children(
        entry: *mut profiler_snapshot_entry_t,
        func: profiler_entry_enum_func,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn profiler_snapshot_entry_name(
        entry: *mut profiler_snapshot_entry_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn profiler_snapshot_entry_times(
        entry: *mut profiler_snapshot_entry_t,
    ) -> *mut profiler_time_entries_t;
}
extern "C" {
    pub fn profiler_snapshot_entry_min_time(entry: *mut profiler_snapshot_entry_t) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_max_time(entry: *mut profiler_snapshot_entry_t) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_overall_count(entry: *mut profiler_snapshot_entry_t) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_times_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> *mut profiler_time_entries_t;
}
extern "C" {
    pub fn profiler_snapshot_entry_expected_time_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_min_time_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_max_time_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_overall_between_calls_count(
        entry: *mut profiler_snapshot_entry_t,
    ) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct text_lookup {
    _unused: [u8; 0],
}
pub type lookup_t = text_lookup;
extern "C" {
    pub fn text_lookup_create(path: *const ::std::os::raw::c_char) -> *mut lookup_t;
}
extern "C" {
    pub fn text_lookup_add(lookup: *mut lookup_t, path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn text_lookup_destroy(lookup: *mut lookup_t);
}
extern "C" {
    pub fn text_lookup_getstr(
        lookup: *mut lookup_t,
        lookup_val: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct input_subsystem {
    _unused: [u8; 0],
}
pub type input_t = input_subsystem;
extern "C" {
    pub fn input_getbuttonstate(input: *mut input_t, button: u32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct axisang {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matrix3 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matrix4 {
    _unused: [u8; 0],
}
pub const gs_draw_mode_GS_POINTS: gs_draw_mode = 0;
pub const gs_draw_mode_GS_LINES: gs_draw_mode = 1;
pub const gs_draw_mode_GS_LINESTRIP: gs_draw_mode = 2;
pub const gs_draw_mode_GS_TRIS: gs_draw_mode = 3;
pub const gs_draw_mode_GS_TRISTRIP: gs_draw_mode = 4;
pub type gs_draw_mode = ::std::os::raw::c_uint;
pub const gs_color_format_GS_UNKNOWN: gs_color_format = 0;
pub const gs_color_format_GS_A8: gs_color_format = 1;
pub const gs_color_format_GS_R8: gs_color_format = 2;
pub const gs_color_format_GS_RGBA: gs_color_format = 3;
pub const gs_color_format_GS_BGRX: gs_color_format = 4;
pub const gs_color_format_GS_BGRA: gs_color_format = 5;
pub const gs_color_format_GS_R10G10B10A2: gs_color_format = 6;
pub const gs_color_format_GS_RGBA16: gs_color_format = 7;
pub const gs_color_format_GS_R16: gs_color_format = 8;
pub const gs_color_format_GS_RGBA16F: gs_color_format = 9;
pub const gs_color_format_GS_RGBA32F: gs_color_format = 10;
pub const gs_color_format_GS_RG16F: gs_color_format = 11;
pub const gs_color_format_GS_RG32F: gs_color_format = 12;
pub const gs_color_format_GS_R16F: gs_color_format = 13;
pub const gs_color_format_GS_R32F: gs_color_format = 14;
pub const gs_color_format_GS_DXT1: gs_color_format = 15;
pub const gs_color_format_GS_DXT3: gs_color_format = 16;
pub const gs_color_format_GS_DXT5: gs_color_format = 17;
pub const gs_color_format_GS_R8G8: gs_color_format = 18;
pub const gs_color_format_GS_RGBA_UNORM: gs_color_format = 19;
pub const gs_color_format_GS_BGRX_UNORM: gs_color_format = 20;
pub const gs_color_format_GS_BGRA_UNORM: gs_color_format = 21;
pub const gs_color_format_GS_RG16: gs_color_format = 22;
pub type gs_color_format = ::std::os::raw::c_uint;
pub const gs_color_space_GS_CS_SRGB: gs_color_space = 0;
pub const gs_color_space_GS_CS_SRGB_16F: gs_color_space = 1;
pub const gs_color_space_GS_CS_709_EXTENDED: gs_color_space = 2;
pub const gs_color_space_GS_CS_709_SCRGB: gs_color_space = 3;
pub type gs_color_space = ::std::os::raw::c_uint;
pub const gs_zstencil_format_GS_ZS_NONE: gs_zstencil_format = 0;
pub const gs_zstencil_format_GS_Z16: gs_zstencil_format = 1;
pub const gs_zstencil_format_GS_Z24_S8: gs_zstencil_format = 2;
pub const gs_zstencil_format_GS_Z32F: gs_zstencil_format = 3;
pub const gs_zstencil_format_GS_Z32F_S8X24: gs_zstencil_format = 4;
pub type gs_zstencil_format = ::std::os::raw::c_uint;
pub const gs_index_type_GS_UNSIGNED_SHORT: gs_index_type = 0;
pub const gs_index_type_GS_UNSIGNED_LONG: gs_index_type = 1;
pub type gs_index_type = ::std::os::raw::c_uint;
pub const gs_cull_mode_GS_BACK: gs_cull_mode = 0;
pub const gs_cull_mode_GS_FRONT: gs_cull_mode = 1;
pub const gs_cull_mode_GS_NEITHER: gs_cull_mode = 2;
pub type gs_cull_mode = ::std::os::raw::c_uint;
pub const gs_blend_type_GS_BLEND_ZERO: gs_blend_type = 0;
pub const gs_blend_type_GS_BLEND_ONE: gs_blend_type = 1;
pub const gs_blend_type_GS_BLEND_SRCCOLOR: gs_blend_type = 2;
pub const gs_blend_type_GS_BLEND_INVSRCCOLOR: gs_blend_type = 3;
pub const gs_blend_type_GS_BLEND_SRCALPHA: gs_blend_type = 4;
pub const gs_blend_type_GS_BLEND_INVSRCALPHA: gs_blend_type = 5;
pub const gs_blend_type_GS_BLEND_DSTCOLOR: gs_blend_type = 6;
pub const gs_blend_type_GS_BLEND_INVDSTCOLOR: gs_blend_type = 7;
pub const gs_blend_type_GS_BLEND_DSTALPHA: gs_blend_type = 8;
pub const gs_blend_type_GS_BLEND_INVDSTALPHA: gs_blend_type = 9;
pub const gs_blend_type_GS_BLEND_SRCALPHASAT: gs_blend_type = 10;
pub type gs_blend_type = ::std::os::raw::c_uint;
pub const gs_blend_op_type_GS_BLEND_OP_ADD: gs_blend_op_type = 0;
pub const gs_blend_op_type_GS_BLEND_OP_SUBTRACT: gs_blend_op_type = 1;
pub const gs_blend_op_type_GS_BLEND_OP_REVERSE_SUBTRACT: gs_blend_op_type = 2;
pub const gs_blend_op_type_GS_BLEND_OP_MIN: gs_blend_op_type = 3;
pub const gs_blend_op_type_GS_BLEND_OP_MAX: gs_blend_op_type = 4;
pub type gs_blend_op_type = ::std::os::raw::c_uint;
pub const gs_depth_test_GS_NEVER: gs_depth_test = 0;
pub const gs_depth_test_GS_LESS: gs_depth_test = 1;
pub const gs_depth_test_GS_LEQUAL: gs_depth_test = 2;
pub const gs_depth_test_GS_EQUAL: gs_depth_test = 3;
pub const gs_depth_test_GS_GEQUAL: gs_depth_test = 4;
pub const gs_depth_test_GS_GREATER: gs_depth_test = 5;
pub const gs_depth_test_GS_NOTEQUAL: gs_depth_test = 6;
pub const gs_depth_test_GS_ALWAYS: gs_depth_test = 7;
pub type gs_depth_test = ::std::os::raw::c_uint;
pub const gs_stencil_side_GS_STENCIL_FRONT: gs_stencil_side = 1;
pub const gs_stencil_side_GS_STENCIL_BACK: gs_stencil_side = 2;
pub const gs_stencil_side_GS_STENCIL_BOTH: gs_stencil_side = 3;
pub type gs_stencil_side = ::std::os::raw::c_uint;
pub const gs_stencil_op_type_GS_KEEP: gs_stencil_op_type = 0;
pub const gs_stencil_op_type_GS_ZERO: gs_stencil_op_type = 1;
pub const gs_stencil_op_type_GS_REPLACE: gs_stencil_op_type = 2;
pub const gs_stencil_op_type_GS_INCR: gs_stencil_op_type = 3;
pub const gs_stencil_op_type_GS_DECR: gs_stencil_op_type = 4;
pub const gs_stencil_op_type_GS_INVERT: gs_stencil_op_type = 5;
pub type gs_stencil_op_type = ::std::os::raw::c_uint;
pub const gs_cube_sides_GS_POSITIVE_X: gs_cube_sides = 0;
pub const gs_cube_sides_GS_NEGATIVE_X: gs_cube_sides = 1;
pub const gs_cube_sides_GS_POSITIVE_Y: gs_cube_sides = 2;
pub const gs_cube_sides_GS_NEGATIVE_Y: gs_cube_sides = 3;
pub const gs_cube_sides_GS_POSITIVE_Z: gs_cube_sides = 4;
pub const gs_cube_sides_GS_NEGATIVE_Z: gs_cube_sides = 5;
pub type gs_cube_sides = ::std::os::raw::c_uint;
pub const gs_sample_filter_GS_FILTER_POINT: gs_sample_filter = 0;
pub const gs_sample_filter_GS_FILTER_LINEAR: gs_sample_filter = 1;
pub const gs_sample_filter_GS_FILTER_ANISOTROPIC: gs_sample_filter = 2;
pub const gs_sample_filter_GS_FILTER_MIN_MAG_POINT_MIP_LINEAR: gs_sample_filter = 3;
pub const gs_sample_filter_GS_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT: gs_sample_filter = 4;
pub const gs_sample_filter_GS_FILTER_MIN_POINT_MAG_MIP_LINEAR: gs_sample_filter = 5;
pub const gs_sample_filter_GS_FILTER_MIN_LINEAR_MAG_MIP_POINT: gs_sample_filter = 6;
pub const gs_sample_filter_GS_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR: gs_sample_filter = 7;
pub const gs_sample_filter_GS_FILTER_MIN_MAG_LINEAR_MIP_POINT: gs_sample_filter = 8;
pub type gs_sample_filter = ::std::os::raw::c_uint;
pub const gs_address_mode_GS_ADDRESS_CLAMP: gs_address_mode = 0;
pub const gs_address_mode_GS_ADDRESS_WRAP: gs_address_mode = 1;
pub const gs_address_mode_GS_ADDRESS_MIRROR: gs_address_mode = 2;
pub const gs_address_mode_GS_ADDRESS_BORDER: gs_address_mode = 3;
pub const gs_address_mode_GS_ADDRESS_MIRRORONCE: gs_address_mode = 4;
pub type gs_address_mode = ::std::os::raw::c_uint;
pub const gs_texture_type_GS_TEXTURE_2D: gs_texture_type = 0;
pub const gs_texture_type_GS_TEXTURE_3D: gs_texture_type = 1;
pub const gs_texture_type_GS_TEXTURE_CUBE: gs_texture_type = 2;
pub type gs_texture_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_device_loss {
    pub device_loss_release:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub device_loss_rebuild: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ::std::os::raw::c_void,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gs_device_loss() {
    const UNINIT: ::std::mem::MaybeUninit<gs_device_loss> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_device_loss>(),
        24usize,
        concat!("Size of: ", stringify!(gs_device_loss))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_device_loss>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_device_loss))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_loss_release) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_device_loss),
            "::",
            stringify!(device_loss_release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_loss_rebuild) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_device_loss),
            "::",
            stringify!(device_loss_rebuild)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_device_loss),
            "::",
            stringify!(data)
        )
    );
}
impl Default for gs_device_loss {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gs_monitor_info {
    pub rotation_degrees: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub cx: ::std::os::raw::c_long,
    pub cy: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_gs_monitor_info() {
    const UNINIT: ::std::mem::MaybeUninit<gs_monitor_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_monitor_info>(),
        40usize,
        concat!("Size of: ", stringify!(gs_monitor_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_monitor_info>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_monitor_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation_degrees) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(rotation_degrees)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(cy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_tvertarray {
    pub width: usize,
    pub array: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gs_tvertarray() {
    const UNINIT: ::std::mem::MaybeUninit<gs_tvertarray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_tvertarray>(),
        16usize,
        concat!("Size of: ", stringify!(gs_tvertarray))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_tvertarray>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_tvertarray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_tvertarray),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_tvertarray),
            "::",
            stringify!(array)
        )
    );
}
impl Default for gs_tvertarray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_vb_data {
    pub num: usize,
    pub points: *mut vec3,
    pub normals: *mut vec3,
    pub tangents: *mut vec3,
    pub colors: *mut u32,
    pub num_tex: usize,
    pub tvarray: *mut gs_tvertarray,
}
#[test]
fn bindgen_test_layout_gs_vb_data() {
    const UNINIT: ::std::mem::MaybeUninit<gs_vb_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_vb_data>(),
        56usize,
        concat!("Size of: ", stringify!(gs_vb_data))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_vb_data>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_vb_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normals) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(normals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tangents) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(tangents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_tex) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(num_tex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tvarray) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(tvarray)
        )
    );
}
impl Default for gs_vb_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_sampler_info {
    pub filter: gs_sample_filter,
    pub address_u: gs_address_mode,
    pub address_v: gs_address_mode,
    pub address_w: gs_address_mode,
    pub max_anisotropy: ::std::os::raw::c_int,
    pub border_color: u32,
}
#[test]
fn bindgen_test_layout_gs_sampler_info() {
    const UNINIT: ::std::mem::MaybeUninit<gs_sampler_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_sampler_info>(),
        24usize,
        concat!("Size of: ", stringify!(gs_sampler_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_sampler_info>(),
        4usize,
        concat!("Alignment of ", stringify!(gs_sampler_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_u) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(address_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(address_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(address_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_anisotropy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(max_anisotropy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_color) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(border_color)
        )
    );
}
impl Default for gs_sampler_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gs_display_mode {
    pub width: u32,
    pub height: u32,
    pub bits: u32,
    pub freq: u32,
}
#[test]
fn bindgen_test_layout_gs_display_mode() {
    const UNINIT: ::std::mem::MaybeUninit<gs_display_mode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_display_mode>(),
        16usize,
        concat!("Size of: ", stringify!(gs_display_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_display_mode>(),
        4usize,
        concat!("Alignment of ", stringify!(gs_display_mode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_display_mode),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_display_mode),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_display_mode),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_display_mode),
            "::",
            stringify!(freq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gs_rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_gs_rect() {
    const UNINIT: ::std::mem::MaybeUninit<gs_rect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_rect>(),
        16usize,
        concat!("Size of: ", stringify!(gs_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(gs_rect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_rect),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_rect),
            "::",
            stringify!(cy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_stage_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_zstencil_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_vertex_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_index_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_sampler_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_swap_chain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_timer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texrender {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_technique {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_pass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct graphics_subsystem {
    _unused: [u8; 0],
}
pub type gs_texture_t = gs_texture;
pub type gs_stagesurf_t = gs_stage_surface;
pub type gs_zstencil_t = gs_zstencil_buffer;
pub type gs_vertbuffer_t = gs_vertex_buffer;
pub type gs_indexbuffer_t = gs_index_buffer;
pub type gs_samplerstate_t = gs_sampler_state;
pub type gs_swapchain_t = gs_swap_chain;
pub type gs_timer_t = gs_timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_timer_range {
    _unused: [u8; 0],
}
pub type gs_timer_range_t = gs_timer_range;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texture_render {
    _unused: [u8; 0],
}
pub type gs_texrender_t = gs_texture_render;
pub type gs_shader_t = gs_shader;
pub type gs_sparam_t = gs_shader_param;
pub type gs_effect_t = gs_effect;
pub type gs_technique_t = gs_effect_technique;
pub type gs_epass_t = gs_effect_pass;
pub type gs_eparam_t = gs_effect_param;
pub type gs_device_t = gs_device;
pub type graphics_t = graphics_subsystem;
pub const gs_shader_param_type_GS_SHADER_PARAM_UNKNOWN: gs_shader_param_type = 0;
pub const gs_shader_param_type_GS_SHADER_PARAM_BOOL: gs_shader_param_type = 1;
pub const gs_shader_param_type_GS_SHADER_PARAM_FLOAT: gs_shader_param_type = 2;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT: gs_shader_param_type = 3;
pub const gs_shader_param_type_GS_SHADER_PARAM_STRING: gs_shader_param_type = 4;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC2: gs_shader_param_type = 5;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC3: gs_shader_param_type = 6;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC4: gs_shader_param_type = 7;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT2: gs_shader_param_type = 8;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT3: gs_shader_param_type = 9;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT4: gs_shader_param_type = 10;
pub const gs_shader_param_type_GS_SHADER_PARAM_MATRIX4X4: gs_shader_param_type = 11;
pub const gs_shader_param_type_GS_SHADER_PARAM_TEXTURE: gs_shader_param_type = 12;
pub type gs_shader_param_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader_texture {
    pub tex: *mut gs_texture_t,
    pub srgb: bool,
}
#[test]
fn bindgen_test_layout_gs_shader_texture() {
    const UNINIT: ::std::mem::MaybeUninit<gs_shader_texture> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_shader_texture>(),
        16usize,
        concat!("Size of: ", stringify!(gs_shader_texture))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_shader_texture>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_shader_texture))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_shader_texture),
            "::",
            stringify!(tex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srgb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_shader_texture),
            "::",
            stringify!(srgb)
        )
    );
}
impl Default for gs_shader_texture {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader_param_info {
    pub type_: gs_shader_param_type,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_gs_shader_param_info() {
    const UNINIT: ::std::mem::MaybeUninit<gs_shader_param_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_shader_param_info>(),
        16usize,
        concat!("Size of: ", stringify!(gs_shader_param_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_shader_param_info>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_shader_param_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_shader_param_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_shader_param_info),
            "::",
            stringify!(name)
        )
    );
}
impl Default for gs_shader_param_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const gs_shader_type_GS_SHADER_VERTEX: gs_shader_type = 0;
pub const gs_shader_type_GS_SHADER_PIXEL: gs_shader_type = 1;
pub type gs_shader_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn gs_shader_destroy(shader: *mut gs_shader_t);
}
extern "C" {
    pub fn gs_shader_get_num_params(shader: *const gs_shader_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gs_shader_get_param_by_idx(shader: *mut gs_shader_t, param: u32) -> *mut gs_sparam_t;
}
extern "C" {
    pub fn gs_shader_get_param_by_name(
        shader: *mut gs_shader_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_sparam_t;
}
extern "C" {
    pub fn gs_shader_get_viewproj_matrix(shader: *const gs_shader_t) -> *mut gs_sparam_t;
}
extern "C" {
    pub fn gs_shader_get_world_matrix(shader: *const gs_shader_t) -> *mut gs_sparam_t;
}
extern "C" {
    pub fn gs_shader_get_param_info(param: *const gs_sparam_t, info: *mut gs_shader_param_info);
}
extern "C" {
    pub fn gs_shader_set_bool(param: *mut gs_sparam_t, val: bool);
}
extern "C" {
    pub fn gs_shader_set_float(param: *mut gs_sparam_t, val: f32);
}
extern "C" {
    pub fn gs_shader_set_int(param: *mut gs_sparam_t, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_shader_set_matrix3(param: *mut gs_sparam_t, val: *const matrix3);
}
extern "C" {
    pub fn gs_shader_set_matrix4(param: *mut gs_sparam_t, val: *const matrix4);
}
extern "C" {
    pub fn gs_shader_set_vec2(param: *mut gs_sparam_t, val: *const vec2);
}
extern "C" {
    pub fn gs_shader_set_vec3(param: *mut gs_sparam_t, val: *const vec3);
}
extern "C" {
    pub fn gs_shader_set_vec4(param: *mut gs_sparam_t, val: *const vec4);
}
extern "C" {
    pub fn gs_shader_set_texture(param: *mut gs_sparam_t, val: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_shader_set_val(
        param: *mut gs_sparam_t,
        val: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    pub fn gs_shader_set_default(param: *mut gs_sparam_t);
}
extern "C" {
    pub fn gs_shader_set_next_sampler(param: *mut gs_sparam_t, sampler: *mut gs_samplerstate_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_param_info {
    pub name: *const ::std::os::raw::c_char,
    pub type_: gs_shader_param_type,
}
#[test]
fn bindgen_test_layout_gs_effect_param_info() {
    const UNINIT: ::std::mem::MaybeUninit<gs_effect_param_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_effect_param_info>(),
        16usize,
        concat!("Size of: ", stringify!(gs_effect_param_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_effect_param_info>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_effect_param_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_effect_param_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_effect_param_info),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for gs_effect_param_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn gs_effect_destroy(effect: *mut gs_effect_t);
}
extern "C" {
    pub fn gs_effect_get_technique(
        effect: *const gs_effect_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_technique_t;
}
extern "C" {
    pub fn gs_effect_get_current_technique(effect: *const gs_effect_t) -> *mut gs_technique_t;
}
extern "C" {
    pub fn gs_technique_begin(technique: *mut gs_technique_t) -> usize;
}
extern "C" {
    pub fn gs_technique_end(technique: *mut gs_technique_t);
}
extern "C" {
    pub fn gs_technique_begin_pass(technique: *mut gs_technique_t, pass: usize) -> bool;
}
extern "C" {
    pub fn gs_technique_begin_pass_by_name(
        technique: *mut gs_technique_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn gs_technique_end_pass(technique: *mut gs_technique_t);
}
extern "C" {
    pub fn gs_technique_get_pass_by_idx(
        technique: *const gs_technique_t,
        pass: usize,
    ) -> *mut gs_epass_t;
}
extern "C" {
    pub fn gs_technique_get_pass_by_name(
        technique: *const gs_technique_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_epass_t;
}
extern "C" {
    pub fn gs_effect_get_num_params(effect: *const gs_effect_t) -> usize;
}
extern "C" {
    pub fn gs_effect_get_param_by_idx(effect: *const gs_effect_t, param: usize)
        -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_effect_get_param_by_name(
        effect: *const gs_effect_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_param_get_num_annotations(param: *const gs_eparam_t) -> usize;
}
extern "C" {
    pub fn gs_param_get_annotation_by_idx(
        param: *const gs_eparam_t,
        annotation: usize,
    ) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_param_get_annotation_by_name(
        param: *const gs_eparam_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_eparam_t;
}
extern "C" {
    #[doc = " Helper function to simplify effect usage.  Use with a while loop that\n contains drawing functions.  Automatically handles techniques, passes, and\n unloading."]
    pub fn gs_effect_loop(effect: *mut gs_effect_t, name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " used internally"]
    pub fn gs_effect_update_params(effect: *mut gs_effect_t);
}
extern "C" {
    pub fn gs_effect_get_viewproj_matrix(effect: *const gs_effect_t) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_effect_get_world_matrix(effect: *const gs_effect_t) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_effect_get_param_info(param: *const gs_eparam_t, info: *mut gs_effect_param_info);
}
extern "C" {
    pub fn gs_effect_set_bool(param: *mut gs_eparam_t, val: bool);
}
extern "C" {
    pub fn gs_effect_set_float(param: *mut gs_eparam_t, val: f32);
}
extern "C" {
    pub fn gs_effect_set_int(param: *mut gs_eparam_t, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_effect_set_matrix4(param: *mut gs_eparam_t, val: *const matrix4);
}
extern "C" {
    pub fn gs_effect_set_vec2(param: *mut gs_eparam_t, val: *const vec2);
}
extern "C" {
    pub fn gs_effect_set_vec3(param: *mut gs_eparam_t, val: *const vec3);
}
extern "C" {
    pub fn gs_effect_set_vec4(param: *mut gs_eparam_t, val: *const vec4);
}
extern "C" {
    pub fn gs_effect_set_texture(param: *mut gs_eparam_t, val: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_effect_set_texture_srgb(param: *mut gs_eparam_t, val: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_effect_set_val(
        param: *mut gs_eparam_t,
        val: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    pub fn gs_effect_set_default(param: *mut gs_eparam_t);
}
extern "C" {
    pub fn gs_effect_get_val_size(param: *mut gs_eparam_t) -> usize;
}
extern "C" {
    pub fn gs_effect_get_val(param: *mut gs_eparam_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_effect_get_default_val_size(param: *mut gs_eparam_t) -> usize;
}
extern "C" {
    pub fn gs_effect_get_default_val(param: *mut gs_eparam_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_effect_set_next_sampler(param: *mut gs_eparam_t, sampler: *mut gs_samplerstate_t);
}
extern "C" {
    pub fn gs_effect_set_color(param: *mut gs_eparam_t, argb: u32);
}
extern "C" {
    pub fn gs_texrender_create(
        format: gs_color_format,
        zsformat: gs_zstencil_format,
    ) -> *mut gs_texrender_t;
}
extern "C" {
    pub fn gs_texrender_destroy(texrender: *mut gs_texrender_t);
}
extern "C" {
    pub fn gs_texrender_begin(texrender: *mut gs_texrender_t, cx: u32, cy: u32) -> bool;
}
extern "C" {
    pub fn gs_texrender_begin_with_color_space(
        texrender: *mut gs_texrender_t,
        cx: u32,
        cy: u32,
        space: gs_color_space,
    ) -> bool;
}
extern "C" {
    pub fn gs_texrender_end(texrender: *mut gs_texrender_t);
}
extern "C" {
    pub fn gs_texrender_reset(texrender: *mut gs_texrender_t);
}
extern "C" {
    pub fn gs_texrender_get_texture(texrender: *const gs_texrender_t) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_texrender_get_format(texrender: *const gs_texrender_t) -> gs_color_format;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_window {
    pub id: u32,
    pub display: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gs_window() {
    const UNINIT: ::std::mem::MaybeUninit<gs_window> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_window>(),
        16usize,
        concat!("Size of: ", stringify!(gs_window))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_window>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_window))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_window),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_window),
            "::",
            stringify!(display)
        )
    );
}
impl Default for gs_window {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_init_data {
    pub window: gs_window,
    pub cx: u32,
    pub cy: u32,
    pub num_backbuffers: u32,
    pub format: gs_color_format,
    pub zsformat: gs_zstencil_format,
    pub adapter: u32,
}
#[test]
fn bindgen_test_layout_gs_init_data() {
    const UNINIT: ::std::mem::MaybeUninit<gs_init_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gs_init_data>(),
        40usize,
        concat!("Size of: ", stringify!(gs_init_data))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_init_data>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_init_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_backbuffers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(num_backbuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zsformat) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(zsformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapter) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(adapter)
        )
    );
}
impl Default for gs_init_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn gs_get_device_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gs_get_device_type() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gs_enum_adapters(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                param: *mut ::std::os::raw::c_void,
                name: *const ::std::os::raw::c_char,
                id: u32,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gs_create(
        graphics: *mut *mut graphics_t,
        module: *const ::std::os::raw::c_char,
        adapter: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gs_destroy(graphics: *mut graphics_t);
}
extern "C" {
    pub fn gs_enter_context(graphics: *mut graphics_t);
}
extern "C" {
    pub fn gs_leave_context();
}
extern "C" {
    pub fn gs_get_context() -> *mut graphics_t;
}
extern "C" {
    pub fn gs_get_device_obj() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_matrix_push();
}
extern "C" {
    pub fn gs_matrix_pop();
}
extern "C" {
    pub fn gs_matrix_identity();
}
extern "C" {
    pub fn gs_matrix_transpose();
}
extern "C" {
    pub fn gs_matrix_set(matrix: *const matrix4);
}
extern "C" {
    pub fn gs_matrix_get(dst: *mut matrix4);
}
extern "C" {
    pub fn gs_matrix_mul(matrix: *const matrix4);
}
extern "C" {
    pub fn gs_matrix_rotquat(rot: *const quat);
}
extern "C" {
    pub fn gs_matrix_rotaa(rot: *const axisang);
}
extern "C" {
    pub fn gs_matrix_translate(pos: *const vec3);
}
extern "C" {
    pub fn gs_matrix_scale(scale: *const vec3);
}
extern "C" {
    pub fn gs_matrix_rotaa4f(x: f32, y: f32, z: f32, angle: f32);
}
extern "C" {
    pub fn gs_matrix_translate3f(x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn gs_matrix_scale3f(x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn gs_render_start(b_new: bool);
}
extern "C" {
    pub fn gs_render_stop(mode: gs_draw_mode);
}
extern "C" {
    pub fn gs_render_save() -> *mut gs_vertbuffer_t;
}
extern "C" {
    pub fn gs_vertex2f(x: f32, y: f32);
}
extern "C" {
    pub fn gs_vertex3f(x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn gs_normal3f(x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn gs_color(color: u32);
}
extern "C" {
    pub fn gs_texcoord(x: f32, y: f32, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_vertex2v(v: *const vec2);
}
extern "C" {
    pub fn gs_vertex3v(v: *const vec3);
}
extern "C" {
    pub fn gs_normal3v(v: *const vec3);
}
extern "C" {
    pub fn gs_color4v(v: *const vec4);
}
extern "C" {
    pub fn gs_texcoord2v(v: *const vec2, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_get_input() -> *mut input_t;
}
extern "C" {
    pub fn gs_get_effect() -> *mut gs_effect_t;
}
extern "C" {
    pub fn gs_effect_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_effect_t;
}
extern "C" {
    pub fn gs_effect_create(
        effect_string: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_effect_t;
}
extern "C" {
    pub fn gs_vertexshader_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_pixelshader_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
}
pub const gs_image_alpha_mode_GS_IMAGE_ALPHA_STRAIGHT: gs_image_alpha_mode = 0;
pub const gs_image_alpha_mode_GS_IMAGE_ALPHA_PREMULTIPLY_SRGB: gs_image_alpha_mode = 1;
pub const gs_image_alpha_mode_GS_IMAGE_ALPHA_PREMULTIPLY: gs_image_alpha_mode = 2;
pub type gs_image_alpha_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn gs_texture_create_from_file(file: *const ::std::os::raw::c_char) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_create_texture_file_data(
        file: *const ::std::os::raw::c_char,
        format: *mut gs_color_format,
        cx: *mut u32,
        cy: *mut u32,
    ) -> *mut u8;
}
extern "C" {
    pub fn gs_create_texture_file_data2(
        file: *const ::std::os::raw::c_char,
        alpha_mode: gs_image_alpha_mode,
        format: *mut gs_color_format,
        cx: *mut u32,
        cy: *mut u32,
    ) -> *mut u8;
}
extern "C" {
    pub fn gs_create_texture_file_data3(
        file: *const ::std::os::raw::c_char,
        alpha_mode: gs_image_alpha_mode,
        format: *mut gs_color_format,
        cx: *mut u32,
        cy: *mut u32,
        space: *mut gs_color_space,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Draws a 2D sprite\n\n   If width or height is 0, the width or height of the texture will be used.\n The flip value specifies whether the texture should be flipped on the U or V\n axis with GS_FLIP_U and GS_FLIP_V."]
    pub fn gs_draw_sprite(tex: *mut gs_texture_t, flip: u32, width: u32, height: u32);
}
extern "C" {
    pub fn gs_draw_sprite_subregion(
        tex: *mut gs_texture_t,
        flip: u32,
        x: u32,
        y: u32,
        cx: u32,
        cy: u32,
    );
}
extern "C" {
    pub fn gs_draw_cube_backdrop(
        cubetex: *mut gs_texture_t,
        rot: *const quat,
        left: f32,
        right: f32,
        top: f32,
        bottom: f32,
        znear: f32,
    );
}
extern "C" {
    #[doc = " sets the viewport to current swap chain size"]
    pub fn gs_reset_viewport();
}
extern "C" {
    #[doc = " sets default screen-sized orthographic mode"]
    pub fn gs_set_2d_mode();
}
extern "C" {
    #[doc = " sets default screen-sized perspective mode"]
    pub fn gs_set_3d_mode(fovy: f64, znear: f64, zvar: f64);
}
extern "C" {
    pub fn gs_viewport_push();
}
extern "C" {
    pub fn gs_viewport_pop();
}
extern "C" {
    pub fn gs_texture_set_image(
        tex: *mut gs_texture_t,
        data: *const u8,
        linesize: u32,
        invert: bool,
    );
}
extern "C" {
    pub fn gs_cubetexture_set_image(
        cubetex: *mut gs_texture_t,
        side: u32,
        data: *const ::std::os::raw::c_void,
        linesize: u32,
        invert: bool,
    );
}
extern "C" {
    pub fn gs_perspective(fovy: f32, aspect: f32, znear: f32, zfar: f32);
}
extern "C" {
    pub fn gs_blend_state_push();
}
extern "C" {
    pub fn gs_blend_state_pop();
}
extern "C" {
    pub fn gs_reset_blend_state();
}
extern "C" {
    pub fn gs_swapchain_create(data: *const gs_init_data) -> *mut gs_swapchain_t;
}
extern "C" {
    pub fn gs_resize(x: u32, y: u32);
}
extern "C" {
    pub fn gs_update_color_space();
}
extern "C" {
    pub fn gs_get_size(x: *mut u32, y: *mut u32);
}
extern "C" {
    pub fn gs_get_width() -> u32;
}
extern "C" {
    pub fn gs_get_height() -> u32;
}
extern "C" {
    pub fn gs_texture_create(
        width: u32,
        height: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_cubetexture_create(
        size: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_voltexture_create(
        width: u32,
        height: u32,
        depth: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_zstencil_create(
        width: u32,
        height: u32,
        format: gs_zstencil_format,
    ) -> *mut gs_zstencil_t;
}
extern "C" {
    pub fn gs_stagesurface_create(
        width: u32,
        height: u32,
        color_format: gs_color_format,
    ) -> *mut gs_stagesurf_t;
}
extern "C" {
    pub fn gs_samplerstate_create(info: *const gs_sampler_info) -> *mut gs_samplerstate_t;
}
extern "C" {
    pub fn gs_vertexshader_create(
        shader: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_pixelshader_create(
        shader: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_vertexbuffer_create(data: *mut gs_vb_data, flags: u32) -> *mut gs_vertbuffer_t;
}
extern "C" {
    pub fn gs_indexbuffer_create(
        type_: gs_index_type,
        indices: *mut ::std::os::raw::c_void,
        num: usize,
        flags: u32,
    ) -> *mut gs_indexbuffer_t;
}
extern "C" {
    pub fn gs_timer_create() -> *mut gs_timer_t;
}
extern "C" {
    pub fn gs_timer_range_create() -> *mut gs_timer_range_t;
}
extern "C" {
    pub fn gs_get_texture_type(texture: *const gs_texture_t) -> gs_texture_type;
}
extern "C" {
    pub fn gs_load_vertexbuffer(vertbuffer: *mut gs_vertbuffer_t);
}
extern "C" {
    pub fn gs_load_indexbuffer(indexbuffer: *mut gs_indexbuffer_t);
}
extern "C" {
    pub fn gs_load_texture(tex: *mut gs_texture_t, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_load_samplerstate(samplerstate: *mut gs_samplerstate_t, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_load_vertexshader(vertshader: *mut gs_shader_t);
}
extern "C" {
    pub fn gs_load_pixelshader(pixelshader: *mut gs_shader_t);
}
extern "C" {
    pub fn gs_load_default_samplerstate(b_3d: bool, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_get_vertex_shader() -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_get_pixel_shader() -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_get_color_space() -> gs_color_space;
}
extern "C" {
    pub fn gs_get_render_target() -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_get_zstencil_target() -> *mut gs_zstencil_t;
}
extern "C" {
    pub fn gs_set_render_target(tex: *mut gs_texture_t, zstencil: *mut gs_zstencil_t);
}
extern "C" {
    pub fn gs_set_render_target_with_color_space(
        tex: *mut gs_texture_t,
        zstencil: *mut gs_zstencil_t,
        space: gs_color_space,
    );
}
extern "C" {
    pub fn gs_set_cube_render_target(
        cubetex: *mut gs_texture_t,
        side: ::std::os::raw::c_int,
        zstencil: *mut gs_zstencil_t,
    );
}
extern "C" {
    pub fn gs_enable_framebuffer_srgb(enable: bool);
}
extern "C" {
    pub fn gs_framebuffer_srgb_enabled() -> bool;
}
extern "C" {
    pub fn gs_get_linear_srgb() -> bool;
}
extern "C" {
    pub fn gs_set_linear_srgb(linear_srgb: bool) -> bool;
}
extern "C" {
    pub fn gs_copy_texture(dst: *mut gs_texture_t, src: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_copy_texture_region(
        dst: *mut gs_texture_t,
        dst_x: u32,
        dst_y: u32,
        src: *mut gs_texture_t,
        src_x: u32,
        src_y: u32,
        src_w: u32,
        src_h: u32,
    );
}
extern "C" {
    pub fn gs_stage_texture(dst: *mut gs_stagesurf_t, src: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_begin_frame();
}
extern "C" {
    pub fn gs_begin_scene();
}
extern "C" {
    pub fn gs_draw(draw_mode: gs_draw_mode, start_vert: u32, num_verts: u32);
}
extern "C" {
    pub fn gs_end_scene();
}
extern "C" {
    pub fn gs_load_swapchain(swapchain: *mut gs_swapchain_t);
}
extern "C" {
    pub fn gs_clear(clear_flags: u32, color: *const vec4, depth: f32, stencil: u8);
}
extern "C" {
    pub fn gs_is_present_ready() -> bool;
}
extern "C" {
    pub fn gs_present();
}
extern "C" {
    pub fn gs_flush();
}
extern "C" {
    pub fn gs_set_cull_mode(mode: gs_cull_mode);
}
extern "C" {
    pub fn gs_get_cull_mode() -> gs_cull_mode;
}
extern "C" {
    pub fn gs_enable_blending(enable: bool);
}
extern "C" {
    pub fn gs_enable_depth_test(enable: bool);
}
extern "C" {
    pub fn gs_enable_stencil_test(enable: bool);
}
extern "C" {
    pub fn gs_enable_stencil_write(enable: bool);
}
extern "C" {
    pub fn gs_enable_color(red: bool, green: bool, blue: bool, alpha: bool);
}
extern "C" {
    pub fn gs_blend_function(src: gs_blend_type, dest: gs_blend_type);
}
extern "C" {
    pub fn gs_blend_function_separate(
        src_c: gs_blend_type,
        dest_c: gs_blend_type,
        src_a: gs_blend_type,
        dest_a: gs_blend_type,
    );
}
extern "C" {
    pub fn gs_blend_op(op: gs_blend_op_type);
}
extern "C" {
    pub fn gs_depth_function(test: gs_depth_test);
}
extern "C" {
    pub fn gs_stencil_function(side: gs_stencil_side, test: gs_depth_test);
}
extern "C" {
    pub fn gs_stencil_op(
        side: gs_stencil_side,
        fail: gs_stencil_op_type,
        zfail: gs_stencil_op_type,
        zpass: gs_stencil_op_type,
    );
}
extern "C" {
    pub fn gs_set_viewport(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gs_get_viewport(rect: *mut gs_rect);
}
extern "C" {
    pub fn gs_set_scissor_rect(rect: *const gs_rect);
}
extern "C" {
    pub fn gs_ortho(left: f32, right: f32, top: f32, bottom: f32, znear: f32, zfar: f32);
}
extern "C" {
    pub fn gs_frustum(left: f32, right: f32, top: f32, bottom: f32, znear: f32, zfar: f32);
}
extern "C" {
    pub fn gs_projection_push();
}
extern "C" {
    pub fn gs_projection_pop();
}
extern "C" {
    pub fn gs_swapchain_destroy(swapchain: *mut gs_swapchain_t);
}
extern "C" {
    pub fn gs_texture_destroy(tex: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_texture_get_width(tex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_texture_get_height(tex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_texture_get_color_format(tex: *const gs_texture_t) -> gs_color_format;
}
extern "C" {
    pub fn gs_texture_map(tex: *mut gs_texture_t, ptr: *mut *mut u8, linesize: *mut u32) -> bool;
}
extern "C" {
    pub fn gs_texture_unmap(tex: *mut gs_texture_t);
}
extern "C" {
    #[doc = " special-case function (GL only) - specifies whether the texture is a\n GL_TEXTURE_RECTANGLE type, which doesn't use normalized texture\n coordinates, doesn't support mipmapping, and requires address clamping"]
    pub fn gs_texture_is_rect(tex: *const gs_texture_t) -> bool;
}
extern "C" {
    #[doc = " Gets a pointer to the context-specific object associated with the texture.\n For example, for GL, this is a GLuint*.  For D3D11, ID3D11Texture2D*."]
    pub fn gs_texture_get_obj(tex: *mut gs_texture_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_cubetexture_destroy(cubetex: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_cubetexture_get_size(cubetex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_cubetexture_get_color_format(cubetex: *const gs_texture_t) -> gs_color_format;
}
extern "C" {
    pub fn gs_voltexture_destroy(voltex: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_voltexture_get_width(voltex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_voltexture_get_height(voltex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_voltexture_get_depth(voltex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_voltexture_get_color_format(voltex: *const gs_texture_t) -> gs_color_format;
}
extern "C" {
    pub fn gs_stagesurface_destroy(stagesurf: *mut gs_stagesurf_t);
}
extern "C" {
    pub fn gs_stagesurface_get_width(stagesurf: *const gs_stagesurf_t) -> u32;
}
extern "C" {
    pub fn gs_stagesurface_get_height(stagesurf: *const gs_stagesurf_t) -> u32;
}
extern "C" {
    pub fn gs_stagesurface_get_color_format(stagesurf: *const gs_stagesurf_t) -> gs_color_format;
}
extern "C" {
    pub fn gs_stagesurface_map(
        stagesurf: *mut gs_stagesurf_t,
        data: *mut *mut u8,
        linesize: *mut u32,
    ) -> bool;
}
extern "C" {
    pub fn gs_stagesurface_unmap(stagesurf: *mut gs_stagesurf_t);
}
extern "C" {
    pub fn gs_zstencil_destroy(zstencil: *mut gs_zstencil_t);
}
extern "C" {
    pub fn gs_samplerstate_destroy(samplerstate: *mut gs_samplerstate_t);
}
extern "C" {
    pub fn gs_vertexbuffer_destroy(vertbuffer: *mut gs_vertbuffer_t);
}
extern "C" {
    pub fn gs_vertexbuffer_flush(vertbuffer: *mut gs_vertbuffer_t);
}
extern "C" {
    pub fn gs_vertexbuffer_flush_direct(vertbuffer: *mut gs_vertbuffer_t, data: *const gs_vb_data);
}
extern "C" {
    pub fn gs_vertexbuffer_get_data(vertbuffer: *const gs_vertbuffer_t) -> *mut gs_vb_data;
}
extern "C" {
    pub fn gs_indexbuffer_destroy(indexbuffer: *mut gs_indexbuffer_t);
}
extern "C" {
    pub fn gs_indexbuffer_flush(indexbuffer: *mut gs_indexbuffer_t);
}
extern "C" {
    pub fn gs_indexbuffer_flush_direct(
        indexbuffer: *mut gs_indexbuffer_t,
        data: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gs_indexbuffer_get_data(
        indexbuffer: *const gs_indexbuffer_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_indexbuffer_get_num_indices(indexbuffer: *const gs_indexbuffer_t) -> usize;
}
extern "C" {
    pub fn gs_indexbuffer_get_type(indexbuffer: *const gs_indexbuffer_t) -> gs_index_type;
}
extern "C" {
    pub fn gs_timer_destroy(timer: *mut gs_timer_t);
}
extern "C" {
    pub fn gs_timer_begin(timer: *mut gs_timer_t);
}
extern "C" {
    pub fn gs_timer_end(timer: *mut gs_timer_t);
}
extern "C" {
    pub fn gs_timer_get_data(timer: *mut gs_timer_t, ticks: *mut u64) -> bool;
}
extern "C" {
    pub fn gs_timer_range_destroy(timer: *mut gs_timer_range_t);
}
extern "C" {
    pub fn gs_timer_range_begin(range: *mut gs_timer_range_t);
}
extern "C" {
    pub fn gs_timer_range_end(range: *mut gs_timer_range_t);
}
extern "C" {
    pub fn gs_timer_range_get_data(
        range: *mut gs_timer_range_t,
        disjoint: *mut bool,
        frequency: *mut u64,
    ) -> bool;
}
extern "C" {
    pub fn gs_nv12_available() -> bool;
}
extern "C" {
    pub fn gs_p010_available() -> bool;
}
extern "C" {
    pub fn gs_is_monitor_hdr(monitor: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn gs_debug_marker_begin(color: *const f32, markername: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gs_debug_marker_begin_format(
        color: *const f32,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn gs_debug_marker_end();
}
extern "C" {
    pub fn gs_texture_create_from_dmabuf(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        drm_format: u32,
        color_format: gs_color_format,
        n_planes: u32,
        fds: *const ::std::os::raw::c_int,
        strides: *const u32,
        offsets: *const u32,
        modifiers: *const u64,
    ) -> *mut gs_texture_t;
}
pub const gs_dmabuf_flags_GS_DMABUF_FLAG_NONE: gs_dmabuf_flags = 0;
pub const gs_dmabuf_flags_GS_DMABUF_FLAG_IMPLICIT_MODIFIERS_SUPPORTED: gs_dmabuf_flags = 1;
pub type gs_dmabuf_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn gs_query_dmabuf_capabilities(
        dmabuf_flags: *mut gs_dmabuf_flags,
        drm_formats: *mut *mut u32,
        n_formats: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn gs_query_dmabuf_modifiers_for_format(
        drm_format: u32,
        modifiers: *mut *mut u64,
        n_modifiers: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn gs_texture_create_from_pixmap(
        width: u32,
        height: u32,
        color_format: gs_color_format,
        target: u32,
        pixmap: *mut ::std::os::raw::c_void,
    ) -> *mut gs_texture_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vec2 {
    pub __bindgen_anon_1: vec2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vec2__bindgen_ty_1 {
    pub __bindgen_anon_1: vec2__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vec2__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_vec2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vec2__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vec2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vec2__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vec2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vec2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout_vec2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vec2__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vec2__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vec2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec2__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(vec2__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec2__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
impl Default for vec2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vec2() {
    assert_eq!(
        ::std::mem::size_of::<vec2>(),
        8usize,
        concat!("Size of: ", stringify!(vec2))
    );
    assert_eq!(
        ::std::mem::align_of::<vec2>(),
        4usize,
        concat!("Alignment of ", stringify!(vec2))
    );
}
impl Default for vec2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn vec2_abs(dst: *mut vec2, v: *const vec2);
}
extern "C" {
    pub fn vec2_floor(dst: *mut vec2, v: *const vec2);
}
extern "C" {
    pub fn vec2_ceil(dst: *mut vec2, v: *const vec2);
}
extern "C" {
    pub fn vec2_close(v1: *const vec2, v2: *const vec2, epsilon: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vec2_norm(dst: *mut vec2, v: *const vec2);
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type __v8hf = u128;
pub type __m128h = u128;
pub type __m128h_u = u128;
pub type __v8bf = u128;
pub type __m128bh = u128;
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
pub type simde_cfloat32 = __BindgenComplex<f32>;
pub type simde_cfloat64 = __BindgenComplex<f64>;
pub type simde_int128 = i128;
pub type simde_uint128 = u128;
pub type simde_float32 = f32;
pub type simde_float64 = f64;
pub type fexcept_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fenv_t {
    pub __control_word: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: ::std::os::raw::c_ushort,
    pub __status_word: ::std::os::raw::c_ushort,
    pub __glibc_reserved2: ::std::os::raw::c_ushort,
    pub __tags: ::std::os::raw::c_ushort,
    pub __glibc_reserved3: ::std::os::raw::c_ushort,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs_selector: ::std::os::raw::c_ushort,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __data_offset: ::std::os::raw::c_uint,
    pub __data_selector: ::std::os::raw::c_ushort,
    pub __glibc_reserved5: ::std::os::raw::c_ushort,
    pub __mxcsr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_fenv_t() {
    const UNINIT: ::std::mem::MaybeUninit<fenv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fenv_t>(),
        32usize,
        concat!("Size of: ", stringify!(fenv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<fenv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(fenv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__control_word) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__control_word)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__status_word) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__status_word)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved2) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__tags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__tags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved3) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__glibc_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__eip) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cs_selector) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__cs_selector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data_offset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__data_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data_selector) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__data_selector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved5) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__glibc_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mxcsr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fenv_t),
            "::",
            stringify!(__mxcsr)
        )
    );
}
impl fenv_t {
    #[inline]
    pub fn __opcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set___opcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn __glibc_reserved4(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set___glibc_reserved4(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __opcode: ::std::os::raw::c_uint,
        __glibc_reserved4: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let __opcode: u32 = unsafe { ::std::mem::transmute(__opcode) };
            __opcode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let __glibc_reserved4: u32 = unsafe { ::std::mem::transmute(__glibc_reserved4) };
            __glibc_reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn feclearexcept(__excepts: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fegetexceptflag(
        __flagp: *mut fexcept_t,
        __excepts: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feraiseexcept(__excepts: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fesetexceptflag(
        __flagp: *const fexcept_t,
        __excepts: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fetestexcept(__excepts: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fegetround() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fesetround(__rounding_direction: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fegetenv(__envp: *mut fenv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feholdexcept(__envp: *mut fenv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fesetenv(__envp: *const fenv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feupdateenv(__envp: *const fenv_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos64_t = _G_fpos64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union simde__m64_private {
    pub i8_: [i8; 8usize],
    pub i16_: [i16; 4usize],
    pub i32_: [i32; 2usize],
    pub i64_: [i64; 1usize],
    pub u8_: [u8; 8usize],
    pub u16_: [u16; 4usize],
    pub u32_: [u32; 2usize],
    pub u64_: [u64; 1usize],
    pub f32_: [simde_float32; 2usize],
    pub i32f: [int_fast32_t; 1usize],
    pub u32f: [uint_fast32_t; 1usize],
    pub n: __m64,
}
#[test]
fn bindgen_test_layout_simde__m64_private() {
    const UNINIT: ::std::mem::MaybeUninit<simde__m64_private> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<simde__m64_private>(),
        8usize,
        concat!("Size of: ", stringify!(simde__m64_private))
    );
    assert_eq!(
        ::std::mem::align_of::<simde__m64_private>(),
        8usize,
        concat!("Alignment of ", stringify!(simde__m64_private))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(i8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(f32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(i32f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(u32f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m64_private),
            "::",
            stringify!(n)
        )
    );
}
impl Default for simde__m64_private {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type simde__m64 = __m64;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union simde__m128_private {
    pub i8_: [i8; 16usize],
    pub i16_: [i16; 8usize],
    pub i32_: [i32; 4usize],
    pub i64_: [i64; 2usize],
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub i128_: [simde_int128; 1usize],
    pub u128_: [simde_uint128; 1usize],
    pub f32_: [simde_float32; 4usize],
    pub i32f: [int_fast32_t; 2usize],
    pub u32f: [uint_fast32_t; 2usize],
    pub m64_private: [simde__m64_private; 2usize],
    pub m64: [simde__m64; 2usize],
    pub n: __m128,
}
#[test]
fn bindgen_test_layout_simde__m128_private() {
    const UNINIT: ::std::mem::MaybeUninit<simde__m128_private> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<simde__m128_private>(),
        16usize,
        concat!("Size of: ", stringify!(simde__m128_private))
    );
    assert_eq!(
        ::std::mem::align_of::<simde__m128_private>(),
        16usize,
        concat!("Alignment of ", stringify!(simde__m128_private))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(i8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i128_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(i128_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u128_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(u128_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(f32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(i32f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(u32f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m64_private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(m64_private)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(m64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128_private),
            "::",
            stringify!(n)
        )
    );
}
impl Default for simde__m128_private {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type simde__m128 = __m128;
pub const SIMDE_MM_ROUND_NEAREST: _bindgen_ty_5 = 0;
pub const SIMDE_MM_ROUND_DOWN: _bindgen_ty_5 = 8192;
pub const SIMDE_MM_ROUND_UP: _bindgen_ty_5 = 16384;
pub const SIMDE_MM_ROUND_TOWARD_ZERO: _bindgen_ty_5 = 24576;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union simde__m128i_private {
    pub i8_: [i8; 16usize],
    pub i16_: [i16; 8usize],
    pub i32_: [i32; 4usize],
    pub i64_: [i64; 2usize],
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub i128_: [simde_int128; 1usize],
    pub u128_: [simde_uint128; 1usize],
    pub f32_: [simde_float32; 4usize],
    pub f64_: [simde_float64; 2usize],
    pub i32f: [int_fast32_t; 2usize],
    pub u32f: [uint_fast32_t; 2usize],
    pub m64_private: [simde__m64_private; 2usize],
    pub m64: [simde__m64; 2usize],
    pub n: __m128i,
}
#[test]
fn bindgen_test_layout_simde__m128i_private() {
    const UNINIT: ::std::mem::MaybeUninit<simde__m128i_private> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<simde__m128i_private>(),
        16usize,
        concat!("Size of: ", stringify!(simde__m128i_private))
    );
    assert_eq!(
        ::std::mem::align_of::<simde__m128i_private>(),
        16usize,
        concat!("Alignment of ", stringify!(simde__m128i_private))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(i8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i128_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(i128_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u128_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(u128_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(f32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(i32f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(u32f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m64_private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(m64_private)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(m64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128i_private),
            "::",
            stringify!(n)
        )
    );
}
impl Default for simde__m128i_private {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union simde__m128d_private {
    pub i8_: [i8; 16usize],
    pub i16_: [i16; 8usize],
    pub i32_: [i32; 4usize],
    pub i64_: [i64; 2usize],
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub f32_: [simde_float32; 4usize],
    pub f64_: [simde_float64; 2usize],
    pub i32f: [int_fast32_t; 2usize],
    pub u32f: [uint_fast32_t; 2usize],
    pub m64_private: [simde__m64_private; 2usize],
    pub m64: [simde__m64; 2usize],
    pub n: __m128d,
}
#[test]
fn bindgen_test_layout_simde__m128d_private() {
    const UNINIT: ::std::mem::MaybeUninit<simde__m128d_private> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<simde__m128d_private>(),
        16usize,
        concat!("Size of: ", stringify!(simde__m128d_private))
    );
    assert_eq!(
        ::std::mem::align_of::<simde__m128d_private>(),
        16usize,
        concat!("Alignment of ", stringify!(simde__m128d_private))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(i8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(f32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(i32f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(u32f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m64_private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(m64_private)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(m64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simde__m128d_private),
            "::",
            stringify!(n)
        )
    );
}
impl Default for simde__m128d_private {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type simde__m128i = __m128i;
pub type simde__m128d = __m128d;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct vec4 {
    pub __bindgen_anon_1: vec4__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union vec4__bindgen_ty_1 {
    pub __bindgen_anon_1: vec4__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 4usize],
    pub m: __m128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vec4__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_vec4__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vec4__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vec4__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vec4__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec4__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(w)
        )
    );
}
#[test]
fn bindgen_test_layout_vec4__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vec4__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vec4__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vec4__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec4__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(vec4__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1),
            "::",
            stringify!(m)
        )
    );
}
impl Default for vec4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vec4() {
    assert_eq!(
        ::std::mem::size_of::<vec4>(),
        16usize,
        concat!("Size of: ", stringify!(vec4))
    );
    assert_eq!(
        ::std::mem::align_of::<vec4>(),
        16usize,
        concat!("Alignment of ", stringify!(vec4))
    );
}
impl Default for vec4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn vec4_from_vec3(dst: *mut vec4, v: *const vec3);
}
extern "C" {
    pub fn vec4_transform(dst: *mut vec4, v: *const vec4, m: *const matrix4);
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct vec3 {
    pub __bindgen_anon_1: vec3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union vec3__bindgen_ty_1 {
    pub __bindgen_anon_1: vec3__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 4usize],
    pub m: __m128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vec3__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_vec3__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vec3__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vec3__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vec3__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(w)
        )
    );
}
#[test]
fn bindgen_test_layout_vec3__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<vec3__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vec3__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vec3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec3__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(vec3__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1),
            "::",
            stringify!(m)
        )
    );
}
impl Default for vec3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vec3() {
    assert_eq!(
        ::std::mem::size_of::<vec3>(),
        16usize,
        concat!("Size of: ", stringify!(vec3))
    );
    assert_eq!(
        ::std::mem::align_of::<vec3>(),
        16usize,
        concat!("Alignment of ", stringify!(vec3))
    );
}
impl Default for vec3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn vec3_from_vec4(dst: *mut vec3, v: *const vec4);
}
extern "C" {
    pub fn vec3_plane_dist(v: *const vec3, p: *const plane) -> f32;
}
extern "C" {
    pub fn vec3_transform(dst: *mut vec3, v: *const vec3, m: *const matrix4);
}
extern "C" {
    pub fn vec3_rotate(dst: *mut vec3, v: *const vec3, m: *const matrix3);
}
extern "C" {
    pub fn vec3_transform3x4(dst: *mut vec3, v: *const vec3, m: *const matrix3);
}
extern "C" {
    pub fn vec3_mirror(dst: *mut vec3, v: *const vec3, p: *const plane);
}
extern "C" {
    pub fn vec3_mirrorv(dst: *mut vec3, v: *const vec3, vec: *const vec3);
}
extern "C" {
    pub fn vec3_rand(dst: *mut vec3, positive_only: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_output {
    _unused: [u8; 0],
}
pub type audio_t = audio_output;
pub const audio_format_AUDIO_FORMAT_UNKNOWN: audio_format = 0;
pub const audio_format_AUDIO_FORMAT_U8BIT: audio_format = 1;
pub const audio_format_AUDIO_FORMAT_16BIT: audio_format = 2;
pub const audio_format_AUDIO_FORMAT_32BIT: audio_format = 3;
pub const audio_format_AUDIO_FORMAT_FLOAT: audio_format = 4;
pub const audio_format_AUDIO_FORMAT_U8BIT_PLANAR: audio_format = 5;
pub const audio_format_AUDIO_FORMAT_16BIT_PLANAR: audio_format = 6;
pub const audio_format_AUDIO_FORMAT_32BIT_PLANAR: audio_format = 7;
pub const audio_format_AUDIO_FORMAT_FLOAT_PLANAR: audio_format = 8;
pub type audio_format = ::std::os::raw::c_uint;
#[doc = "< Unknown setting, fallback is stereo."]
pub const speaker_layout_SPEAKERS_UNKNOWN: speaker_layout = 0;
#[doc = "< Channels: MONO"]
pub const speaker_layout_SPEAKERS_MONO: speaker_layout = 1;
#[doc = "< Channels: FL, FR"]
pub const speaker_layout_SPEAKERS_STEREO: speaker_layout = 2;
#[doc = "< Channels: FL, FR, LFE"]
pub const speaker_layout_SPEAKERS_2POINT1: speaker_layout = 3;
#[doc = "< Channels: FL, FR, FC, RC"]
pub const speaker_layout_SPEAKERS_4POINT0: speaker_layout = 4;
#[doc = "< Channels: FL, FR, FC, LFE, RC"]
pub const speaker_layout_SPEAKERS_4POINT1: speaker_layout = 5;
#[doc = "< Channels: FL, FR, FC, LFE, RL, RR"]
pub const speaker_layout_SPEAKERS_5POINT1: speaker_layout = 6;
#[doc = "< Channels: FL, FR, FC, LFE, RL, RR, SL, SR"]
pub const speaker_layout_SPEAKERS_7POINT1: speaker_layout = 8;
#[doc = " The speaker layout describes where the speakers are located in the room.\n For OBS it dictates:\n  *  how many channels are available and\n  *  which channels are used for which speakers.\n\n Standard channel layouts where retrieved from ffmpeg documentation at:\n     https://trac.ffmpeg.org/wiki/AudioChannelManipulation"]
pub type speaker_layout = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_data {
    pub data: [*mut u8; 8usize],
    pub frames: u32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_audio_data() {
    const UNINIT: ::std::mem::MaybeUninit<audio_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audio_data>(),
        80usize,
        concat!("Size of: ", stringify!(audio_data))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_data>(),
        8usize,
        concat!("Alignment of ", stringify!(audio_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_data),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_data),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for audio_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_output_data {
    pub data: [*mut f32; 8usize],
}
#[test]
fn bindgen_test_layout_audio_output_data() {
    const UNINIT: ::std::mem::MaybeUninit<audio_output_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audio_output_data>(),
        64usize,
        concat!("Size of: ", stringify!(audio_output_data))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_output_data>(),
        8usize,
        concat!("Alignment of ", stringify!(audio_output_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for audio_output_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type audio_input_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        start_ts: u64,
        end_ts: u64,
        new_ts: *mut u64,
        active_mixers: u32,
        mixes: *mut audio_output_data,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_output_info {
    pub name: *const ::std::os::raw::c_char,
    pub samples_per_sec: u32,
    pub format: audio_format,
    pub speakers: speaker_layout,
    pub input_callback: audio_input_callback_t,
    pub input_param: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_audio_output_info() {
    const UNINIT: ::std::mem::MaybeUninit<audio_output_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audio_output_info>(),
        40usize,
        concat!("Size of: ", stringify!(audio_output_info))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_output_info>(),
        8usize,
        concat!("Alignment of ", stringify!(audio_output_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_per_sec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(speakers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(input_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_param) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(input_param)
        )
    );
}
impl Default for audio_output_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_convert_info {
    pub samples_per_sec: u32,
    pub format: audio_format,
    pub speakers: speaker_layout,
    pub allow_clipping: bool,
}
#[test]
fn bindgen_test_layout_audio_convert_info() {
    const UNINIT: ::std::mem::MaybeUninit<audio_convert_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audio_convert_info>(),
        16usize,
        concat!("Size of: ", stringify!(audio_convert_info))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_convert_info>(),
        4usize,
        concat!("Alignment of ", stringify!(audio_convert_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_per_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_convert_info),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_convert_info),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_convert_info),
            "::",
            stringify!(speakers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_clipping) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_convert_info),
            "::",
            stringify!(allow_clipping)
        )
    );
}
impl Default for audio_convert_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn audio_output_open(
        audio: *mut *mut audio_t,
        info: *mut audio_output_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn audio_output_close(audio: *mut audio_t);
}
pub type audio_output_callback_t = ::std::option::Option<
    unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, mix_idx: usize, data: *mut audio_data),
>;
extern "C" {
    pub fn audio_output_connect(
        video: *mut audio_t,
        mix_idx: usize,
        conversion: *const audio_convert_info,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn audio_output_disconnect(
        video: *mut audio_t,
        mix_idx: usize,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn audio_output_active(audio: *const audio_t) -> bool;
}
extern "C" {
    pub fn audio_output_get_block_size(audio: *const audio_t) -> usize;
}
extern "C" {
    pub fn audio_output_get_planes(audio: *const audio_t) -> usize;
}
extern "C" {
    pub fn audio_output_get_channels(audio: *const audio_t) -> usize;
}
extern "C" {
    pub fn audio_output_get_sample_rate(audio: *const audio_t) -> u32;
}
extern "C" {
    pub fn audio_output_get_info(audio: *const audio_t) -> *const audio_output_info;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_frame {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_output {
    _unused: [u8; 0],
}
pub type video_t = video_output;
pub const video_format_VIDEO_FORMAT_NONE: video_format = 0;
pub const video_format_VIDEO_FORMAT_I420: video_format = 1;
pub const video_format_VIDEO_FORMAT_NV12: video_format = 2;
pub const video_format_VIDEO_FORMAT_YVYU: video_format = 3;
pub const video_format_VIDEO_FORMAT_YUY2: video_format = 4;
pub const video_format_VIDEO_FORMAT_UYVY: video_format = 5;
pub const video_format_VIDEO_FORMAT_RGBA: video_format = 6;
pub const video_format_VIDEO_FORMAT_BGRA: video_format = 7;
pub const video_format_VIDEO_FORMAT_BGRX: video_format = 8;
pub const video_format_VIDEO_FORMAT_Y800: video_format = 9;
pub const video_format_VIDEO_FORMAT_I444: video_format = 10;
pub const video_format_VIDEO_FORMAT_BGR3: video_format = 11;
pub const video_format_VIDEO_FORMAT_I422: video_format = 12;
pub const video_format_VIDEO_FORMAT_I40A: video_format = 13;
pub const video_format_VIDEO_FORMAT_I42A: video_format = 14;
pub const video_format_VIDEO_FORMAT_YUVA: video_format = 15;
pub const video_format_VIDEO_FORMAT_AYUV: video_format = 16;
pub const video_format_VIDEO_FORMAT_I010: video_format = 17;
pub const video_format_VIDEO_FORMAT_P010: video_format = 18;
pub const video_format_VIDEO_FORMAT_I210: video_format = 19;
pub const video_format_VIDEO_FORMAT_I412: video_format = 20;
pub const video_format_VIDEO_FORMAT_YA2L: video_format = 21;
pub const video_format_VIDEO_FORMAT_P216: video_format = 22;
pub const video_format_VIDEO_FORMAT_P416: video_format = 23;
pub const video_format_VIDEO_FORMAT_V210: video_format = 24;
pub type video_format = ::std::os::raw::c_uint;
pub const video_trc_VIDEO_TRC_DEFAULT: video_trc = 0;
pub const video_trc_VIDEO_TRC_SRGB: video_trc = 1;
pub const video_trc_VIDEO_TRC_PQ: video_trc = 2;
pub const video_trc_VIDEO_TRC_HLG: video_trc = 3;
pub type video_trc = ::std::os::raw::c_uint;
pub const video_colorspace_VIDEO_CS_DEFAULT: video_colorspace = 0;
pub const video_colorspace_VIDEO_CS_601: video_colorspace = 1;
pub const video_colorspace_VIDEO_CS_709: video_colorspace = 2;
pub const video_colorspace_VIDEO_CS_SRGB: video_colorspace = 3;
pub const video_colorspace_VIDEO_CS_2100_PQ: video_colorspace = 4;
pub const video_colorspace_VIDEO_CS_2100_HLG: video_colorspace = 5;
pub type video_colorspace = ::std::os::raw::c_uint;
pub const video_range_type_VIDEO_RANGE_DEFAULT: video_range_type = 0;
pub const video_range_type_VIDEO_RANGE_PARTIAL: video_range_type = 1;
pub const video_range_type_VIDEO_RANGE_FULL: video_range_type = 2;
pub type video_range_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_data {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_video_data() {
    const UNINIT: ::std::mem::MaybeUninit<video_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<video_data>(),
        104usize,
        concat!("Size of: ", stringify!(video_data))
    );
    assert_eq!(
        ::std::mem::align_of::<video_data>(),
        8usize,
        concat!("Alignment of ", stringify!(video_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linesize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(video_data),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(video_data),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for video_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_output_info {
    pub name: *const ::std::os::raw::c_char,
    pub format: video_format,
    pub fps_num: u32,
    pub fps_den: u32,
    pub width: u32,
    pub height: u32,
    pub cache_size: usize,
    pub colorspace: video_colorspace,
    pub range: video_range_type,
}
#[test]
fn bindgen_test_layout_video_output_info() {
    const UNINIT: ::std::mem::MaybeUninit<video_output_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<video_output_info>(),
        48usize,
        concat!("Size of: ", stringify!(video_output_info))
    );
    assert_eq!(
        ::std::mem::align_of::<video_output_info>(),
        8usize,
        concat!("Alignment of ", stringify!(video_output_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_num) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(fps_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_den) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(fps_den)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(range)
        )
    );
}
impl Default for video_output_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const video_scale_type_VIDEO_SCALE_DEFAULT: video_scale_type = 0;
pub const video_scale_type_VIDEO_SCALE_POINT: video_scale_type = 1;
pub const video_scale_type_VIDEO_SCALE_FAST_BILINEAR: video_scale_type = 2;
pub const video_scale_type_VIDEO_SCALE_BILINEAR: video_scale_type = 3;
pub const video_scale_type_VIDEO_SCALE_BICUBIC: video_scale_type = 4;
pub type video_scale_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_scale_info {
    pub format: video_format,
    pub width: u32,
    pub height: u32,
    pub range: video_range_type,
    pub colorspace: video_colorspace,
}
#[test]
fn bindgen_test_layout_video_scale_info() {
    const UNINIT: ::std::mem::MaybeUninit<video_scale_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<video_scale_info>(),
        20usize,
        concat!("Size of: ", stringify!(video_scale_info))
    );
    assert_eq!(
        ::std::mem::align_of::<video_scale_info>(),
        4usize,
        concat!("Alignment of ", stringify!(video_scale_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(colorspace)
        )
    );
}
impl Default for video_scale_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn video_format_from_fourcc(fourcc: u32) -> video_format;
}
extern "C" {
    pub fn video_format_get_parameters(
        color_space: video_colorspace,
        range: video_range_type,
        matrix: *mut f32,
        min_range: *mut f32,
        max_range: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn video_format_get_parameters_for_format(
        color_space: video_colorspace,
        range: video_range_type,
        format: video_format,
        matrix: *mut f32,
        min_range: *mut f32,
        max_range: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn video_output_open(
        video: *mut *mut video_t,
        info: *mut video_output_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn video_output_close(video: *mut video_t);
}
extern "C" {
    pub fn video_output_connect(
        video: *mut video_t,
        conversion: *const video_scale_info,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn video_output_disconnect(
        video: *mut video_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn video_output_active(video: *const video_t) -> bool;
}
extern "C" {
    pub fn video_output_get_info(video: *const video_t) -> *const video_output_info;
}
extern "C" {
    pub fn video_output_lock_frame(
        video: *mut video_t,
        frame: *mut video_frame,
        count: ::std::os::raw::c_int,
        timestamp: u64,
    ) -> bool;
}
extern "C" {
    pub fn video_output_unlock_frame(video: *mut video_t);
}
extern "C" {
    pub fn video_output_get_frame_time(video: *const video_t) -> u64;
}
extern "C" {
    pub fn video_output_stop(video: *mut video_t);
}
extern "C" {
    pub fn video_output_stopped(video: *mut video_t) -> bool;
}
extern "C" {
    pub fn video_output_get_format(video: *const video_t) -> video_format;
}
extern "C" {
    pub fn video_output_get_width(video: *const video_t) -> u32;
}
extern "C" {
    pub fn video_output_get_height(video: *const video_t) -> u32;
}
extern "C" {
    pub fn video_output_get_frame_rate(video: *const video_t) -> f64;
}
extern "C" {
    pub fn video_output_get_skipped_frames(video: *const video_t) -> u32;
}
extern "C" {
    pub fn video_output_get_total_frames(video: *const video_t) -> u32;
}
extern "C" {
    pub fn video_output_inc_texture_encoders(video: *mut video_t);
}
extern "C" {
    pub fn video_output_dec_texture_encoders(video: *mut video_t);
}
extern "C" {
    pub fn video_output_inc_texture_frames(video: *mut video_t);
}
extern "C" {
    pub fn video_output_inc_texture_skipped_frames(video: *mut video_t);
}
pub const call_param_type_CALL_PARAM_TYPE_VOID: call_param_type = 0;
pub const call_param_type_CALL_PARAM_TYPE_INT: call_param_type = 1;
pub const call_param_type_CALL_PARAM_TYPE_FLOAT: call_param_type = 2;
pub const call_param_type_CALL_PARAM_TYPE_BOOL: call_param_type = 3;
pub const call_param_type_CALL_PARAM_TYPE_PTR: call_param_type = 4;
pub const call_param_type_CALL_PARAM_TYPE_STRING: call_param_type = 5;
pub type call_param_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct calldata {
    pub stack: *mut u8,
    pub size: usize,
    pub capacity: usize,
    pub fixed: bool,
}
#[test]
fn bindgen_test_layout_calldata() {
    const UNINIT: ::std::mem::MaybeUninit<calldata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<calldata>(),
        32usize,
        concat!("Size of: ", stringify!(calldata))
    );
    assert_eq!(
        ::std::mem::align_of::<calldata>(),
        8usize,
        concat!("Alignment of ", stringify!(calldata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(calldata),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(calldata),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(calldata),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(calldata),
            "::",
            stringify!(fixed)
        )
    );
}
impl Default for calldata {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type calldata_t = calldata;
extern "C" {
    pub fn calldata_get_data(
        data: *const calldata_t,
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn calldata_set_data(
        data: *mut calldata_t,
        name: *const ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_void,
        new_size: usize,
    );
}
extern "C" {
    pub fn calldata_get_string(
        data: *const calldata_t,
        name: *const ::std::os::raw::c_char,
        str_: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_handler {
    _unused: [u8; 0],
}
pub type signal_handler_t = signal_handler;
pub type global_signal_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut calldata_t,
    ),
>;
pub type signal_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut calldata_t),
>;
extern "C" {
    pub fn signal_handler_create() -> *mut signal_handler_t;
}
extern "C" {
    pub fn signal_handler_destroy(handler: *mut signal_handler_t);
}
extern "C" {
    pub fn signal_handler_add(
        handler: *mut signal_handler_t,
        signal_decl: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn signal_handler_connect(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_connect_ref(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_disconnect(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_connect_global(
        handler: *mut signal_handler_t,
        callback: global_signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_disconnect_global(
        handler: *mut signal_handler_t,
        callback: global_signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_remove_current();
}
extern "C" {
    pub fn signal_handler_signal(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        params: *mut calldata_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_handler {
    _unused: [u8; 0],
}
pub type proc_handler_t = proc_handler;
pub type proc_handler_proc_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut calldata_t),
>;
extern "C" {
    pub fn proc_handler_create() -> *mut proc_handler_t;
}
extern "C" {
    pub fn proc_handler_destroy(handler: *mut proc_handler_t);
}
extern "C" {
    pub fn proc_handler_add(
        handler: *mut proc_handler_t,
        decl_string: *const ::std::os::raw::c_char,
        proc_: proc_handler_proc_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Calls a function in a procedure handler.  Returns false if the named\n procedure is not found."]
    pub fn proc_handler_call(
        handler: *mut proc_handler_t,
        name: *const ::std::os::raw::c_char,
        params: *mut calldata_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct media_frames_per_second {
    pub numerator: u32,
    pub denominator: u32,
}
#[test]
fn bindgen_test_layout_media_frames_per_second() {
    const UNINIT: ::std::mem::MaybeUninit<media_frames_per_second> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<media_frames_per_second>(),
        8usize,
        concat!("Size of: ", stringify!(media_frames_per_second))
    );
    assert_eq!(
        ::std::mem::align_of::<media_frames_per_second>(),
        4usize,
        concat!("Alignment of ", stringify!(media_frames_per_second))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(media_frames_per_second),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(media_frames_per_second),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data_array {
    _unused: [u8; 0],
}
pub type obs_data_t = obs_data;
pub type obs_data_item_t = obs_data_item;
pub type obs_data_array_t = obs_data_array;
pub const obs_data_type_OBS_DATA_NULL: obs_data_type = 0;
pub const obs_data_type_OBS_DATA_STRING: obs_data_type = 1;
pub const obs_data_type_OBS_DATA_NUMBER: obs_data_type = 2;
pub const obs_data_type_OBS_DATA_BOOLEAN: obs_data_type = 3;
pub const obs_data_type_OBS_DATA_OBJECT: obs_data_type = 4;
pub const obs_data_type_OBS_DATA_ARRAY: obs_data_type = 5;
pub type obs_data_type = ::std::os::raw::c_uint;
pub const obs_data_number_type_OBS_DATA_NUM_INVALID: obs_data_number_type = 0;
pub const obs_data_number_type_OBS_DATA_NUM_INT: obs_data_number_type = 1;
pub const obs_data_number_type_OBS_DATA_NUM_DOUBLE: obs_data_number_type = 2;
pub type obs_data_number_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_data_create() -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_create_from_json(json_string: *const ::std::os::raw::c_char)
        -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_create_from_json_file(
        json_file: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_create_from_json_file_safe(
        json_file: *const ::std::os::raw::c_char,
        backup_ext: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_addref(data: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_release(data: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_get_json(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_get_json_pretty(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_get_last_json(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_save_json(data: *mut obs_data_t, file: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_data_save_json_safe(
        data: *mut obs_data_t,
        file: *const ::std::os::raw::c_char,
        temp_ext: *const ::std::os::raw::c_char,
        backup_ext: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_save_json_pretty_safe(
        data: *mut obs_data_t,
        file: *const ::std::os::raw::c_char,
        temp_ext: *const ::std::os::raw::c_char,
        backup_ext: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_apply(target: *mut obs_data_t, apply_data: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_erase(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_data_clear(data: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_set_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_set_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    pub fn obs_data_set_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: bool);
}
extern "C" {
    pub fn obs_data_set_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        obj: *mut obs_data_t,
    );
}
extern "C" {
    pub fn obs_data_set_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        array: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_get_defaults(data: *mut obs_data_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_set_default_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_default_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_set_default_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    pub fn obs_data_set_default_bool(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: bool,
    );
}
extern "C" {
    pub fn obs_data_set_default_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        obj: *mut obs_data_t,
    );
}
extern "C" {
    pub fn obs_data_set_default_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        arr: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_bool(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: bool,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        obj: *mut obs_data_t,
    );
}
extern "C" {
    pub fn obs_data_get_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_get_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_get_double(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn obs_data_get_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_data_get_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_get_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_get_default_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_get_default_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_get_default_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn obs_data_get_default_bool(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_get_default_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_get_default_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_get_autoselect_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_get_autoselect_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_get_autoselect_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn obs_data_get_autoselect_bool(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_get_autoselect_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_get_autoselect_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_array_create() -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_array_addref(array: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_data_array_release(array: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_data_array_count(array: *mut obs_data_array_t) -> usize;
}
extern "C" {
    pub fn obs_data_array_item(array: *mut obs_data_array_t, idx: usize) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_array_push_back(array: *mut obs_data_array_t, obj: *mut obs_data_t) -> usize;
}
extern "C" {
    pub fn obs_data_array_insert(array: *mut obs_data_array_t, idx: usize, obj: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_array_push_back_array(
        array: *mut obs_data_array_t,
        array2: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_array_erase(array: *mut obs_data_array_t, idx: usize);
}
extern "C" {
    pub fn obs_data_array_enum(
        array: *mut obs_data_array_t,
        cb: ::std::option::Option<
            unsafe extern "C" fn(data: *mut obs_data_t, param: *mut ::std::os::raw::c_void),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_data_has_user_value(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_has_default_value(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_has_autoselect_value(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_item_has_user_value(data: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_has_default_value(data: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_has_autoselect_value(data: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_unset_user_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_data_unset_default_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_data_unset_autoselect_value(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_unset_user_value(data: *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_item_unset_default_value(data: *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_item_unset_autoselect_value(data: *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_first(data: *mut obs_data_t) -> *mut obs_data_item_t;
}
extern "C" {
    pub fn obs_data_item_byname(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_item_t;
}
extern "C" {
    pub fn obs_data_item_next(item: *mut *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_release(item: *mut *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_item_remove(item: *mut *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_item_gettype(item: *mut obs_data_item_t) -> obs_data_type;
}
extern "C" {
    pub fn obs_data_item_numtype(item: *mut obs_data_item_t) -> obs_data_number_type;
}
extern "C" {
    pub fn obs_data_item_get_name(item: *mut obs_data_item_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_item_set_string(
        item: *mut *mut obs_data_item_t,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_int(item: *mut *mut obs_data_item_t, val: ::std::os::raw::c_longlong);
}
extern "C" {
    pub fn obs_data_item_set_double(item: *mut *mut obs_data_item_t, val: f64);
}
extern "C" {
    pub fn obs_data_item_set_bool(item: *mut *mut obs_data_item_t, val: bool);
}
extern "C" {
    pub fn obs_data_item_set_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_item_set_array(item: *mut *mut obs_data_item_t, val: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_data_item_set_default_string(
        item: *mut *mut obs_data_item_t,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_default_int(
        item: *mut *mut obs_data_item_t,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_item_set_default_double(item: *mut *mut obs_data_item_t, val: f64);
}
extern "C" {
    pub fn obs_data_item_set_default_bool(item: *mut *mut obs_data_item_t, val: bool);
}
extern "C" {
    pub fn obs_data_item_set_default_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_item_set_default_array(
        item: *mut *mut obs_data_item_t,
        val: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_item_set_autoselect_string(
        item: *mut *mut obs_data_item_t,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_autoselect_int(
        item: *mut *mut obs_data_item_t,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_item_set_autoselect_double(item: *mut *mut obs_data_item_t, val: f64);
}
extern "C" {
    pub fn obs_data_item_set_autoselect_bool(item: *mut *mut obs_data_item_t, val: bool);
}
extern "C" {
    pub fn obs_data_item_set_autoselect_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_item_set_autoselect_array(
        item: *mut *mut obs_data_item_t,
        val: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_item_get_string(item: *mut obs_data_item_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_item_get_int(item: *mut obs_data_item_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_item_get_double(item: *mut obs_data_item_t) -> f64;
}
extern "C" {
    pub fn obs_data_item_get_bool(item: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_item_get_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_item_get_default_string(
        item: *mut obs_data_item_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_item_get_default_int(item: *mut obs_data_item_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_item_get_default_double(item: *mut obs_data_item_t) -> f64;
}
extern "C" {
    pub fn obs_data_item_get_default_bool(item: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_default_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_item_get_default_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_string(
        item: *mut obs_data_item_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_int(
        item: *mut obs_data_item_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_double(item: *mut obs_data_item_t) -> f64;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_bool(item: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_set_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec2,
    );
}
extern "C" {
    pub fn obs_data_set_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec3,
    );
}
extern "C" {
    pub fn obs_data_set_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec4,
    );
}
extern "C" {
    pub fn obs_data_set_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const quat,
    );
}
extern "C" {
    pub fn obs_data_set_default_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec2,
    );
}
extern "C" {
    pub fn obs_data_set_default_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec3,
    );
}
extern "C" {
    pub fn obs_data_set_default_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec4,
    );
}
extern "C" {
    pub fn obs_data_set_default_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const quat,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec2,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec3,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec4,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const quat,
    );
}
extern "C" {
    pub fn obs_data_get_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec2,
    );
}
extern "C" {
    pub fn obs_data_get_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec3,
    );
}
extern "C" {
    pub fn obs_data_get_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec4,
    );
}
extern "C" {
    pub fn obs_data_get_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut quat,
    );
}
extern "C" {
    pub fn obs_data_get_default_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec2,
    );
}
extern "C" {
    pub fn obs_data_get_default_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec3,
    );
}
extern "C" {
    pub fn obs_data_get_default_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec4,
    );
}
extern "C" {
    pub fn obs_data_get_default_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut quat,
    );
}
extern "C" {
    pub fn obs_data_get_autoselect_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec2,
    );
}
extern "C" {
    pub fn obs_data_get_autoselect_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec3,
    );
}
extern "C" {
    pub fn obs_data_get_autoselect_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec4,
    );
}
extern "C" {
    pub fn obs_data_get_autoselect_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut quat,
    );
}
extern "C" {
    pub fn obs_data_set_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_default_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_get_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_get_default_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_get_autoselect_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_item_set_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_default_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_autoselect_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_get_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_default_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
#[doc = " Modal UI definition structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_modal_ui {
    #[doc = "< Identifier associated with this UI"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< Task of the UI"]
    pub task: *const ::std::os::raw::c_char,
    #[doc = "< UI target (UI toolkit or program name)"]
    pub target: *const ::std::os::raw::c_char,
    #[doc = " Callback to execute modal interface.\n\n The @b object variable points to the input/output/encoder/etc.  The\n @b ui_data variable points to the UI parent or UI-specific data to\n be used with the custom user interface.\n\n What @b ui_data points to differs depending on the target, and you\n should use discretion and consistency when using this variable to\n relay information to the UI function.  For example, it would be\n ideal to have @b ui_data point to a parent, QWidget for Qt, or a\n wxWindow for wxWidgets, etc., though it's up to the discretion of\n the developer to define that value.  Because of the nature of void\n pointers, discretion and consistency is advised.\n\n @param  object   Pointer/handle to the data associated with this\n                  call.\n @param  ui_data  UI data to pass associated with this specific\n                  target, if any.\n @return          @b true if user completed the task, or\n                  @b false if user cancelled the task."]
    pub exec: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ui_data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_obs_modal_ui() {
    const UNINIT: ::std::mem::MaybeUninit<obs_modal_ui> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_modal_ui>(),
        48usize,
        concat!("Size of: ", stringify!(obs_modal_ui))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_modal_ui>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_modal_ui))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exec) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(exec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_type_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(free_type_data)
        )
    );
}
impl Default for obs_modal_ui {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Registers a modal UI definition to the current obs context.  This should be\n used in obs_module_load.\n\n @param  info  Pointer to the modal definition structure"]
    pub fn obs_register_modal_ui(info: *const obs_modal_ui);
}
#[doc = " Modeless UI definition structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_modeless_ui {
    #[doc = "< Identifier associated with this UI"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< Task of the UI"]
    pub task: *const ::std::os::raw::c_char,
    #[doc = "< UI target (UI toolkit or program name)"]
    pub target: *const ::std::os::raw::c_char,
    #[doc = " Callback to create modeless interface.\n\n This function is almost identical to the modal exec function,\n except modeless UI calls return immediately, and typically are\n supposed to return a pointer or handle to the specific UI object\n that was created.  For example, a Qt object would ideally return a\n pointer to a QWidget.  Again, discretion and consistency is advised\n for the return value.\n\n @param   object  Pointer/handle to the data associated with this\n                  call.\n @param  ui_data  UI data to pass associated with this specific\n                  target, if any.\n @return          Pointer/handle to the modeless UI associated with\n                  the specific target."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ui_data: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_obs_modeless_ui() {
    const UNINIT: ::std::mem::MaybeUninit<obs_modeless_ui> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_modeless_ui>(),
        48usize,
        concat!("Size of: ", stringify!(obs_modeless_ui))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_modeless_ui>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_modeless_ui))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_type_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(free_type_data)
        )
    );
}
impl Default for obs_modeless_ui {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Registers a modeless UI definition to the current obs context.  This should\n be used in obs_module_load.\n\n @param  info  Pointer to the modal definition structure"]
    pub fn obs_register_modeless_ui(info: *const obs_modeless_ui);
}
extern "C" {
    #[doc = " Requests modal UI to be displayed.  Returns when user is complete.\n\n @param    name  Name of the input/output/etc type that UI was requested for\n @param    task  Task of the user interface (usually \"config\")\n @param  target  Desired target (i.e. \"qt\", \"wx\", \"gtk3\", \"win32\", etc)\n @param    data  Pointer to the obs input/output/etc\n @param ui_data  UI-specific data, usually a parent pointer/handle (if any)\n\n @return         OBS_UI_SUCCESS if the UI was successful,\n                 OBS_UI_CANCEL if the UI was cancelled by the user, or\n                 OBS_UI_NOTFOUND if the UI callback was not found"]
    pub fn obs_exec_ui(
        id: *const ::std::os::raw::c_char,
        task: *const ::std::os::raw::c_char,
        target: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        ui_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Requests modeless UI to be created.  Returns immediately.\n\n @param    name  Name of the input/output/etc type that UI was requested for\n @param    task  Task of the user interface\n @param  target  Desired target (i.e. \"qt\", \"wx\", \"gtk3\", \"win32\", etc)\n @param    data  Pointer to the obs input/output/etc\n @param ui_data  UI-specific data, usually a parent pointer/handle (if any)\n\n @return         Pointer/handle to the target-specific modeless object, or\n                 NULL if not found or failed."]
    pub fn obs_create_ui(
        id: *const ::std::os::raw::c_char,
        task: *const ::std::os::raw::c_char,
        target: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        ui_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub const obs_property_type_OBS_PROPERTY_INVALID: obs_property_type = 0;
pub const obs_property_type_OBS_PROPERTY_BOOL: obs_property_type = 1;
pub const obs_property_type_OBS_PROPERTY_INT: obs_property_type = 2;
pub const obs_property_type_OBS_PROPERTY_FLOAT: obs_property_type = 3;
pub const obs_property_type_OBS_PROPERTY_TEXT: obs_property_type = 4;
pub const obs_property_type_OBS_PROPERTY_PATH: obs_property_type = 5;
pub const obs_property_type_OBS_PROPERTY_LIST: obs_property_type = 6;
pub const obs_property_type_OBS_PROPERTY_COLOR: obs_property_type = 7;
pub const obs_property_type_OBS_PROPERTY_BUTTON: obs_property_type = 8;
pub const obs_property_type_OBS_PROPERTY_FONT: obs_property_type = 9;
pub const obs_property_type_OBS_PROPERTY_EDITABLE_LIST: obs_property_type = 10;
pub const obs_property_type_OBS_PROPERTY_FRAME_RATE: obs_property_type = 11;
pub const obs_property_type_OBS_PROPERTY_GROUP: obs_property_type = 12;
pub const obs_property_type_OBS_PROPERTY_COLOR_ALPHA: obs_property_type = 13;
pub type obs_property_type = ::std::os::raw::c_uint;
pub const obs_combo_format_OBS_COMBO_FORMAT_INVALID: obs_combo_format = 0;
pub const obs_combo_format_OBS_COMBO_FORMAT_INT: obs_combo_format = 1;
pub const obs_combo_format_OBS_COMBO_FORMAT_FLOAT: obs_combo_format = 2;
pub const obs_combo_format_OBS_COMBO_FORMAT_STRING: obs_combo_format = 3;
pub type obs_combo_format = ::std::os::raw::c_uint;
pub const obs_combo_type_OBS_COMBO_TYPE_INVALID: obs_combo_type = 0;
pub const obs_combo_type_OBS_COMBO_TYPE_EDITABLE: obs_combo_type = 1;
pub const obs_combo_type_OBS_COMBO_TYPE_LIST: obs_combo_type = 2;
pub type obs_combo_type = ::std::os::raw::c_uint;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_STRINGS: obs_editable_list_type = 0;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_FILES: obs_editable_list_type = 1;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_FILES_AND_URLS: obs_editable_list_type = 2;
pub type obs_editable_list_type = ::std::os::raw::c_uint;
pub const obs_path_type_OBS_PATH_FILE: obs_path_type = 0;
pub const obs_path_type_OBS_PATH_FILE_SAVE: obs_path_type = 1;
pub const obs_path_type_OBS_PATH_DIRECTORY: obs_path_type = 2;
pub type obs_path_type = ::std::os::raw::c_uint;
pub const obs_text_type_OBS_TEXT_DEFAULT: obs_text_type = 0;
pub const obs_text_type_OBS_TEXT_PASSWORD: obs_text_type = 1;
pub const obs_text_type_OBS_TEXT_MULTILINE: obs_text_type = 2;
pub const obs_text_type_OBS_TEXT_INFO: obs_text_type = 3;
pub type obs_text_type = ::std::os::raw::c_uint;
pub const obs_text_info_type_OBS_TEXT_INFO_NORMAL: obs_text_info_type = 0;
pub const obs_text_info_type_OBS_TEXT_INFO_WARNING: obs_text_info_type = 1;
pub const obs_text_info_type_OBS_TEXT_INFO_ERROR: obs_text_info_type = 2;
pub type obs_text_info_type = ::std::os::raw::c_uint;
pub const obs_number_type_OBS_NUMBER_SCROLLER: obs_number_type = 0;
pub const obs_number_type_OBS_NUMBER_SLIDER: obs_number_type = 1;
pub type obs_number_type = ::std::os::raw::c_uint;
pub const obs_group_type_OBS_COMBO_INVALID: obs_group_type = 0;
pub const obs_group_type_OBS_GROUP_NORMAL: obs_group_type = 1;
pub const obs_group_type_OBS_GROUP_CHECKABLE: obs_group_type = 2;
pub type obs_group_type = ::std::os::raw::c_uint;
pub const obs_button_type_OBS_BUTTON_DEFAULT: obs_button_type = 0;
pub const obs_button_type_OBS_BUTTON_URL: obs_button_type = 1;
pub type obs_button_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_properties {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_property {
    _unused: [u8; 0],
}
pub type obs_properties_t = obs_properties;
pub type obs_property_t = obs_property;
extern "C" {
    pub fn obs_properties_create() -> *mut obs_properties_t;
}
extern "C" {
    pub fn obs_properties_create_param(
        param: *mut ::std::os::raw::c_void,
        destroy: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
    ) -> *mut obs_properties_t;
}
extern "C" {
    pub fn obs_properties_destroy(props: *mut obs_properties_t);
}
extern "C" {
    pub fn obs_properties_set_flags(props: *mut obs_properties_t, flags: u32);
}
extern "C" {
    pub fn obs_properties_get_flags(props: *mut obs_properties_t) -> u32;
}
extern "C" {
    pub fn obs_properties_set_param(
        props: *mut obs_properties_t,
        param: *mut ::std::os::raw::c_void,
        destroy: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn obs_properties_get_param(props: *mut obs_properties_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_properties_first(props: *mut obs_properties_t) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_get(
        props: *mut obs_properties_t,
        property: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_get_parent(props: *mut obs_properties_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Remove a property from a properties list.\n\n Removes a property from a properties list. Only valid in either\n get_properties or modified_callback(2). modified_callback(2) must return\n true so that all UI properties are rebuilt and returning false is undefined\n behavior.\n\n @param props Properties to remove from.\n @param property Name of the property to remove."]
    pub fn obs_properties_remove_by_name(
        props: *mut obs_properties_t,
        property: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Applies settings to the properties by calling all the necessary\n modification callbacks"]
    pub fn obs_properties_apply_settings(props: *mut obs_properties_t, settings: *mut obs_data_t);
}
#[doc = " Callback for when a button property is clicked.  If the properties\n need to be refreshed due to changes to the property layout, return true,\n otherwise return false."]
pub type obs_property_clicked_t = ::std::option::Option<
    unsafe extern "C" fn(
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn obs_properties_add_bool(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_int(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_float(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: f64,
        max: f64,
        step: f64,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_int_slider(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_float_slider(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: f64,
        max: f64,
        step: f64,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_text(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_text_type,
    ) -> *mut obs_property_t;
}
extern "C" {
    #[doc = " Adds a 'path' property.  Can be a directory or a file.\n\n If target is a file path, the filters should be this format, separated by\n double semicolons, and extensions separated by space:\n   \"Example types 1 and 2 (*.ex1 *.ex2);;Example type 3 (*.ex3)\"\n\n @param  props        Properties object\n @param  name         Settings name\n @param  description  Description (display name) of the property\n @param  type         Type of path (directory or file)\n @param  filter       If type is a file path, then describes the file filter\n                      that the user can browse.  Items are separated via\n                      double semicolons.  If multiple file types in a\n                      filter, separate with space."]
    pub fn obs_properties_add_path(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_path_type,
        filter: *const ::std::os::raw::c_char,
        default_path: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_list(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_combo_type,
        format: obs_combo_format,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_color(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_color_alpha(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_button(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
        callback: obs_property_clicked_t,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_button2(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
        callback: obs_property_clicked_t,
        priv_: *mut ::std::os::raw::c_void,
    ) -> *mut obs_property_t;
}
extern "C" {
    #[doc = " Adds a font selection property.\n\n A font is an obs_data sub-object which contains the following items:\n   face:   face name string\n   style:  style name string\n   size:   size integer\n   flags:  font flags integer (OBS_FONT_* defined above)"]
    pub fn obs_properties_add_font(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_editable_list(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_editable_list_type,
        filter: *const ::std::os::raw::c_char,
        default_path: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_frame_rate(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_group(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_group_type,
        group: *mut obs_properties_t,
    ) -> *mut obs_property_t;
}
#[doc = " Optional callback for when a property is modified.  If the properties\n need to be refreshed due to changes to the property layout, return true,\n otherwise return false."]
pub type obs_property_modified_t = ::std::option::Option<
    unsafe extern "C" fn(
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        settings: *mut obs_data_t,
    ) -> bool,
>;
pub type obs_property_modified2_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        settings: *mut obs_data_t,
    ) -> bool,
>;
extern "C" {
    pub fn obs_property_set_modified_callback(
        p: *mut obs_property_t,
        modified: obs_property_modified_t,
    );
}
extern "C" {
    pub fn obs_property_set_modified_callback2(
        p: *mut obs_property_t,
        modified: obs_property_modified2_t,
        priv_: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_property_modified(p: *mut obs_property_t, settings: *mut obs_data_t) -> bool;
}
extern "C" {
    pub fn obs_property_button_clicked(
        p: *mut obs_property_t,
        obj: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn obs_property_set_visible(p: *mut obs_property_t, visible: bool);
}
extern "C" {
    pub fn obs_property_set_enabled(p: *mut obs_property_t, enabled: bool);
}
extern "C" {
    pub fn obs_property_set_description(
        p: *mut obs_property_t,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_set_long_description(
        p: *mut obs_property_t,
        long_description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_name(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_description(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_long_description(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_get_type(p: *mut obs_property_t) -> obs_property_type;
}
extern "C" {
    pub fn obs_property_enabled(p: *mut obs_property_t) -> bool;
}
extern "C" {
    pub fn obs_property_visible(p: *mut obs_property_t) -> bool;
}
extern "C" {
    pub fn obs_property_next(p: *mut *mut obs_property_t) -> bool;
}
extern "C" {
    pub fn obs_property_int_min(p: *mut obs_property_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_property_int_max(p: *mut obs_property_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_property_int_step(p: *mut obs_property_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_property_int_type(p: *mut obs_property_t) -> obs_number_type;
}
extern "C" {
    pub fn obs_property_int_suffix(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_float_min(p: *mut obs_property_t) -> f64;
}
extern "C" {
    pub fn obs_property_float_max(p: *mut obs_property_t) -> f64;
}
extern "C" {
    pub fn obs_property_float_step(p: *mut obs_property_t) -> f64;
}
extern "C" {
    pub fn obs_property_float_type(p: *mut obs_property_t) -> obs_number_type;
}
extern "C" {
    pub fn obs_property_float_suffix(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_text_type(p: *mut obs_property_t) -> obs_text_type;
}
extern "C" {
    pub fn obs_property_text_monospace(p: *mut obs_property_t) -> bool;
}
extern "C" {
    pub fn obs_property_text_info_type(p: *mut obs_property_t) -> obs_text_info_type;
}
extern "C" {
    pub fn obs_property_text_info_word_wrap(p: *mut obs_property_t) -> bool;
}
extern "C" {
    pub fn obs_property_path_type(p: *mut obs_property_t) -> obs_path_type;
}
extern "C" {
    pub fn obs_property_path_filter(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_path_default_path(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_list_type(p: *mut obs_property_t) -> obs_combo_type;
}
extern "C" {
    pub fn obs_property_list_format(p: *mut obs_property_t) -> obs_combo_format;
}
extern "C" {
    pub fn obs_property_int_set_limits(
        p: *mut obs_property_t,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn obs_property_float_set_limits(p: *mut obs_property_t, min: f64, max: f64, step: f64);
}
extern "C" {
    pub fn obs_property_int_set_suffix(
        p: *mut obs_property_t,
        suffix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_float_set_suffix(
        p: *mut obs_property_t,
        suffix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_text_set_monospace(p: *mut obs_property_t, monospace: bool);
}
extern "C" {
    pub fn obs_property_text_set_info_type(p: *mut obs_property_t, type_: obs_text_info_type);
}
extern "C" {
    pub fn obs_property_text_set_info_word_wrap(p: *mut obs_property_t, word_wrap: bool);
}
extern "C" {
    pub fn obs_property_button_set_type(p: *mut obs_property_t, type_: obs_button_type);
}
extern "C" {
    pub fn obs_property_button_set_url(p: *mut obs_property_t, url: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_property_list_clear(p: *mut obs_property_t);
}
extern "C" {
    pub fn obs_property_list_add_string(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn obs_property_list_add_int(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    ) -> usize;
}
extern "C" {
    pub fn obs_property_list_add_float(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    ) -> usize;
}
extern "C" {
    pub fn obs_property_list_insert_string(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_list_insert_int(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_property_list_insert_float(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    pub fn obs_property_list_item_disable(p: *mut obs_property_t, idx: usize, disabled: bool);
}
extern "C" {
    pub fn obs_property_list_item_disabled(p: *mut obs_property_t, idx: usize) -> bool;
}
extern "C" {
    pub fn obs_property_list_item_remove(p: *mut obs_property_t, idx: usize);
}
extern "C" {
    pub fn obs_property_list_item_count(p: *mut obs_property_t) -> usize;
}
extern "C" {
    pub fn obs_property_list_item_name(
        p: *mut obs_property_t,
        idx: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_list_item_string(
        p: *mut obs_property_t,
        idx: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_list_item_int(
        p: *mut obs_property_t,
        idx: usize,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_property_list_item_float(p: *mut obs_property_t, idx: usize) -> f64;
}
extern "C" {
    pub fn obs_property_editable_list_type(p: *mut obs_property_t) -> obs_editable_list_type;
}
extern "C" {
    pub fn obs_property_editable_list_filter(
        p: *mut obs_property_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_editable_list_default_path(
        p: *mut obs_property_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_frame_rate_clear(p: *mut obs_property_t);
}
extern "C" {
    pub fn obs_property_frame_rate_options_clear(p: *mut obs_property_t);
}
extern "C" {
    pub fn obs_property_frame_rate_fps_ranges_clear(p: *mut obs_property_t);
}
extern "C" {
    pub fn obs_property_frame_rate_option_add(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn obs_property_frame_rate_fps_range_add(
        p: *mut obs_property_t,
        min: media_frames_per_second,
        max: media_frames_per_second,
    ) -> usize;
}
extern "C" {
    pub fn obs_property_frame_rate_option_insert(
        p: *mut obs_property_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_frame_rate_fps_range_insert(
        p: *mut obs_property_t,
        idx: usize,
        min: media_frames_per_second,
        max: media_frames_per_second,
    );
}
extern "C" {
    pub fn obs_property_frame_rate_options_count(p: *mut obs_property_t) -> usize;
}
extern "C" {
    pub fn obs_property_frame_rate_option_name(
        p: *mut obs_property_t,
        idx: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_frame_rate_option_description(
        p: *mut obs_property_t,
        idx: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_frame_rate_fps_ranges_count(p: *mut obs_property_t) -> usize;
}
extern "C" {
    pub fn obs_property_frame_rate_fps_range_min(
        p: *mut obs_property_t,
        idx: usize,
    ) -> media_frames_per_second;
}
extern "C" {
    pub fn obs_property_frame_rate_fps_range_max(
        p: *mut obs_property_t,
        idx: usize,
    ) -> media_frames_per_second;
}
extern "C" {
    pub fn obs_property_group_type(p: *mut obs_property_t) -> obs_group_type;
}
extern "C" {
    pub fn obs_property_group_content(p: *mut obs_property_t) -> *mut obs_properties_t;
}
extern "C" {
    pub fn obs_property_button_type(p: *mut obs_property_t) -> obs_button_type;
}
extern "C" {
    pub fn obs_property_button_url(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_proprety_text_type(p: *mut obs_property_t) -> obs_text_type;
}
pub const obs_interaction_flags_INTERACT_NONE: obs_interaction_flags = 0;
pub const obs_interaction_flags_INTERACT_CAPS_KEY: obs_interaction_flags = 1;
pub const obs_interaction_flags_INTERACT_SHIFT_KEY: obs_interaction_flags = 2;
pub const obs_interaction_flags_INTERACT_CONTROL_KEY: obs_interaction_flags = 4;
pub const obs_interaction_flags_INTERACT_ALT_KEY: obs_interaction_flags = 8;
pub const obs_interaction_flags_INTERACT_MOUSE_LEFT: obs_interaction_flags = 16;
pub const obs_interaction_flags_INTERACT_MOUSE_MIDDLE: obs_interaction_flags = 32;
pub const obs_interaction_flags_INTERACT_MOUSE_RIGHT: obs_interaction_flags = 64;
pub const obs_interaction_flags_INTERACT_COMMAND_KEY: obs_interaction_flags = 128;
pub const obs_interaction_flags_INTERACT_NUMLOCK_KEY: obs_interaction_flags = 256;
pub const obs_interaction_flags_INTERACT_IS_KEY_PAD: obs_interaction_flags = 512;
pub const obs_interaction_flags_INTERACT_IS_LEFT: obs_interaction_flags = 1024;
pub const obs_interaction_flags_INTERACT_IS_RIGHT: obs_interaction_flags = 2048;
pub type obs_interaction_flags = ::std::os::raw::c_uint;
pub const obs_mouse_button_type_MOUSE_LEFT: obs_mouse_button_type = 0;
pub const obs_mouse_button_type_MOUSE_MIDDLE: obs_mouse_button_type = 1;
pub const obs_mouse_button_type_MOUSE_RIGHT: obs_mouse_button_type = 2;
pub type obs_mouse_button_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct obs_mouse_event {
    pub modifiers: u32,
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_obs_mouse_event() {
    const UNINIT: ::std::mem::MaybeUninit<obs_mouse_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_mouse_event>(),
        12usize,
        concat!("Size of: ", stringify!(obs_mouse_event))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_mouse_event>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_mouse_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_mouse_event),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_mouse_event),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_mouse_event),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_key_event {
    pub modifiers: u32,
    pub text: *mut ::std::os::raw::c_char,
    pub native_modifiers: u32,
    pub native_scancode: u32,
    pub native_vkey: u32,
}
#[test]
fn bindgen_test_layout_obs_key_event() {
    const UNINIT: ::std::mem::MaybeUninit<obs_key_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_key_event>(),
        32usize,
        concat!("Size of: ", stringify!(obs_key_event))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_key_event>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_key_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_modifiers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(native_modifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_scancode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(native_scancode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_vkey) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(native_vkey)
        )
    );
}
impl Default for obs_key_event {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_context_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_display {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_view {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_scene {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_scene_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_encoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_service {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_fader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_volmeter {
    _unused: [u8; 0],
}
pub type obs_object_t = obs_context_data;
pub type obs_display_t = obs_display;
pub type obs_view_t = obs_view;
pub type obs_source_t = obs_source;
pub type obs_scene_t = obs_scene;
pub type obs_sceneitem_t = obs_scene_item;
pub type obs_output_t = obs_output;
pub type obs_encoder_t = obs_encoder;
pub type obs_service_t = obs_service;
pub type obs_module_t = obs_module;
pub type obs_fader_t = obs_fader;
pub type obs_volmeter_t = obs_volmeter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_object {
    _unused: [u8; 0],
}
pub type obs_weak_object_t = obs_weak_object;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_source {
    _unused: [u8; 0],
}
pub type obs_weak_source_t = obs_weak_source;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_output {
    _unused: [u8; 0],
}
pub type obs_weak_output_t = obs_weak_output;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_encoder {
    _unused: [u8; 0],
}
pub type obs_weak_encoder_t = obs_weak_encoder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_service {
    _unused: [u8; 0],
}
pub type obs_weak_service_t = obs_weak_service;
pub type obs_missing_file_cb = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut ::std::os::raw::c_void,
        new_path: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_missing_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_missing_files {
    _unused: [u8; 0],
}
pub type obs_missing_file_t = obs_missing_file;
pub type obs_missing_files_t = obs_missing_files;
pub const obs_missing_file_src_OBS_MISSING_FILE_SOURCE: obs_missing_file_src = 0;
pub const obs_missing_file_src_OBS_MISSING_FILE_SCRIPT: obs_missing_file_src = 1;
pub type obs_missing_file_src = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_missing_files_create() -> *mut obs_missing_files_t;
}
extern "C" {
    pub fn obs_missing_file_create(
        path: *const ::std::os::raw::c_char,
        callback: obs_missing_file_cb,
        src_type: ::std::os::raw::c_int,
        src: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut obs_missing_file_t;
}
extern "C" {
    pub fn obs_missing_files_add_file(
        files: *mut obs_missing_files_t,
        file: *mut obs_missing_file_t,
    );
}
extern "C" {
    pub fn obs_missing_files_count(files: *mut obs_missing_files_t) -> usize;
}
extern "C" {
    pub fn obs_missing_files_get_file(
        files: *mut obs_missing_files_t,
        idx: ::std::os::raw::c_int,
    ) -> *mut obs_missing_file_t;
}
extern "C" {
    pub fn obs_missing_files_destroy(files: *mut obs_missing_files_t);
}
extern "C" {
    pub fn obs_missing_files_append(dst: *mut obs_missing_files_t, src: *mut obs_missing_files_t);
}
extern "C" {
    pub fn obs_missing_file_issue_callback(
        file: *mut obs_missing_file_t,
        new_path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_missing_file_get_path(
        file: *mut obs_missing_file_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_missing_file_get_source_name(
        file: *mut obs_missing_file_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_missing_file_release(file: *mut obs_missing_file_t);
}
extern "C" {
    pub fn obs_missing_file_destroy(file: *mut obs_missing_file_t);
}
pub const obs_source_type_OBS_SOURCE_TYPE_INPUT: obs_source_type = 0;
pub const obs_source_type_OBS_SOURCE_TYPE_FILTER: obs_source_type = 1;
pub const obs_source_type_OBS_SOURCE_TYPE_TRANSITION: obs_source_type = 2;
pub const obs_source_type_OBS_SOURCE_TYPE_SCENE: obs_source_type = 3;
pub type obs_source_type = ::std::os::raw::c_uint;
pub const obs_balance_type_OBS_BALANCE_TYPE_SINE_LAW: obs_balance_type = 0;
pub const obs_balance_type_OBS_BALANCE_TYPE_SQUARE_LAW: obs_balance_type = 1;
pub const obs_balance_type_OBS_BALANCE_TYPE_LINEAR: obs_balance_type = 2;
pub type obs_balance_type = ::std::os::raw::c_uint;
pub const obs_icon_type_OBS_ICON_TYPE_UNKNOWN: obs_icon_type = 0;
pub const obs_icon_type_OBS_ICON_TYPE_IMAGE: obs_icon_type = 1;
pub const obs_icon_type_OBS_ICON_TYPE_COLOR: obs_icon_type = 2;
pub const obs_icon_type_OBS_ICON_TYPE_SLIDESHOW: obs_icon_type = 3;
pub const obs_icon_type_OBS_ICON_TYPE_AUDIO_INPUT: obs_icon_type = 4;
pub const obs_icon_type_OBS_ICON_TYPE_AUDIO_OUTPUT: obs_icon_type = 5;
pub const obs_icon_type_OBS_ICON_TYPE_DESKTOP_CAPTURE: obs_icon_type = 6;
pub const obs_icon_type_OBS_ICON_TYPE_WINDOW_CAPTURE: obs_icon_type = 7;
pub const obs_icon_type_OBS_ICON_TYPE_GAME_CAPTURE: obs_icon_type = 8;
pub const obs_icon_type_OBS_ICON_TYPE_CAMERA: obs_icon_type = 9;
pub const obs_icon_type_OBS_ICON_TYPE_TEXT: obs_icon_type = 10;
pub const obs_icon_type_OBS_ICON_TYPE_MEDIA: obs_icon_type = 11;
pub const obs_icon_type_OBS_ICON_TYPE_BROWSER: obs_icon_type = 12;
pub const obs_icon_type_OBS_ICON_TYPE_CUSTOM: obs_icon_type = 13;
pub const obs_icon_type_OBS_ICON_TYPE_PROCESS_AUDIO_OUTPUT: obs_icon_type = 14;
pub type obs_icon_type = ::std::os::raw::c_uint;
pub const obs_media_state_OBS_MEDIA_STATE_NONE: obs_media_state = 0;
pub const obs_media_state_OBS_MEDIA_STATE_PLAYING: obs_media_state = 1;
pub const obs_media_state_OBS_MEDIA_STATE_OPENING: obs_media_state = 2;
pub const obs_media_state_OBS_MEDIA_STATE_BUFFERING: obs_media_state = 3;
pub const obs_media_state_OBS_MEDIA_STATE_PAUSED: obs_media_state = 4;
pub const obs_media_state_OBS_MEDIA_STATE_STOPPED: obs_media_state = 5;
pub const obs_media_state_OBS_MEDIA_STATE_ENDED: obs_media_state = 6;
pub const obs_media_state_OBS_MEDIA_STATE_ERROR: obs_media_state = 7;
pub type obs_media_state = ::std::os::raw::c_uint;
#[doc = " @}"]
pub type obs_source_enum_proc_t = ::std::option::Option<
    unsafe extern "C" fn(
        parent: *mut obs_source_t,
        child: *mut obs_source_t,
        param: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_audio_mix {
    pub output: [audio_output_data; 6usize],
}
#[test]
fn bindgen_test_layout_obs_source_audio_mix() {
    const UNINIT: ::std::mem::MaybeUninit<obs_source_audio_mix> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_source_audio_mix>(),
        384usize,
        concat!("Size of: ", stringify!(obs_source_audio_mix))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_audio_mix>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_audio_mix))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio_mix),
            "::",
            stringify!(output)
        )
    );
}
impl Default for obs_source_audio_mix {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Source definition structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_info {
    #[doc = " Unique string identifier for the source"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = " Type of source.\n\n OBS_SOURCE_TYPE_INPUT for input sources,\n OBS_SOURCE_TYPE_FILTER for filter sources, and\n OBS_SOURCE_TYPE_TRANSITION for transition sources."]
    pub type_: obs_source_type,
    #[doc = " Source output flags"]
    pub output_flags: u32,
    #[doc = " Get the translated name of the source type\n\n @param  type_data  The type_data variable of this structure\n @return               The translated name of the source type"]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            type_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Creates the source data for the source\n\n @param  settings  Settings to initialize the source with\n @param  source    Source that this data is associated with\n @return           The data associated with this source"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut obs_data_t,
            source: *mut obs_source_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroys the private data for the source\n\n Async sources must not call obs_source_output_video after returning\n from destroy"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Returns the width of the source.  Required if this is an input\n source and has non-async video"]
    pub get_width:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " Returns the height of the source.  Required if this is an input\n source and has non-async video"]
    pub get_height:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " Gets the default settings for this source\n\n @param[out]  settings  Data to assign default settings to\n @deprecated            Use get_defaults2 if type_data is needed"]
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    #[doc = " Gets the property information of this source\n\n @return         The properties data\n @deprecated     Use get_properties2 if type_data is needed"]
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t,
    >,
    #[doc = " Updates the settings for this source\n\n @param data      Source data\n @param settings  New settings for this source"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    #[doc = " Called when the source has been activated in the main view"]
    pub activate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source has been deactivated from the main view\n (no longer being played/displayed)"]
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source is visible"]
    pub show: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source is no longer visible"]
    pub hide: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called each video frame with the time elapsed\n\n @param  data     Source data\n @param  seconds  Seconds elapsed since the last frame"]
    pub video_tick: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, seconds: f32),
    >,
    #[doc = " Called when rendering the source with the graphics subsystem.\n\n If this is an input/transition source, this is called to draw the\n source texture with the graphics subsystem using the specified\n effect.\n\n If this is a filter source, it wraps source draw calls (for\n example applying a custom effect with custom parameters to a\n source).  In this case, it's highly recommended to use the\n obs_source_process_filter function to automatically handle\n effect-based filter processing.  However, you can implement custom\n draw handling as desired as well.\n\n If the source output flags do not include SOURCE_CUSTOM_DRAW, all\n a source needs to do is set the \"image\" parameter of the effect to\n the desired texture, and then draw.  If the output flags include\n SOURCE_COLOR_MATRIX, you may optionally set the \"color_matrix\"\n parameter of the effect to a custom 4x4 conversion matrix (by\n default it will be set to an YUV->RGB conversion matrix)\n\n @param data    Source data\n @param effect  Effect to be used with this source.  If the source\n                output flags include SOURCE_CUSTOM_DRAW, this will\n                be NULL, and the source is expected to process with\n                an effect manually."]
    pub video_render: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, effect: *mut gs_effect_t),
    >,
    #[doc = " Called to filter raw async video data.\n\n @note          This function is only used with filter sources.\n\n @param  data   Filter data\n @param  frame  Video frame to filter\n @return        New video frame data.  This can defer video data to\n                be drawn later if time is needed for processing"]
    pub filter_video: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            frame: *mut obs_source_frame,
        ) -> *mut obs_source_frame,
    >,
    #[doc = " Called to filter raw audio data.\n\n @note          This function is only used with filter sources.\n\n @param  data   Filter data\n @param  audio  Audio data to filter.\n @return        Modified or new audio data.  You can directly modify\n                the data passed and return it, or you can defer audio\n                data for later if time is needed for processing.  If\n                you are returning new data, that data must exist\n                until the next call to the filter_audio callback or\n                until the filter is removed/destroyed."]
    pub filter_audio: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            audio: *mut obs_audio_data,
        ) -> *mut obs_audio_data,
    >,
    #[doc = " Called to enumerate all active sources being used within this\n source.  If the source has children that render audio/video it must\n implement this callback.\n\n @param  data           Filter data\n @param  enum_callback  Enumeration callback\n @param  param          User data to pass to callback"]
    pub enum_active_sources: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            enum_callback: obs_source_enum_proc_t,
            param: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Called when saving a source.  This is a separate function because\n sometimes a source needs to know when it is being saved so it\n doesn't always have to update the current settings until a certain\n point.\n\n @param  data      Source data\n @param  settings  Settings"]
    pub save: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    #[doc = " Called when loading a source from saved data.  This should be called\n after all the loading sources have actually been created because\n sometimes there are sources that depend on each other.\n\n @param  data      Source data\n @param  settings  Settings"]
    pub load: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    #[doc = " Called when interacting with a source and a mouse-down or mouse-up\n occurs.\n\n @param data         Source data\n @param event        Mouse event properties\n @param type         Mouse button pushed\n @param mouse_up     Mouse event type (true if mouse-up)\n @param click_count  Mouse click count (1 for single click, etc.)"]
    pub mouse_click: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_mouse_event,
            type_: i32,
            mouse_up: bool,
            click_count: u32,
        ),
    >,
    #[doc = " Called when interacting with a source and a mouse-move occurs.\n\n @param data         Source data\n @param event        Mouse event properties\n @param mouse_leave  Mouse leave state (true if mouse left source)"]
    pub mouse_move: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_mouse_event,
            mouse_leave: bool,
        ),
    >,
    #[doc = " Called when interacting with a source and a mouse-wheel occurs.\n\n @param data         Source data\n @param event        Mouse event properties\n @param x_delta      Movement delta in the horizontal direction\n @param y_delta      Movement delta in the vertical direction"]
    pub mouse_wheel: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_mouse_event,
            x_delta: ::std::os::raw::c_int,
            y_delta: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Called when interacting with a source and gain focus/lost focus event\n occurs.\n\n @param data         Source data\n @param focus        Focus state (true if focus gained)"]
    pub focus:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, focus: bool)>,
    #[doc = " Called when interacting with a source and a key-up or key-down\n occurs.\n\n @param data         Source data\n @param event        Key event properties\n @param focus        Key event type (true if mouse-up)"]
    pub key_click: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_key_event,
            key_up: bool,
        ),
    >,
    #[doc = " Called when the filter is removed from a source\n\n @param  data    Filter data\n @param  source  Source that the filter being removed from"]
    pub filter_remove: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, source: *mut obs_source_t),
    >,
    #[doc = " Private data associated with this entry"]
    pub type_data: *mut ::std::os::raw::c_void,
    #[doc = " If defined, called to free private data on shutdown"]
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub audio_render: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            ts_out: *mut u64,
            audio_output: *mut obs_source_audio_mix,
            mixers: u32,
            channels: usize,
            sample_rate: usize,
        ) -> bool,
    >,
    #[doc = " Called to enumerate all active and inactive sources being used\n within this source.  If this callback isn't implemented,\n enum_active_sources will be called instead.\n\n This is typically used if a source can have inactive child sources.\n\n @param  data           Filter data\n @param  enum_callback  Enumeration callback\n @param  param          User data to pass to callback"]
    pub enum_all_sources: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            enum_callback: obs_source_enum_proc_t,
            param: *mut ::std::os::raw::c_void,
        ),
    >,
    pub transition_start:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub transition_stop:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Gets the default settings for this source\n\n If get_defaults is also defined both will be called, and the first\n call will be to get_defaults, then to get_defaults2.\n\n @param       type_data The type_data variable of this structure\n @param[out]  settings  Data to assign default settings to"]
    pub get_defaults2: ::std::option::Option<
        unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    #[doc = " Gets the property information of this source\n\n @param data      Source data\n @param type_data The type_data variable of this structure\n @return          The properties data"]
    pub get_properties2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            type_data: *mut ::std::os::raw::c_void,
        ) -> *mut obs_properties_t,
    >,
    pub audio_mix: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            ts_out: *mut u64,
            audio_output: *mut audio_output_data,
            channels: usize,
            sample_rate: usize,
        ) -> bool,
    >,
    #[doc = " Icon type for the source"]
    pub icon_type: obs_icon_type,
    #[doc = " Media controls"]
    pub media_play_pause:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, pause: bool)>,
    pub media_restart:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_stop: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_next: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_previous:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_get_duration:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> i64>,
    pub media_get_time:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> i64>,
    pub media_set_time: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, miliseconds: i64),
    >,
    pub media_get_state: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> obs_media_state,
    >,
    pub version: u32,
    pub unversioned_id: *const ::std::os::raw::c_char,
    #[doc = " Missing files"]
    pub missing_files: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_missing_files_t,
    >,
    #[doc = " Get color space"]
    pub video_get_color_space: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            count: usize,
            preferred_spaces: *const gs_color_space,
        ) -> gs_color_space,
    >,
}
#[test]
fn bindgen_test_layout_obs_source_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_source_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_source_info>(),
        400usize,
        concat!("Size of: ", stringify!(obs_source_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(output_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_width) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_height) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_defaults) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_defaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deactivate) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(deactivate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hide) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(hide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_tick) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(video_tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_render) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(video_render)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_video) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(filter_video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_audio) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(filter_audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enum_active_sources) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(enum_active_sources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(save)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouse_click) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(mouse_click)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouse_move) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(mouse_move)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouse_wheel) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(mouse_wheel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_click) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(key_click)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_remove) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(filter_remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_data) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_type_data) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(free_type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_render) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(audio_render)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enum_all_sources) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(enum_all_sources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transition_start) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(transition_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transition_stop) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(transition_stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_defaults2) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_defaults2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties2) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_properties2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_mix) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(audio_mix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).icon_type) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(icon_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_play_pause) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_play_pause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_restart) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_restart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_stop) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_next) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_previous) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_previous)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_get_duration) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_get_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_get_time) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_get_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_set_time) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_set_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_get_state) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_get_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unversioned_id) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(unversioned_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missing_files) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(missing_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_get_color_space) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(video_get_color_space)
        )
    );
}
impl Default for obs_source_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn obs_register_source_s(info: *const obs_source_info, size: usize);
}
#[doc = "< The encoder provides an audio codec"]
pub const obs_encoder_type_OBS_ENCODER_AUDIO: obs_encoder_type = 0;
#[doc = "< The encoder provides a video codec"]
pub const obs_encoder_type_OBS_ENCODER_VIDEO: obs_encoder_type = 1;
#[doc = " Specifies the encoder type"]
pub type obs_encoder_type = ::std::os::raw::c_uint;
#[doc = " Encoder output packet"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct encoder_packet {
    #[doc = "< Packet data"]
    pub data: *mut u8,
    #[doc = "< Packet size"]
    pub size: usize,
    #[doc = "< Presentation timestamp"]
    pub pts: i64,
    #[doc = "< Decode timestamp"]
    pub dts: i64,
    #[doc = "< Timebase numerator"]
    pub timebase_num: i32,
    #[doc = "< Timebase denominator"]
    pub timebase_den: i32,
    #[doc = "< Encoder type"]
    pub type_: obs_encoder_type,
    #[doc = "< Is a keyframe"]
    pub keyframe: bool,
    pub dts_usec: i64,
    pub sys_dts_usec: i64,
    #[doc = " Packet priority\n\n This is generally use by video encoders to specify the priority\n of the packet."]
    pub priority: ::std::os::raw::c_int,
    #[doc = " Dropped packet priority\n\n If this packet needs to be dropped, the next packet must be of this\n priority or higher to continue transmission."]
    pub drop_priority: ::std::os::raw::c_int,
    #[doc = " Audio track index (used with outputs)"]
    pub track_idx: usize,
    #[doc = " Encoder from which the track originated from"]
    pub encoder: *mut obs_encoder_t,
}
#[test]
fn bindgen_test_layout_encoder_packet() {
    const UNINIT: ::std::mem::MaybeUninit<encoder_packet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<encoder_packet>(),
        88usize,
        concat!("Size of: ", stringify!(encoder_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<encoder_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(encoder_packet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timebase_num) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(timebase_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timebase_den) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(timebase_den)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyframe) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(keyframe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts_usec) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(dts_usec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sys_dts_usec) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(sys_dts_usec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drop_priority) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(drop_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).track_idx) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(track_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(encoder)
        )
    );
}
impl Default for encoder_packet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encoder input frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct encoder_frame {
    #[doc = " Data for the frame/audio"]
    pub data: [*mut u8; 8usize],
    #[doc = " size of each plane"]
    pub linesize: [u32; 8usize],
    #[doc = " Number of frames (audio only)"]
    pub frames: u32,
    #[doc = " Presentation timestamp"]
    pub pts: i64,
}
#[test]
fn bindgen_test_layout_encoder_frame() {
    const UNINIT: ::std::mem::MaybeUninit<encoder_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<encoder_frame>(),
        112usize,
        concat!("Size of: ", stringify!(encoder_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<encoder_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(encoder_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_frame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linesize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_frame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_frame),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_frame),
            "::",
            stringify!(pts)
        )
    );
}
impl Default for encoder_frame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encoder interface\n\n Encoders have a limited usage with OBS.  You are not generally supposed to\n implement every encoder out there.  Generally, these are limited or specific\n encoders for h264/aac for streaming and recording.  It doesn't have to be\n *just* h264 or aac of course, but generally those are the expected encoders.\n\n That being said, other encoders will be kept in mind for future use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_encoder_info {
    #[doc = " Specifies the named identifier of this encoder"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = " Specifies the encoder type (video or audio)"]
    pub type_: obs_encoder_type,
    #[doc = " Specifies the codec"]
    pub codec: *const ::std::os::raw::c_char,
    #[doc = " Gets the full translated name of this encoder\n\n @param  type_data  The type_data variable of this structure\n @return            Translated name of the encoder"]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            type_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Creates the encoder with the specified settings\n\n @param  settings  Settings for the encoder\n @param  encoder   OBS encoder context\n @return           Data associated with this encoder context, or\n                   NULL if initialization failed."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut obs_data_t,
            encoder: *mut obs_encoder_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroys the encoder data\n\n @param  data  Data associated with this encoder context"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Encodes frame(s), and outputs encoded packets as they become\n available.\n\n @param       data             Data associated with this encoder\n                               context\n @param[in]   frame            Raw audio/video data to encode\n @param[out]  packet           Encoder packet output, if any\n @param[out]  received_packet  Set to true if a packet was received,\n                               false otherwise\n @return                       true if successful, false otherwise."]
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            frame: *mut encoder_frame,
            packet: *mut encoder_packet,
            received_packet: *mut bool,
        ) -> bool,
    >,
    #[doc = " Audio encoder only:  Returns the frame size for this encoder"]
    pub get_frame_size:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> usize>,
    #[doc = " Gets the default settings for this encoder\n\n @param[out]  settings  Data to assign default settings to"]
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    #[doc = " Gets the property information of this encoder\n\n @return         The properties data"]
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t,
    >,
    #[doc = " Updates the settings for this encoder (usually used for things like\n changing bitrate while active)\n\n @param  data      Data associated with this encoder context\n @param  settings  New settings for this encoder\n @return           true if successful, false otherwise"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t) -> bool,
    >,
    #[doc = " Returns extra data associated with this encoder (usually header)\n\n @param  data             Data associated with this encoder context\n @param[out]  extra_data  Pointer to receive the extra data\n @param[out]  size        Pointer to receive the size of the extra\n                          data\n @return                  true if extra data available, false\n                          otherwise"]
    pub get_extra_data: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            extra_data: *mut *mut u8,
            size: *mut usize,
        ) -> bool,
    >,
    #[doc = " Gets the SEI data, if any\n\n @param       data      Data associated with this encoder context\n @param[out]  sei_data  Pointer to receive the SEI data\n @param[out]  size      Pointer to receive the SEI data size\n @return                true if SEI data available, false otherwise"]
    pub get_sei_data: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            sei_data: *mut *mut u8,
            size: *mut usize,
        ) -> bool,
    >,
    #[doc = " Returns desired audio format and sample information\n\n @param          data  Data associated with this encoder context\n @param[in/out]  info  Audio format information"]
    pub get_audio_info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *mut audio_convert_info),
    >,
    #[doc = " Returns desired video format information\n\n @param          data  Data associated with this encoder context\n @param[in/out]  info  Video format information"]
    pub get_video_info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *mut video_scale_info),
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub caps: u32,
    #[doc = " Gets the default settings for this encoder\n\n If get_defaults is also defined both will be called, and the first\n call will be to get_defaults, then to get_defaults2.\n\n @param[out]  settings  Data to assign default settings to\n @param[in]   typedata  Type Data"]
    pub get_defaults2: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut obs_data_t, type_data: *mut ::std::os::raw::c_void),
    >,
    #[doc = " Gets the property information of this encoder\n\n @param[in]   data      Pointer from create (or null)\n @param[in]   typedata  Type Data\n @return                The properties data"]
    pub get_properties2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            type_data: *mut ::std::os::raw::c_void,
        ) -> *mut obs_properties_t,
    >,
    pub encode_texture: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            handle: u32,
            pts: i64,
            lock_key: u64,
            next_key: *mut u64,
            packet: *mut encoder_packet,
            received_packet: *mut bool,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_obs_encoder_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_encoder_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_encoder_info>(),
        168usize,
        concat!("Size of: ", stringify!(obs_encoder_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_encoder_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_encoder_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_frame_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_frame_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_defaults) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_defaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_extra_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_extra_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sei_data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_sei_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_audio_info) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_audio_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_video_info) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_video_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_data) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_type_data) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(free_type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caps) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(caps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_defaults2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_defaults2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_properties2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode_texture) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(encode_texture)
        )
    );
}
impl Default for obs_encoder_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn obs_register_encoder_s(info: *const obs_encoder_info, size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_output_info {
    pub id: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            type_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut obs_data_t,
            output: *mut obs_output_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub start:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    pub stop:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, ts: u64)>,
    pub raw_video: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, frame: *mut video_data),
    >,
    pub raw_audio: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, frames: *mut audio_data),
    >,
    pub encoded_packet: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, packet: *mut encoder_packet),
    >,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t,
    >,
    pub unused1: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub get_total_bytes:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u64>,
    pub get_dropped_frames: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub get_congestion:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> f32>,
    pub get_connect_time_ms: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub encoded_video_codecs: *const ::std::os::raw::c_char,
    pub encoded_audio_codecs: *const ::std::os::raw::c_char,
    pub raw_audio2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            idx: usize,
            frames: *mut audio_data,
        ),
    >,
    pub protocols: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_output_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_output_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_output_info>(),
        192usize,
        concat!("Size of: ", stringify!(obs_output_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_output_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_output_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_video) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(raw_video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_audio) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(raw_audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoded_packet) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(encoded_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_defaults) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_defaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused1) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(unused1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_total_bytes) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_total_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_dropped_frames) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_dropped_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_data) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_type_data) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(free_type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_congestion) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_congestion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_connect_time_ms) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_connect_time_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoded_video_codecs) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(encoded_video_codecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoded_audio_codecs) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(encoded_audio_codecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_audio2) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(raw_audio2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocols) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(protocols)
        )
    );
}
impl Default for obs_output_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn obs_register_output_s(info: *const obs_output_info, size: usize);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct obs_service_resolution {
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_obs_service_resolution() {
    const UNINIT: ::std::mem::MaybeUninit<obs_service_resolution> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_service_resolution>(),
        8usize,
        concat!("Size of: ", stringify!(obs_service_resolution))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_service_resolution>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_service_resolution))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_resolution),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_resolution),
            "::",
            stringify!(cy)
        )
    );
}
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_SERVER_URL: obs_service_connect_info =
    0;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_STREAM_ID: obs_service_connect_info = 2;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_STREAM_KEY: obs_service_connect_info =
    2;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_USERNAME: obs_service_connect_info = 4;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_PASSWORD: obs_service_connect_info = 6;
pub const obs_service_connect_info_OBS_SERVICE_CONNECT_INFO_ENCRYPT_PASSPHRASE:
    obs_service_connect_info = 8;
pub type obs_service_connect_info = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_service_info {
    pub id: *const ::std::os::raw::c_char,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            type_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut obs_data_t,
            service: *mut obs_service_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t,
    >,
    #[doc = " Called when getting ready to start up an output, before the encoders\n and output are initialized\n\n @param  data    Internal service data\n @param  output  Output context\n @return         true to allow the output to start up,\n                 false to prevent output from starting up"]
    pub initialize: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, output: *mut obs_output_t) -> bool,
    >,
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub get_key: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub get_username: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub get_password: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub deprecated_1: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    pub apply_encoder_settings: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            video_encoder_settings: *mut obs_data_t,
            audio_encoder_settings: *mut obs_data_t,
        ),
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub get_output_type: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub get_supported_resolutions: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            resolutions: *mut *mut obs_service_resolution,
            count: *mut usize,
        ),
    >,
    pub get_max_fps: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, fps: *mut ::std::os::raw::c_int),
    >,
    pub get_max_bitrate: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            video_bitrate: *mut ::std::os::raw::c_int,
            audio_bitrate: *mut ::std::os::raw::c_int,
        ),
    >,
    pub get_supported_video_codecs: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
        ) -> *mut *const ::std::os::raw::c_char,
    >,
    pub get_protocol: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub get_supported_audio_codecs: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
        ) -> *mut *const ::std::os::raw::c_char,
    >,
    pub get_connect_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            type_: u32,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub can_try_to_connect:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
}
#[test]
fn bindgen_test_layout_obs_service_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_service_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_service_info>(),
        216usize,
        concat!("Size of: ", stringify!(obs_service_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_service_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_service_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deactivate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(deactivate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_defaults) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_defaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_key) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_username) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_password) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_1) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(deprecated_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apply_encoder_settings) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(apply_encoder_settings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_data) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_type_data) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(free_type_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_output_type) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_output_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_supported_resolutions) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_supported_resolutions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_max_fps) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_max_fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_max_bitrate) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_max_bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_supported_video_codecs) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_supported_video_codecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_protocol) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_supported_audio_codecs) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_supported_audio_codecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_connect_info) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_connect_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_try_to_connect) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(can_try_to_connect)
        )
    );
}
impl Default for obs_service_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn obs_register_service_s(info: *const obs_service_info, size: usize);
}
#[doc = " @brief A simple cubic fader for controlling audio levels\n\n This is a very common type of software fader since it yields good\n results while being quite performant.\n The input value is mapped to mul values with the simple formula x^3."]
pub const obs_fader_type_OBS_FADER_CUBIC: obs_fader_type = 0;
#[doc = " @brief A fader compliant to IEC 60-268-18\n\n This type of fader has several segments with different slopes that\n map deflection linearly to dB values. The segments are defined as\n in the following table:\n\n@code\nDeflection           | Volume\n------------------------------------------\n[ 100   %, 75   % ]  | [   0 dB,   -9 dB ]\n[  75   %, 50   % ]  | [  -9 dB,  -20 dB ]\n[  50   %, 30   % ]  | [ -20 dB,  -30 dB ]\n[  30   %, 15   % ]  | [ -30 dB,  -40 dB ]\n[  15   %,  7.5 % ]  | [ -40 dB,  -50 dB ]\n[   7.5 %,  2.5 % ]  | [ -50 dB,  -60 dB ]\n[   2.5 %,  0   % ]  | [ -60 dB, -inf dB ]\n@endcode"]
pub const obs_fader_type_OBS_FADER_IEC: obs_fader_type = 1;
#[doc = " @brief Logarithmic fader"]
pub const obs_fader_type_OBS_FADER_LOG: obs_fader_type = 2;
#[doc = " @brief Fader types"]
pub type obs_fader_type = ::std::os::raw::c_uint;
#[doc = " @brief A simple peak meter measuring the maximum of all samples.\n\n This was a very common type of peak meter used for audio, but\n is not very accurate with regards to further audio processing."]
pub const obs_peak_meter_type_SAMPLE_PEAK_METER: obs_peak_meter_type = 0;
#[doc = " @brief An accurate peak meter measure the maximum of inter-samples.\n\n This meter is more computational intensive due to 4x oversampling\n to determine the true peak to an accuracy of +/- 0.5 dB."]
pub const obs_peak_meter_type_TRUE_PEAK_METER: obs_peak_meter_type = 1;
#[doc = " @brief Peak meter types"]
pub type obs_peak_meter_type = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Create a fader\n @param type the type of the fader\n @return pointer to the fader object\n\n A fader object is used to map input values from a gui element to dB and\n subsequently multiplier values used by libobs to mix audio.\n The current \"position\" of the fader is internally stored as dB value."]
    pub fn obs_fader_create(type_: obs_fader_type) -> *mut obs_fader_t;
}
extern "C" {
    #[doc = " @brief Destroy a fader\n @param fader pointer to the fader object\n\n Destroy the fader and free all related data"]
    pub fn obs_fader_destroy(fader: *mut obs_fader_t);
}
extern "C" {
    #[doc = " @brief Set the fader dB value\n @param fader pointer to the fader object\n @param db new dB value\n @return true if value was set without clamping"]
    pub fn obs_fader_set_db(fader: *mut obs_fader_t, db: f32) -> bool;
}
extern "C" {
    #[doc = " @brief Get the current fader dB value\n @param fader pointer to the fader object\n @return current fader dB value"]
    pub fn obs_fader_get_db(fader: *mut obs_fader_t) -> f32;
}
extern "C" {
    #[doc = " @brief Set the fader value from deflection\n @param fader pointer to the fader object\n @param def new deflection\n @return true if value was set without clamping\n\n This sets the new fader value from the supplied deflection, in case the\n resulting value was clamped due to limits this function will return false.\n The deflection is typically in the range [0.0, 1.0] but may be higher in\n order to provide some amplification. In order for this to work the high dB\n limit has to be set."]
    pub fn obs_fader_set_deflection(fader: *mut obs_fader_t, def: f32) -> bool;
}
extern "C" {
    #[doc = " @brief Get the current fader deflection\n @param fader pointer to the fader object\n @return current fader deflection"]
    pub fn obs_fader_get_deflection(fader: *mut obs_fader_t) -> f32;
}
extern "C" {
    #[doc = " @brief Set the fader value from multiplier\n @param fader pointer to the fader object\n @return true if the value was set without clamping"]
    pub fn obs_fader_set_mul(fader: *mut obs_fader_t, mul: f32) -> bool;
}
extern "C" {
    #[doc = " @brief Get the current fader multiplier value\n @param fader pointer to the fader object\n @return current fader multiplier"]
    pub fn obs_fader_get_mul(fader: *mut obs_fader_t) -> f32;
}
extern "C" {
    #[doc = " @brief Attach the fader to a source\n @param fader pointer to the fader object\n @param source pointer to the source object\n @return true on success\n\n When the fader is attached to a source it will automatically sync it's state\n to the volume of the source."]
    pub fn obs_fader_attach_source(fader: *mut obs_fader_t, source: *mut obs_source_t) -> bool;
}
extern "C" {
    #[doc = " @brief Detach the fader from the currently attached source\n @param fader pointer to the fader object"]
    pub fn obs_fader_detach_source(fader: *mut obs_fader_t);
}
pub type obs_fader_changed_t =
    ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, db: f32)>;
extern "C" {
    pub fn obs_fader_add_callback(
        fader: *mut obs_fader_t,
        callback: obs_fader_changed_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_fader_remove_callback(
        fader: *mut obs_fader_t,
        callback: obs_fader_changed_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Create a volume meter\n @param type the mapping type to use for the volume meter\n @return pointer to the volume meter object\n\n A volume meter object is used to prepare the sound levels reported by audio\n sources for display in a GUI.\n It will automatically take source volume into account and map the levels\n to a range [0.0f, 1.0f]."]
    pub fn obs_volmeter_create(type_: obs_fader_type) -> *mut obs_volmeter_t;
}
extern "C" {
    #[doc = " @brief Destroy a volume meter\n @param volmeter pointer to the volmeter object\n\n Destroy the volume meter and free all related data"]
    pub fn obs_volmeter_destroy(volmeter: *mut obs_volmeter_t);
}
extern "C" {
    #[doc = " @brief Attach the volume meter to a source\n @param volmeter pointer to the volume meter object\n @param source pointer to the source object\n @return true on success\n\n When the volume meter is attached to a source it will start to listen to\n volume updates on the source and after preparing the data emit its own\n signal."]
    pub fn obs_volmeter_attach_source(
        volmeter: *mut obs_volmeter_t,
        source: *mut obs_source_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Detach the volume meter from the currently attached source\n @param volmeter pointer to the volume meter object"]
    pub fn obs_volmeter_detach_source(volmeter: *mut obs_volmeter_t);
}
extern "C" {
    #[doc = " @brief Set the peak meter type for the volume meter\n @param volmeter pointer to the volume meter object\n @param peak_meter_type set if true-peak needs to be measured."]
    pub fn obs_volmeter_set_peak_meter_type(
        volmeter: *mut obs_volmeter_t,
        peak_meter_type: obs_peak_meter_type,
    );
}
extern "C" {
    #[doc = " @brief Set the update interval for the volume meter\n @param volmeter pointer to the volume meter object\n @param ms update interval in ms\n\n This sets the update interval in milliseconds that should be processed before\n the resulting values are emitted by the levels_updated signal. The resulting\n number of audio samples is rounded to an integer.\n\n Please note that due to way obs does receive audio data from the sources\n this is no hard guarantee for the timing of the signal itself. When the\n volume meter receives a chunk of data that is multiple the size of the sample\n interval, all data will be sampled and the values updated accordingly, but\n only the signal for the last segment is actually emitted.\n On the other hand data might be received in a way that will cause the signal\n to be emitted in shorter intervals than specified here under some\n circumstances."]
    pub fn obs_volmeter_set_update_interval(
        volmeter: *mut obs_volmeter_t,
        ms: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Get the update interval currently used for the volume meter\n @param volmeter pointer to the volume meter object\n @return update interval in ms"]
    pub fn obs_volmeter_get_update_interval(
        volmeter: *mut obs_volmeter_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Get the number of channels which are configured for this source.\n @param volmeter pointer to the volume meter object"]
    pub fn obs_volmeter_get_nr_channels(volmeter: *mut obs_volmeter_t) -> ::std::os::raw::c_int;
}
pub type obs_volmeter_updated_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        magnitude: *const f32,
        peak: *const f32,
        input_peak: *const f32,
    ),
>;
extern "C" {
    pub fn obs_volmeter_add_callback(
        volmeter: *mut obs_volmeter_t,
        callback: obs_volmeter_updated_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_volmeter_remove_callback(
        volmeter: *mut obs_volmeter_t,
        callback: obs_volmeter_updated_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_mul_to_db(mul: f32) -> f32;
}
extern "C" {
    pub fn obs_db_to_mul(db: f32) -> f32;
}
pub type obs_hotkey_id = usize;
pub type obs_hotkey_pair_id = usize;
pub const obs_key_OBS_KEY_NONE: obs_key = 0;
pub const obs_key_OBS_KEY_RETURN: obs_key = 1;
pub const obs_key_OBS_KEY_ENTER: obs_key = 2;
pub const obs_key_OBS_KEY_ESCAPE: obs_key = 3;
pub const obs_key_OBS_KEY_TAB: obs_key = 4;
pub const obs_key_OBS_KEY_BACKTAB: obs_key = 5;
pub const obs_key_OBS_KEY_BACKSPACE: obs_key = 6;
pub const obs_key_OBS_KEY_INSERT: obs_key = 7;
pub const obs_key_OBS_KEY_DELETE: obs_key = 8;
pub const obs_key_OBS_KEY_PAUSE: obs_key = 9;
pub const obs_key_OBS_KEY_PRINT: obs_key = 10;
pub const obs_key_OBS_KEY_SYSREQ: obs_key = 11;
pub const obs_key_OBS_KEY_CLEAR: obs_key = 12;
pub const obs_key_OBS_KEY_HOME: obs_key = 13;
pub const obs_key_OBS_KEY_END: obs_key = 14;
pub const obs_key_OBS_KEY_LEFT: obs_key = 15;
pub const obs_key_OBS_KEY_UP: obs_key = 16;
pub const obs_key_OBS_KEY_RIGHT: obs_key = 17;
pub const obs_key_OBS_KEY_DOWN: obs_key = 18;
pub const obs_key_OBS_KEY_PAGEUP: obs_key = 19;
pub const obs_key_OBS_KEY_PAGEDOWN: obs_key = 20;
pub const obs_key_OBS_KEY_SHIFT: obs_key = 21;
pub const obs_key_OBS_KEY_CONTROL: obs_key = 22;
pub const obs_key_OBS_KEY_META: obs_key = 23;
pub const obs_key_OBS_KEY_ALT: obs_key = 24;
pub const obs_key_OBS_KEY_ALTGR: obs_key = 25;
pub const obs_key_OBS_KEY_CAPSLOCK: obs_key = 26;
pub const obs_key_OBS_KEY_NUMLOCK: obs_key = 27;
pub const obs_key_OBS_KEY_SCROLLLOCK: obs_key = 28;
pub const obs_key_OBS_KEY_F1: obs_key = 29;
pub const obs_key_OBS_KEY_F2: obs_key = 30;
pub const obs_key_OBS_KEY_F3: obs_key = 31;
pub const obs_key_OBS_KEY_F4: obs_key = 32;
pub const obs_key_OBS_KEY_F5: obs_key = 33;
pub const obs_key_OBS_KEY_F6: obs_key = 34;
pub const obs_key_OBS_KEY_F7: obs_key = 35;
pub const obs_key_OBS_KEY_F8: obs_key = 36;
pub const obs_key_OBS_KEY_F9: obs_key = 37;
pub const obs_key_OBS_KEY_F10: obs_key = 38;
pub const obs_key_OBS_KEY_F11: obs_key = 39;
pub const obs_key_OBS_KEY_F12: obs_key = 40;
pub const obs_key_OBS_KEY_F13: obs_key = 41;
pub const obs_key_OBS_KEY_F14: obs_key = 42;
pub const obs_key_OBS_KEY_F15: obs_key = 43;
pub const obs_key_OBS_KEY_F16: obs_key = 44;
pub const obs_key_OBS_KEY_F17: obs_key = 45;
pub const obs_key_OBS_KEY_F18: obs_key = 46;
pub const obs_key_OBS_KEY_F19: obs_key = 47;
pub const obs_key_OBS_KEY_F20: obs_key = 48;
pub const obs_key_OBS_KEY_F21: obs_key = 49;
pub const obs_key_OBS_KEY_F22: obs_key = 50;
pub const obs_key_OBS_KEY_F23: obs_key = 51;
pub const obs_key_OBS_KEY_F24: obs_key = 52;
pub const obs_key_OBS_KEY_F25: obs_key = 53;
pub const obs_key_OBS_KEY_F26: obs_key = 54;
pub const obs_key_OBS_KEY_F27: obs_key = 55;
pub const obs_key_OBS_KEY_F28: obs_key = 56;
pub const obs_key_OBS_KEY_F29: obs_key = 57;
pub const obs_key_OBS_KEY_F30: obs_key = 58;
pub const obs_key_OBS_KEY_F31: obs_key = 59;
pub const obs_key_OBS_KEY_F32: obs_key = 60;
pub const obs_key_OBS_KEY_F33: obs_key = 61;
pub const obs_key_OBS_KEY_F34: obs_key = 62;
pub const obs_key_OBS_KEY_F35: obs_key = 63;
pub const obs_key_OBS_KEY_MENU: obs_key = 64;
pub const obs_key_OBS_KEY_HYPER_L: obs_key = 65;
pub const obs_key_OBS_KEY_HYPER_R: obs_key = 66;
pub const obs_key_OBS_KEY_HELP: obs_key = 67;
pub const obs_key_OBS_KEY_DIRECTION_L: obs_key = 68;
pub const obs_key_OBS_KEY_DIRECTION_R: obs_key = 69;
pub const obs_key_OBS_KEY_SPACE: obs_key = 70;
pub const obs_key_OBS_KEY_EXCLAM: obs_key = 71;
pub const obs_key_OBS_KEY_QUOTEDBL: obs_key = 72;
pub const obs_key_OBS_KEY_NUMBERSIGN: obs_key = 73;
pub const obs_key_OBS_KEY_DOLLAR: obs_key = 74;
pub const obs_key_OBS_KEY_PERCENT: obs_key = 75;
pub const obs_key_OBS_KEY_AMPERSAND: obs_key = 76;
pub const obs_key_OBS_KEY_APOSTROPHE: obs_key = 77;
pub const obs_key_OBS_KEY_PARENLEFT: obs_key = 78;
pub const obs_key_OBS_KEY_PARENRIGHT: obs_key = 79;
pub const obs_key_OBS_KEY_ASTERISK: obs_key = 80;
pub const obs_key_OBS_KEY_PLUS: obs_key = 81;
pub const obs_key_OBS_KEY_COMMA: obs_key = 82;
pub const obs_key_OBS_KEY_MINUS: obs_key = 83;
pub const obs_key_OBS_KEY_PERIOD: obs_key = 84;
pub const obs_key_OBS_KEY_SLASH: obs_key = 85;
pub const obs_key_OBS_KEY_0: obs_key = 86;
pub const obs_key_OBS_KEY_1: obs_key = 87;
pub const obs_key_OBS_KEY_2: obs_key = 88;
pub const obs_key_OBS_KEY_3: obs_key = 89;
pub const obs_key_OBS_KEY_4: obs_key = 90;
pub const obs_key_OBS_KEY_5: obs_key = 91;
pub const obs_key_OBS_KEY_6: obs_key = 92;
pub const obs_key_OBS_KEY_7: obs_key = 93;
pub const obs_key_OBS_KEY_8: obs_key = 94;
pub const obs_key_OBS_KEY_9: obs_key = 95;
pub const obs_key_OBS_KEY_NUMEQUAL: obs_key = 96;
pub const obs_key_OBS_KEY_NUMASTERISK: obs_key = 97;
pub const obs_key_OBS_KEY_NUMPLUS: obs_key = 98;
pub const obs_key_OBS_KEY_NUMCOMMA: obs_key = 99;
pub const obs_key_OBS_KEY_NUMMINUS: obs_key = 100;
pub const obs_key_OBS_KEY_NUMPERIOD: obs_key = 101;
pub const obs_key_OBS_KEY_NUMSLASH: obs_key = 102;
pub const obs_key_OBS_KEY_NUM0: obs_key = 103;
pub const obs_key_OBS_KEY_NUM1: obs_key = 104;
pub const obs_key_OBS_KEY_NUM2: obs_key = 105;
pub const obs_key_OBS_KEY_NUM3: obs_key = 106;
pub const obs_key_OBS_KEY_NUM4: obs_key = 107;
pub const obs_key_OBS_KEY_NUM5: obs_key = 108;
pub const obs_key_OBS_KEY_NUM6: obs_key = 109;
pub const obs_key_OBS_KEY_NUM7: obs_key = 110;
pub const obs_key_OBS_KEY_NUM8: obs_key = 111;
pub const obs_key_OBS_KEY_NUM9: obs_key = 112;
pub const obs_key_OBS_KEY_COLON: obs_key = 113;
pub const obs_key_OBS_KEY_SEMICOLON: obs_key = 114;
pub const obs_key_OBS_KEY_QUOTE: obs_key = 115;
pub const obs_key_OBS_KEY_LESS: obs_key = 116;
pub const obs_key_OBS_KEY_EQUAL: obs_key = 117;
pub const obs_key_OBS_KEY_GREATER: obs_key = 118;
pub const obs_key_OBS_KEY_QUESTION: obs_key = 119;
pub const obs_key_OBS_KEY_AT: obs_key = 120;
pub const obs_key_OBS_KEY_A: obs_key = 121;
pub const obs_key_OBS_KEY_B: obs_key = 122;
pub const obs_key_OBS_KEY_C: obs_key = 123;
pub const obs_key_OBS_KEY_D: obs_key = 124;
pub const obs_key_OBS_KEY_E: obs_key = 125;
pub const obs_key_OBS_KEY_F: obs_key = 126;
pub const obs_key_OBS_KEY_G: obs_key = 127;
pub const obs_key_OBS_KEY_H: obs_key = 128;
pub const obs_key_OBS_KEY_I: obs_key = 129;
pub const obs_key_OBS_KEY_J: obs_key = 130;
pub const obs_key_OBS_KEY_K: obs_key = 131;
pub const obs_key_OBS_KEY_L: obs_key = 132;
pub const obs_key_OBS_KEY_M: obs_key = 133;
pub const obs_key_OBS_KEY_N: obs_key = 134;
pub const obs_key_OBS_KEY_O: obs_key = 135;
pub const obs_key_OBS_KEY_P: obs_key = 136;
pub const obs_key_OBS_KEY_Q: obs_key = 137;
pub const obs_key_OBS_KEY_R: obs_key = 138;
pub const obs_key_OBS_KEY_S: obs_key = 139;
pub const obs_key_OBS_KEY_T: obs_key = 140;
pub const obs_key_OBS_KEY_U: obs_key = 141;
pub const obs_key_OBS_KEY_V: obs_key = 142;
pub const obs_key_OBS_KEY_W: obs_key = 143;
pub const obs_key_OBS_KEY_X: obs_key = 144;
pub const obs_key_OBS_KEY_Y: obs_key = 145;
pub const obs_key_OBS_KEY_Z: obs_key = 146;
pub const obs_key_OBS_KEY_BRACKETLEFT: obs_key = 147;
pub const obs_key_OBS_KEY_BACKSLASH: obs_key = 148;
pub const obs_key_OBS_KEY_BRACKETRIGHT: obs_key = 149;
pub const obs_key_OBS_KEY_ASCIICIRCUM: obs_key = 150;
pub const obs_key_OBS_KEY_UNDERSCORE: obs_key = 151;
pub const obs_key_OBS_KEY_QUOTELEFT: obs_key = 152;
pub const obs_key_OBS_KEY_BRACELEFT: obs_key = 153;
pub const obs_key_OBS_KEY_BAR: obs_key = 154;
pub const obs_key_OBS_KEY_BRACERIGHT: obs_key = 155;
pub const obs_key_OBS_KEY_ASCIITILDE: obs_key = 156;
pub const obs_key_OBS_KEY_NOBREAKSPACE: obs_key = 157;
pub const obs_key_OBS_KEY_EXCLAMDOWN: obs_key = 158;
pub const obs_key_OBS_KEY_CENT: obs_key = 159;
pub const obs_key_OBS_KEY_STERLING: obs_key = 160;
pub const obs_key_OBS_KEY_CURRENCY: obs_key = 161;
pub const obs_key_OBS_KEY_YEN: obs_key = 162;
pub const obs_key_OBS_KEY_BROKENBAR: obs_key = 163;
pub const obs_key_OBS_KEY_SECTION: obs_key = 164;
pub const obs_key_OBS_KEY_DIAERESIS: obs_key = 165;
pub const obs_key_OBS_KEY_COPYRIGHT: obs_key = 166;
pub const obs_key_OBS_KEY_ORDFEMININE: obs_key = 167;
pub const obs_key_OBS_KEY_GUILLEMOTLEFT: obs_key = 168;
pub const obs_key_OBS_KEY_NOTSIGN: obs_key = 169;
pub const obs_key_OBS_KEY_HYPHEN: obs_key = 170;
pub const obs_key_OBS_KEY_REGISTERED: obs_key = 171;
pub const obs_key_OBS_KEY_MACRON: obs_key = 172;
pub const obs_key_OBS_KEY_DEGREE: obs_key = 173;
pub const obs_key_OBS_KEY_PLUSMINUS: obs_key = 174;
pub const obs_key_OBS_KEY_TWOSUPERIOR: obs_key = 175;
pub const obs_key_OBS_KEY_THREESUPERIOR: obs_key = 176;
pub const obs_key_OBS_KEY_ACUTE: obs_key = 177;
pub const obs_key_OBS_KEY_MU: obs_key = 178;
pub const obs_key_OBS_KEY_PARAGRAPH: obs_key = 179;
pub const obs_key_OBS_KEY_PERIODCENTERED: obs_key = 180;
pub const obs_key_OBS_KEY_CEDILLA: obs_key = 181;
pub const obs_key_OBS_KEY_ONESUPERIOR: obs_key = 182;
pub const obs_key_OBS_KEY_MASCULINE: obs_key = 183;
pub const obs_key_OBS_KEY_GUILLEMOTRIGHT: obs_key = 184;
pub const obs_key_OBS_KEY_ONEQUARTER: obs_key = 185;
pub const obs_key_OBS_KEY_ONEHALF: obs_key = 186;
pub const obs_key_OBS_KEY_THREEQUARTERS: obs_key = 187;
pub const obs_key_OBS_KEY_QUESTIONDOWN: obs_key = 188;
pub const obs_key_OBS_KEY_AGRAVE: obs_key = 189;
pub const obs_key_OBS_KEY_AACUTE: obs_key = 190;
pub const obs_key_OBS_KEY_ACIRCUMFLEX: obs_key = 191;
pub const obs_key_OBS_KEY_ATILDE: obs_key = 192;
pub const obs_key_OBS_KEY_ADIAERESIS: obs_key = 193;
pub const obs_key_OBS_KEY_ARING: obs_key = 194;
pub const obs_key_OBS_KEY_AE: obs_key = 195;
pub const obs_key_OBS_KEY_CCEDILLA: obs_key = 196;
pub const obs_key_OBS_KEY_EGRAVE: obs_key = 197;
pub const obs_key_OBS_KEY_EACUTE: obs_key = 198;
pub const obs_key_OBS_KEY_ECIRCUMFLEX: obs_key = 199;
pub const obs_key_OBS_KEY_EDIAERESIS: obs_key = 200;
pub const obs_key_OBS_KEY_IGRAVE: obs_key = 201;
pub const obs_key_OBS_KEY_IACUTE: obs_key = 202;
pub const obs_key_OBS_KEY_ICIRCUMFLEX: obs_key = 203;
pub const obs_key_OBS_KEY_IDIAERESIS: obs_key = 204;
pub const obs_key_OBS_KEY_ETH: obs_key = 205;
pub const obs_key_OBS_KEY_NTILDE: obs_key = 206;
pub const obs_key_OBS_KEY_OGRAVE: obs_key = 207;
pub const obs_key_OBS_KEY_OACUTE: obs_key = 208;
pub const obs_key_OBS_KEY_OCIRCUMFLEX: obs_key = 209;
pub const obs_key_OBS_KEY_OTILDE: obs_key = 210;
pub const obs_key_OBS_KEY_ODIAERESIS: obs_key = 211;
pub const obs_key_OBS_KEY_MULTIPLY: obs_key = 212;
pub const obs_key_OBS_KEY_OOBLIQUE: obs_key = 213;
pub const obs_key_OBS_KEY_UGRAVE: obs_key = 214;
pub const obs_key_OBS_KEY_UACUTE: obs_key = 215;
pub const obs_key_OBS_KEY_UCIRCUMFLEX: obs_key = 216;
pub const obs_key_OBS_KEY_UDIAERESIS: obs_key = 217;
pub const obs_key_OBS_KEY_YACUTE: obs_key = 218;
pub const obs_key_OBS_KEY_THORN: obs_key = 219;
pub const obs_key_OBS_KEY_SSHARP: obs_key = 220;
pub const obs_key_OBS_KEY_DIVISION: obs_key = 221;
pub const obs_key_OBS_KEY_YDIAERESIS: obs_key = 222;
pub const obs_key_OBS_KEY_MULTI_KEY: obs_key = 223;
pub const obs_key_OBS_KEY_CODEINPUT: obs_key = 224;
pub const obs_key_OBS_KEY_SINGLECANDIDATE: obs_key = 225;
pub const obs_key_OBS_KEY_MULTIPLECANDIDATE: obs_key = 226;
pub const obs_key_OBS_KEY_PREVIOUSCANDIDATE: obs_key = 227;
pub const obs_key_OBS_KEY_MODE_SWITCH: obs_key = 228;
pub const obs_key_OBS_KEY_KANJI: obs_key = 229;
pub const obs_key_OBS_KEY_MUHENKAN: obs_key = 230;
pub const obs_key_OBS_KEY_HENKAN: obs_key = 231;
pub const obs_key_OBS_KEY_ROMAJI: obs_key = 232;
pub const obs_key_OBS_KEY_HIRAGANA: obs_key = 233;
pub const obs_key_OBS_KEY_KATAKANA: obs_key = 234;
pub const obs_key_OBS_KEY_HIRAGANA_KATAKANA: obs_key = 235;
pub const obs_key_OBS_KEY_ZENKAKU: obs_key = 236;
pub const obs_key_OBS_KEY_HANKAKU: obs_key = 237;
pub const obs_key_OBS_KEY_ZENKAKU_HANKAKU: obs_key = 238;
pub const obs_key_OBS_KEY_TOUROKU: obs_key = 239;
pub const obs_key_OBS_KEY_MASSYO: obs_key = 240;
pub const obs_key_OBS_KEY_KANA_LOCK: obs_key = 241;
pub const obs_key_OBS_KEY_KANA_SHIFT: obs_key = 242;
pub const obs_key_OBS_KEY_EISU_SHIFT: obs_key = 243;
pub const obs_key_OBS_KEY_EISU_TOGGLE: obs_key = 244;
pub const obs_key_OBS_KEY_HANGUL: obs_key = 245;
pub const obs_key_OBS_KEY_HANGUL_START: obs_key = 246;
pub const obs_key_OBS_KEY_HANGUL_END: obs_key = 247;
pub const obs_key_OBS_KEY_HANGUL_HANJA: obs_key = 248;
pub const obs_key_OBS_KEY_HANGUL_JAMO: obs_key = 249;
pub const obs_key_OBS_KEY_HANGUL_ROMAJA: obs_key = 250;
pub const obs_key_OBS_KEY_HANGUL_JEONJA: obs_key = 251;
pub const obs_key_OBS_KEY_HANGUL_BANJA: obs_key = 252;
pub const obs_key_OBS_KEY_HANGUL_PREHANJA: obs_key = 253;
pub const obs_key_OBS_KEY_HANGUL_POSTHANJA: obs_key = 254;
pub const obs_key_OBS_KEY_HANGUL_SPECIAL: obs_key = 255;
pub const obs_key_OBS_KEY_DEAD_GRAVE: obs_key = 256;
pub const obs_key_OBS_KEY_DEAD_ACUTE: obs_key = 257;
pub const obs_key_OBS_KEY_DEAD_CIRCUMFLEX: obs_key = 258;
pub const obs_key_OBS_KEY_DEAD_TILDE: obs_key = 259;
pub const obs_key_OBS_KEY_DEAD_MACRON: obs_key = 260;
pub const obs_key_OBS_KEY_DEAD_BREVE: obs_key = 261;
pub const obs_key_OBS_KEY_DEAD_ABOVEDOT: obs_key = 262;
pub const obs_key_OBS_KEY_DEAD_DIAERESIS: obs_key = 263;
pub const obs_key_OBS_KEY_DEAD_ABOVERING: obs_key = 264;
pub const obs_key_OBS_KEY_DEAD_DOUBLEACUTE: obs_key = 265;
pub const obs_key_OBS_KEY_DEAD_CARON: obs_key = 266;
pub const obs_key_OBS_KEY_DEAD_CEDILLA: obs_key = 267;
pub const obs_key_OBS_KEY_DEAD_OGONEK: obs_key = 268;
pub const obs_key_OBS_KEY_DEAD_IOTA: obs_key = 269;
pub const obs_key_OBS_KEY_DEAD_VOICED_SOUND: obs_key = 270;
pub const obs_key_OBS_KEY_DEAD_SEMIVOICED_SOUND: obs_key = 271;
pub const obs_key_OBS_KEY_DEAD_BELOWDOT: obs_key = 272;
pub const obs_key_OBS_KEY_DEAD_HOOK: obs_key = 273;
pub const obs_key_OBS_KEY_DEAD_HORN: obs_key = 274;
pub const obs_key_OBS_KEY_BACK: obs_key = 275;
pub const obs_key_OBS_KEY_FORWARD: obs_key = 276;
pub const obs_key_OBS_KEY_STOP: obs_key = 277;
pub const obs_key_OBS_KEY_REFRESH: obs_key = 278;
pub const obs_key_OBS_KEY_VOLUMEDOWN: obs_key = 279;
pub const obs_key_OBS_KEY_VOLUMEMUTE: obs_key = 280;
pub const obs_key_OBS_KEY_VOLUMEUP: obs_key = 281;
pub const obs_key_OBS_KEY_BASSBOOST: obs_key = 282;
pub const obs_key_OBS_KEY_BASSUP: obs_key = 283;
pub const obs_key_OBS_KEY_BASSDOWN: obs_key = 284;
pub const obs_key_OBS_KEY_TREBLEUP: obs_key = 285;
pub const obs_key_OBS_KEY_TREBLEDOWN: obs_key = 286;
pub const obs_key_OBS_KEY_MEDIAPLAY: obs_key = 287;
pub const obs_key_OBS_KEY_MEDIASTOP: obs_key = 288;
pub const obs_key_OBS_KEY_MEDIAPREVIOUS: obs_key = 289;
pub const obs_key_OBS_KEY_MEDIANEXT: obs_key = 290;
pub const obs_key_OBS_KEY_MEDIARECORD: obs_key = 291;
pub const obs_key_OBS_KEY_MEDIAPAUSE: obs_key = 292;
pub const obs_key_OBS_KEY_MEDIATOGGLEPLAYPAUSE: obs_key = 293;
pub const obs_key_OBS_KEY_HOMEPAGE: obs_key = 294;
pub const obs_key_OBS_KEY_FAVORITES: obs_key = 295;
pub const obs_key_OBS_KEY_SEARCH: obs_key = 296;
pub const obs_key_OBS_KEY_STANDBY: obs_key = 297;
pub const obs_key_OBS_KEY_OPENURL: obs_key = 298;
pub const obs_key_OBS_KEY_LAUNCHMAIL: obs_key = 299;
pub const obs_key_OBS_KEY_LAUNCHMEDIA: obs_key = 300;
pub const obs_key_OBS_KEY_LAUNCH0: obs_key = 301;
pub const obs_key_OBS_KEY_LAUNCH1: obs_key = 302;
pub const obs_key_OBS_KEY_LAUNCH2: obs_key = 303;
pub const obs_key_OBS_KEY_LAUNCH3: obs_key = 304;
pub const obs_key_OBS_KEY_LAUNCH4: obs_key = 305;
pub const obs_key_OBS_KEY_LAUNCH5: obs_key = 306;
pub const obs_key_OBS_KEY_LAUNCH6: obs_key = 307;
pub const obs_key_OBS_KEY_LAUNCH7: obs_key = 308;
pub const obs_key_OBS_KEY_LAUNCH8: obs_key = 309;
pub const obs_key_OBS_KEY_LAUNCH9: obs_key = 310;
pub const obs_key_OBS_KEY_LAUNCHA: obs_key = 311;
pub const obs_key_OBS_KEY_LAUNCHB: obs_key = 312;
pub const obs_key_OBS_KEY_LAUNCHC: obs_key = 313;
pub const obs_key_OBS_KEY_LAUNCHD: obs_key = 314;
pub const obs_key_OBS_KEY_LAUNCHE: obs_key = 315;
pub const obs_key_OBS_KEY_LAUNCHF: obs_key = 316;
pub const obs_key_OBS_KEY_LAUNCHG: obs_key = 317;
pub const obs_key_OBS_KEY_LAUNCHH: obs_key = 318;
pub const obs_key_OBS_KEY_MONBRIGHTNESSUP: obs_key = 319;
pub const obs_key_OBS_KEY_MONBRIGHTNESSDOWN: obs_key = 320;
pub const obs_key_OBS_KEY_KEYBOARDLIGHTONOFF: obs_key = 321;
pub const obs_key_OBS_KEY_KEYBOARDBRIGHTNESSUP: obs_key = 322;
pub const obs_key_OBS_KEY_KEYBOARDBRIGHTNESSDOWN: obs_key = 323;
pub const obs_key_OBS_KEY_POWEROFF: obs_key = 324;
pub const obs_key_OBS_KEY_WAKEUP: obs_key = 325;
pub const obs_key_OBS_KEY_EJECT: obs_key = 326;
pub const obs_key_OBS_KEY_SCREENSAVER: obs_key = 327;
pub const obs_key_OBS_KEY_WWW: obs_key = 328;
pub const obs_key_OBS_KEY_MEMO: obs_key = 329;
pub const obs_key_OBS_KEY_LIGHTBULB: obs_key = 330;
pub const obs_key_OBS_KEY_SHOP: obs_key = 331;
pub const obs_key_OBS_KEY_HISTORY: obs_key = 332;
pub const obs_key_OBS_KEY_ADDFAVORITE: obs_key = 333;
pub const obs_key_OBS_KEY_HOTLINKS: obs_key = 334;
pub const obs_key_OBS_KEY_BRIGHTNESSADJUST: obs_key = 335;
pub const obs_key_OBS_KEY_FINANCE: obs_key = 336;
pub const obs_key_OBS_KEY_COMMUNITY: obs_key = 337;
pub const obs_key_OBS_KEY_AUDIOREWIND: obs_key = 338;
pub const obs_key_OBS_KEY_BACKFORWARD: obs_key = 339;
pub const obs_key_OBS_KEY_APPLICATIONLEFT: obs_key = 340;
pub const obs_key_OBS_KEY_APPLICATIONRIGHT: obs_key = 341;
pub const obs_key_OBS_KEY_BOOK: obs_key = 342;
pub const obs_key_OBS_KEY_CD: obs_key = 343;
pub const obs_key_OBS_KEY_CALCULATOR: obs_key = 344;
pub const obs_key_OBS_KEY_TODOLIST: obs_key = 345;
pub const obs_key_OBS_KEY_CLEARGRAB: obs_key = 346;
pub const obs_key_OBS_KEY_CLOSE: obs_key = 347;
pub const obs_key_OBS_KEY_COPY: obs_key = 348;
pub const obs_key_OBS_KEY_CUT: obs_key = 349;
pub const obs_key_OBS_KEY_DISPLAY: obs_key = 350;
pub const obs_key_OBS_KEY_DOS: obs_key = 351;
pub const obs_key_OBS_KEY_DOCUMENTS: obs_key = 352;
pub const obs_key_OBS_KEY_EXCEL: obs_key = 353;
pub const obs_key_OBS_KEY_EXPLORER: obs_key = 354;
pub const obs_key_OBS_KEY_GAME: obs_key = 355;
pub const obs_key_OBS_KEY_GO: obs_key = 356;
pub const obs_key_OBS_KEY_ITOUCH: obs_key = 357;
pub const obs_key_OBS_KEY_LOGOFF: obs_key = 358;
pub const obs_key_OBS_KEY_MARKET: obs_key = 359;
pub const obs_key_OBS_KEY_MEETING: obs_key = 360;
pub const obs_key_OBS_KEY_MENUKB: obs_key = 361;
pub const obs_key_OBS_KEY_MENUPB: obs_key = 362;
pub const obs_key_OBS_KEY_MYSITES: obs_key = 363;
pub const obs_key_OBS_KEY_NEWS: obs_key = 364;
pub const obs_key_OBS_KEY_OFFICEHOME: obs_key = 365;
pub const obs_key_OBS_KEY_OPTION: obs_key = 366;
pub const obs_key_OBS_KEY_PASTE: obs_key = 367;
pub const obs_key_OBS_KEY_PHONE: obs_key = 368;
pub const obs_key_OBS_KEY_CALENDAR: obs_key = 369;
pub const obs_key_OBS_KEY_REPLY: obs_key = 370;
pub const obs_key_OBS_KEY_RELOAD: obs_key = 371;
pub const obs_key_OBS_KEY_ROTATEWINDOWS: obs_key = 372;
pub const obs_key_OBS_KEY_ROTATIONPB: obs_key = 373;
pub const obs_key_OBS_KEY_ROTATIONKB: obs_key = 374;
pub const obs_key_OBS_KEY_SAVE: obs_key = 375;
pub const obs_key_OBS_KEY_SEND: obs_key = 376;
pub const obs_key_OBS_KEY_SPELL: obs_key = 377;
pub const obs_key_OBS_KEY_SPLITSCREEN: obs_key = 378;
pub const obs_key_OBS_KEY_SUPPORT: obs_key = 379;
pub const obs_key_OBS_KEY_TASKPANE: obs_key = 380;
pub const obs_key_OBS_KEY_TERMINAL: obs_key = 381;
pub const obs_key_OBS_KEY_TOOLS: obs_key = 382;
pub const obs_key_OBS_KEY_TRAVEL: obs_key = 383;
pub const obs_key_OBS_KEY_VIDEO: obs_key = 384;
pub const obs_key_OBS_KEY_WORD: obs_key = 385;
pub const obs_key_OBS_KEY_XFER: obs_key = 386;
pub const obs_key_OBS_KEY_ZOOMIN: obs_key = 387;
pub const obs_key_OBS_KEY_ZOOMOUT: obs_key = 388;
pub const obs_key_OBS_KEY_AWAY: obs_key = 389;
pub const obs_key_OBS_KEY_MESSENGER: obs_key = 390;
pub const obs_key_OBS_KEY_WEBCAM: obs_key = 391;
pub const obs_key_OBS_KEY_MAILFORWARD: obs_key = 392;
pub const obs_key_OBS_KEY_PICTURES: obs_key = 393;
pub const obs_key_OBS_KEY_MUSIC: obs_key = 394;
pub const obs_key_OBS_KEY_BATTERY: obs_key = 395;
pub const obs_key_OBS_KEY_BLUETOOTH: obs_key = 396;
pub const obs_key_OBS_KEY_WLAN: obs_key = 397;
pub const obs_key_OBS_KEY_UWB: obs_key = 398;
pub const obs_key_OBS_KEY_AUDIOFORWARD: obs_key = 399;
pub const obs_key_OBS_KEY_AUDIOREPEAT: obs_key = 400;
pub const obs_key_OBS_KEY_AUDIORANDOMPLAY: obs_key = 401;
pub const obs_key_OBS_KEY_SUBTITLE: obs_key = 402;
pub const obs_key_OBS_KEY_AUDIOCYCLETRACK: obs_key = 403;
pub const obs_key_OBS_KEY_TIME: obs_key = 404;
pub const obs_key_OBS_KEY_HIBERNATE: obs_key = 405;
pub const obs_key_OBS_KEY_VIEW: obs_key = 406;
pub const obs_key_OBS_KEY_TOPMENU: obs_key = 407;
pub const obs_key_OBS_KEY_POWERDOWN: obs_key = 408;
pub const obs_key_OBS_KEY_SUSPEND: obs_key = 409;
pub const obs_key_OBS_KEY_CONTRASTADJUST: obs_key = 410;
pub const obs_key_OBS_KEY_MEDIALAST: obs_key = 411;
pub const obs_key_OBS_KEY_CALL: obs_key = 412;
pub const obs_key_OBS_KEY_CAMERA: obs_key = 413;
pub const obs_key_OBS_KEY_CAMERAFOCUS: obs_key = 414;
pub const obs_key_OBS_KEY_CONTEXT1: obs_key = 415;
pub const obs_key_OBS_KEY_CONTEXT2: obs_key = 416;
pub const obs_key_OBS_KEY_CONTEXT3: obs_key = 417;
pub const obs_key_OBS_KEY_CONTEXT4: obs_key = 418;
pub const obs_key_OBS_KEY_FLIP: obs_key = 419;
pub const obs_key_OBS_KEY_HANGUP: obs_key = 420;
pub const obs_key_OBS_KEY_NO: obs_key = 421;
pub const obs_key_OBS_KEY_SELECT: obs_key = 422;
pub const obs_key_OBS_KEY_YES: obs_key = 423;
pub const obs_key_OBS_KEY_TOGGLECALLHANGUP: obs_key = 424;
pub const obs_key_OBS_KEY_VOICEDIAL: obs_key = 425;
pub const obs_key_OBS_KEY_LASTNUMBERREDIAL: obs_key = 426;
pub const obs_key_OBS_KEY_EXECUTE: obs_key = 427;
pub const obs_key_OBS_KEY_PRINTER: obs_key = 428;
pub const obs_key_OBS_KEY_PLAY: obs_key = 429;
pub const obs_key_OBS_KEY_SLEEP: obs_key = 430;
pub const obs_key_OBS_KEY_ZOOM: obs_key = 431;
pub const obs_key_OBS_KEY_CANCEL: obs_key = 432;
pub const obs_key_OBS_KEY_MOUSE1: obs_key = 433;
pub const obs_key_OBS_KEY_MOUSE2: obs_key = 434;
pub const obs_key_OBS_KEY_MOUSE3: obs_key = 435;
pub const obs_key_OBS_KEY_MOUSE4: obs_key = 436;
pub const obs_key_OBS_KEY_MOUSE5: obs_key = 437;
pub const obs_key_OBS_KEY_MOUSE6: obs_key = 438;
pub const obs_key_OBS_KEY_MOUSE7: obs_key = 439;
pub const obs_key_OBS_KEY_MOUSE8: obs_key = 440;
pub const obs_key_OBS_KEY_MOUSE9: obs_key = 441;
pub const obs_key_OBS_KEY_MOUSE10: obs_key = 442;
pub const obs_key_OBS_KEY_MOUSE11: obs_key = 443;
pub const obs_key_OBS_KEY_MOUSE12: obs_key = 444;
pub const obs_key_OBS_KEY_MOUSE13: obs_key = 445;
pub const obs_key_OBS_KEY_MOUSE14: obs_key = 446;
pub const obs_key_OBS_KEY_MOUSE15: obs_key = 447;
pub const obs_key_OBS_KEY_MOUSE16: obs_key = 448;
pub const obs_key_OBS_KEY_MOUSE17: obs_key = 449;
pub const obs_key_OBS_KEY_MOUSE18: obs_key = 450;
pub const obs_key_OBS_KEY_MOUSE19: obs_key = 451;
pub const obs_key_OBS_KEY_MOUSE20: obs_key = 452;
pub const obs_key_OBS_KEY_MOUSE21: obs_key = 453;
pub const obs_key_OBS_KEY_MOUSE22: obs_key = 454;
pub const obs_key_OBS_KEY_MOUSE23: obs_key = 455;
pub const obs_key_OBS_KEY_MOUSE24: obs_key = 456;
pub const obs_key_OBS_KEY_MOUSE25: obs_key = 457;
pub const obs_key_OBS_KEY_MOUSE26: obs_key = 458;
pub const obs_key_OBS_KEY_MOUSE27: obs_key = 459;
pub const obs_key_OBS_KEY_MOUSE28: obs_key = 460;
pub const obs_key_OBS_KEY_MOUSE29: obs_key = 461;
pub const obs_key_OBS_KEY_BACKSLASH_RT102: obs_key = 462;
pub const obs_key_OBS_KEY_OPEN: obs_key = 463;
pub const obs_key_OBS_KEY_FIND: obs_key = 464;
pub const obs_key_OBS_KEY_REDO: obs_key = 465;
pub const obs_key_OBS_KEY_UNDO: obs_key = 466;
pub const obs_key_OBS_KEY_FRONT: obs_key = 467;
pub const obs_key_OBS_KEY_PROPS: obs_key = 468;
pub const obs_key_OBS_KEY_VK_CANCEL: obs_key = 469;
pub const obs_key_OBS_KEY_0x07: obs_key = 470;
pub const obs_key_OBS_KEY_0x0A: obs_key = 471;
pub const obs_key_OBS_KEY_0x0B: obs_key = 472;
pub const obs_key_OBS_KEY_0x0E: obs_key = 473;
pub const obs_key_OBS_KEY_0x0F: obs_key = 474;
pub const obs_key_OBS_KEY_0x16: obs_key = 475;
pub const obs_key_OBS_KEY_VK_JUNJA: obs_key = 476;
pub const obs_key_OBS_KEY_VK_FINAL: obs_key = 477;
pub const obs_key_OBS_KEY_0x1A: obs_key = 478;
pub const obs_key_OBS_KEY_VK_ACCEPT: obs_key = 479;
pub const obs_key_OBS_KEY_VK_MODECHANGE: obs_key = 480;
pub const obs_key_OBS_KEY_VK_SELECT: obs_key = 481;
pub const obs_key_OBS_KEY_VK_PRINT: obs_key = 482;
pub const obs_key_OBS_KEY_VK_EXECUTE: obs_key = 483;
pub const obs_key_OBS_KEY_VK_HELP: obs_key = 484;
pub const obs_key_OBS_KEY_0x30: obs_key = 485;
pub const obs_key_OBS_KEY_0x31: obs_key = 486;
pub const obs_key_OBS_KEY_0x32: obs_key = 487;
pub const obs_key_OBS_KEY_0x33: obs_key = 488;
pub const obs_key_OBS_KEY_0x34: obs_key = 489;
pub const obs_key_OBS_KEY_0x35: obs_key = 490;
pub const obs_key_OBS_KEY_0x36: obs_key = 491;
pub const obs_key_OBS_KEY_0x37: obs_key = 492;
pub const obs_key_OBS_KEY_0x38: obs_key = 493;
pub const obs_key_OBS_KEY_0x39: obs_key = 494;
pub const obs_key_OBS_KEY_0x3A: obs_key = 495;
pub const obs_key_OBS_KEY_0x3B: obs_key = 496;
pub const obs_key_OBS_KEY_0x3C: obs_key = 497;
pub const obs_key_OBS_KEY_0x3D: obs_key = 498;
pub const obs_key_OBS_KEY_0x3E: obs_key = 499;
pub const obs_key_OBS_KEY_0x3F: obs_key = 500;
pub const obs_key_OBS_KEY_0x40: obs_key = 501;
pub const obs_key_OBS_KEY_0x41: obs_key = 502;
pub const obs_key_OBS_KEY_0x42: obs_key = 503;
pub const obs_key_OBS_KEY_0x43: obs_key = 504;
pub const obs_key_OBS_KEY_0x44: obs_key = 505;
pub const obs_key_OBS_KEY_0x45: obs_key = 506;
pub const obs_key_OBS_KEY_0x46: obs_key = 507;
pub const obs_key_OBS_KEY_0x47: obs_key = 508;
pub const obs_key_OBS_KEY_0x48: obs_key = 509;
pub const obs_key_OBS_KEY_0x49: obs_key = 510;
pub const obs_key_OBS_KEY_0x4A: obs_key = 511;
pub const obs_key_OBS_KEY_0x4B: obs_key = 512;
pub const obs_key_OBS_KEY_0x4C: obs_key = 513;
pub const obs_key_OBS_KEY_0x4D: obs_key = 514;
pub const obs_key_OBS_KEY_0x4E: obs_key = 515;
pub const obs_key_OBS_KEY_0x4F: obs_key = 516;
pub const obs_key_OBS_KEY_0x50: obs_key = 517;
pub const obs_key_OBS_KEY_0x51: obs_key = 518;
pub const obs_key_OBS_KEY_0x52: obs_key = 519;
pub const obs_key_OBS_KEY_0x53: obs_key = 520;
pub const obs_key_OBS_KEY_0x54: obs_key = 521;
pub const obs_key_OBS_KEY_0x55: obs_key = 522;
pub const obs_key_OBS_KEY_0x56: obs_key = 523;
pub const obs_key_OBS_KEY_0x57: obs_key = 524;
pub const obs_key_OBS_KEY_0x58: obs_key = 525;
pub const obs_key_OBS_KEY_0x59: obs_key = 526;
pub const obs_key_OBS_KEY_0x5A: obs_key = 527;
pub const obs_key_OBS_KEY_VK_LWIN: obs_key = 528;
pub const obs_key_OBS_KEY_VK_RWIN: obs_key = 529;
pub const obs_key_OBS_KEY_VK_APPS: obs_key = 530;
pub const obs_key_OBS_KEY_0x5E: obs_key = 531;
pub const obs_key_OBS_KEY_VK_SLEEP: obs_key = 532;
pub const obs_key_OBS_KEY_VK_SEPARATOR: obs_key = 533;
pub const obs_key_OBS_KEY_0x88: obs_key = 534;
pub const obs_key_OBS_KEY_0x89: obs_key = 535;
pub const obs_key_OBS_KEY_0x8A: obs_key = 536;
pub const obs_key_OBS_KEY_0x8B: obs_key = 537;
pub const obs_key_OBS_KEY_0x8C: obs_key = 538;
pub const obs_key_OBS_KEY_0x8D: obs_key = 539;
pub const obs_key_OBS_KEY_0x8E: obs_key = 540;
pub const obs_key_OBS_KEY_0x8F: obs_key = 541;
pub const obs_key_OBS_KEY_VK_OEM_FJ_JISHO: obs_key = 542;
pub const obs_key_OBS_KEY_VK_OEM_FJ_LOYA: obs_key = 543;
pub const obs_key_OBS_KEY_VK_OEM_FJ_ROYA: obs_key = 544;
pub const obs_key_OBS_KEY_0x97: obs_key = 545;
pub const obs_key_OBS_KEY_0x98: obs_key = 546;
pub const obs_key_OBS_KEY_0x99: obs_key = 547;
pub const obs_key_OBS_KEY_0x9A: obs_key = 548;
pub const obs_key_OBS_KEY_0x9B: obs_key = 549;
pub const obs_key_OBS_KEY_0x9C: obs_key = 550;
pub const obs_key_OBS_KEY_0x9D: obs_key = 551;
pub const obs_key_OBS_KEY_0x9E: obs_key = 552;
pub const obs_key_OBS_KEY_0x9F: obs_key = 553;
pub const obs_key_OBS_KEY_VK_LSHIFT: obs_key = 554;
pub const obs_key_OBS_KEY_VK_RSHIFT: obs_key = 555;
pub const obs_key_OBS_KEY_VK_LCONTROL: obs_key = 556;
pub const obs_key_OBS_KEY_VK_RCONTROL: obs_key = 557;
pub const obs_key_OBS_KEY_VK_LMENU: obs_key = 558;
pub const obs_key_OBS_KEY_VK_RMENU: obs_key = 559;
pub const obs_key_OBS_KEY_VK_BROWSER_BACK: obs_key = 560;
pub const obs_key_OBS_KEY_VK_BROWSER_FORWARD: obs_key = 561;
pub const obs_key_OBS_KEY_VK_BROWSER_REFRESH: obs_key = 562;
pub const obs_key_OBS_KEY_VK_BROWSER_STOP: obs_key = 563;
pub const obs_key_OBS_KEY_VK_BROWSER_SEARCH: obs_key = 564;
pub const obs_key_OBS_KEY_VK_BROWSER_FAVORITES: obs_key = 565;
pub const obs_key_OBS_KEY_VK_BROWSER_HOME: obs_key = 566;
pub const obs_key_OBS_KEY_VK_VOLUME_MUTE: obs_key = 567;
pub const obs_key_OBS_KEY_VK_VOLUME_DOWN: obs_key = 568;
pub const obs_key_OBS_KEY_VK_VOLUME_UP: obs_key = 569;
pub const obs_key_OBS_KEY_VK_MEDIA_NEXT_TRACK: obs_key = 570;
pub const obs_key_OBS_KEY_VK_MEDIA_PREV_TRACK: obs_key = 571;
pub const obs_key_OBS_KEY_VK_MEDIA_STOP: obs_key = 572;
pub const obs_key_OBS_KEY_VK_MEDIA_PLAY_PAUSE: obs_key = 573;
pub const obs_key_OBS_KEY_VK_LAUNCH_MAIL: obs_key = 574;
pub const obs_key_OBS_KEY_VK_LAUNCH_MEDIA_SELECT: obs_key = 575;
pub const obs_key_OBS_KEY_VK_LAUNCH_APP1: obs_key = 576;
pub const obs_key_OBS_KEY_VK_LAUNCH_APP2: obs_key = 577;
pub const obs_key_OBS_KEY_0xB8: obs_key = 578;
pub const obs_key_OBS_KEY_0xB9: obs_key = 579;
pub const obs_key_OBS_KEY_0xC1: obs_key = 580;
pub const obs_key_OBS_KEY_0xC2: obs_key = 581;
pub const obs_key_OBS_KEY_0xC3: obs_key = 582;
pub const obs_key_OBS_KEY_0xC4: obs_key = 583;
pub const obs_key_OBS_KEY_0xC5: obs_key = 584;
pub const obs_key_OBS_KEY_0xC6: obs_key = 585;
pub const obs_key_OBS_KEY_0xC7: obs_key = 586;
pub const obs_key_OBS_KEY_0xC8: obs_key = 587;
pub const obs_key_OBS_KEY_0xC9: obs_key = 588;
pub const obs_key_OBS_KEY_0xCA: obs_key = 589;
pub const obs_key_OBS_KEY_0xCB: obs_key = 590;
pub const obs_key_OBS_KEY_0xCC: obs_key = 591;
pub const obs_key_OBS_KEY_0xCD: obs_key = 592;
pub const obs_key_OBS_KEY_0xCE: obs_key = 593;
pub const obs_key_OBS_KEY_0xCF: obs_key = 594;
pub const obs_key_OBS_KEY_0xD0: obs_key = 595;
pub const obs_key_OBS_KEY_0xD1: obs_key = 596;
pub const obs_key_OBS_KEY_0xD2: obs_key = 597;
pub const obs_key_OBS_KEY_0xD3: obs_key = 598;
pub const obs_key_OBS_KEY_0xD4: obs_key = 599;
pub const obs_key_OBS_KEY_0xD5: obs_key = 600;
pub const obs_key_OBS_KEY_0xD6: obs_key = 601;
pub const obs_key_OBS_KEY_0xD7: obs_key = 602;
pub const obs_key_OBS_KEY_0xD8: obs_key = 603;
pub const obs_key_OBS_KEY_0xD9: obs_key = 604;
pub const obs_key_OBS_KEY_0xDA: obs_key = 605;
pub const obs_key_OBS_KEY_VK_OEM_8: obs_key = 606;
pub const obs_key_OBS_KEY_0xE0: obs_key = 607;
pub const obs_key_OBS_KEY_VK_OEM_AX: obs_key = 608;
pub const obs_key_OBS_KEY_VK_ICO_HELP: obs_key = 609;
pub const obs_key_OBS_KEY_VK_ICO_00: obs_key = 610;
pub const obs_key_OBS_KEY_VK_PROCESSKEY: obs_key = 611;
pub const obs_key_OBS_KEY_VK_ICO_CLEAR: obs_key = 612;
pub const obs_key_OBS_KEY_VK_PACKET: obs_key = 613;
pub const obs_key_OBS_KEY_0xE8: obs_key = 614;
pub const obs_key_OBS_KEY_VK_OEM_RESET: obs_key = 615;
pub const obs_key_OBS_KEY_VK_OEM_JUMP: obs_key = 616;
pub const obs_key_OBS_KEY_VK_OEM_PA1: obs_key = 617;
pub const obs_key_OBS_KEY_VK_OEM_PA2: obs_key = 618;
pub const obs_key_OBS_KEY_VK_OEM_PA3: obs_key = 619;
pub const obs_key_OBS_KEY_VK_OEM_WSCTRL: obs_key = 620;
pub const obs_key_OBS_KEY_VK_OEM_CUSEL: obs_key = 621;
pub const obs_key_OBS_KEY_VK_OEM_ATTN: obs_key = 622;
pub const obs_key_OBS_KEY_VK_OEM_FINISH: obs_key = 623;
pub const obs_key_OBS_KEY_VK_OEM_COPY: obs_key = 624;
pub const obs_key_OBS_KEY_VK_OEM_AUTO: obs_key = 625;
pub const obs_key_OBS_KEY_VK_OEM_ENLW: obs_key = 626;
pub const obs_key_OBS_KEY_VK_ATTN: obs_key = 627;
pub const obs_key_OBS_KEY_VK_CRSEL: obs_key = 628;
pub const obs_key_OBS_KEY_VK_EXSEL: obs_key = 629;
pub const obs_key_OBS_KEY_VK_EREOF: obs_key = 630;
pub const obs_key_OBS_KEY_VK_PLAY: obs_key = 631;
pub const obs_key_OBS_KEY_VK_ZOOM: obs_key = 632;
pub const obs_key_OBS_KEY_VK_NONAME: obs_key = 633;
pub const obs_key_OBS_KEY_VK_PA1: obs_key = 634;
pub const obs_key_OBS_KEY_VK_OEM_CLEAR: obs_key = 635;
pub const obs_key_OBS_KEY_LAST_VALUE: obs_key = 636;
pub type obs_key = ::std::os::raw::c_uint;
pub use self::obs_key as obs_key_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_key_combination {
    pub modifiers: u32,
    pub key: obs_key_t,
}
#[test]
fn bindgen_test_layout_obs_key_combination() {
    const UNINIT: ::std::mem::MaybeUninit<obs_key_combination> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_key_combination>(),
        8usize,
        concat!("Size of: ", stringify!(obs_key_combination))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_key_combination>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_key_combination))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_combination),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_combination),
            "::",
            stringify!(key)
        )
    );
}
impl Default for obs_key_combination {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type obs_key_combination_t = obs_key_combination;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_hotkey {
    _unused: [u8; 0],
}
pub type obs_hotkey_t = obs_hotkey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_hotkey_binding {
    _unused: [u8; 0],
}
pub type obs_hotkey_binding_t = obs_hotkey_binding;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_FRONTEND: obs_hotkey_registerer_type = 0;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_SOURCE: obs_hotkey_registerer_type = 1;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_OUTPUT: obs_hotkey_registerer_type = 2;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_ENCODER: obs_hotkey_registerer_type = 3;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_SERVICE: obs_hotkey_registerer_type = 4;
pub type obs_hotkey_registerer_type = ::std::os::raw::c_uint;
pub use self::obs_hotkey_registerer_type as obs_hotkey_registerer_t;
extern "C" {
    pub fn obs_hotkey_get_id(key: *const obs_hotkey_t) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_get_name(key: *const obs_hotkey_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_hotkey_get_description(key: *const obs_hotkey_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_hotkey_get_registerer_type(key: *const obs_hotkey_t) -> obs_hotkey_registerer_t;
}
extern "C" {
    pub fn obs_hotkey_get_registerer(key: *const obs_hotkey_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_hotkey_get_pair_partner_id(key: *const obs_hotkey_t) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_binding_get_key_combination(
        binding: *mut obs_hotkey_binding_t,
    ) -> obs_key_combination_t;
}
extern "C" {
    pub fn obs_hotkey_binding_get_hotkey_id(binding: *mut obs_hotkey_binding_t) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_binding_get_hotkey(binding: *mut obs_hotkey_binding_t) -> *mut obs_hotkey_t;
}
extern "C" {
    pub fn obs_hotkey_set_name(id: obs_hotkey_id, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_hotkey_set_description(id: obs_hotkey_id, desc: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_hotkey_pair_set_names(
        id: obs_hotkey_pair_id,
        name0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_hotkey_pair_set_descriptions(
        id: obs_hotkey_pair_id,
        desc0: *const ::std::os::raw::c_char,
        desc1: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_hotkeys_translations {
    pub insert: *const ::std::os::raw::c_char,
    pub del: *const ::std::os::raw::c_char,
    pub home: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub page_up: *const ::std::os::raw::c_char,
    pub page_down: *const ::std::os::raw::c_char,
    pub num_lock: *const ::std::os::raw::c_char,
    pub scroll_lock: *const ::std::os::raw::c_char,
    pub caps_lock: *const ::std::os::raw::c_char,
    pub backspace: *const ::std::os::raw::c_char,
    pub tab: *const ::std::os::raw::c_char,
    pub print: *const ::std::os::raw::c_char,
    pub pause: *const ::std::os::raw::c_char,
    pub left: *const ::std::os::raw::c_char,
    pub right: *const ::std::os::raw::c_char,
    pub up: *const ::std::os::raw::c_char,
    pub down: *const ::std::os::raw::c_char,
    pub shift: *const ::std::os::raw::c_char,
    pub alt: *const ::std::os::raw::c_char,
    pub control: *const ::std::os::raw::c_char,
    pub meta: *const ::std::os::raw::c_char,
    pub menu: *const ::std::os::raw::c_char,
    pub space: *const ::std::os::raw::c_char,
    pub numpad_num: *const ::std::os::raw::c_char,
    pub numpad_divide: *const ::std::os::raw::c_char,
    pub numpad_multiply: *const ::std::os::raw::c_char,
    pub numpad_minus: *const ::std::os::raw::c_char,
    pub numpad_plus: *const ::std::os::raw::c_char,
    pub numpad_decimal: *const ::std::os::raw::c_char,
    pub apple_keypad_num: *const ::std::os::raw::c_char,
    pub apple_keypad_divide: *const ::std::os::raw::c_char,
    pub apple_keypad_multiply: *const ::std::os::raw::c_char,
    pub apple_keypad_minus: *const ::std::os::raw::c_char,
    pub apple_keypad_plus: *const ::std::os::raw::c_char,
    pub apple_keypad_decimal: *const ::std::os::raw::c_char,
    pub apple_keypad_equal: *const ::std::os::raw::c_char,
    pub mouse_num: *const ::std::os::raw::c_char,
    pub escape: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_hotkeys_translations() {
    const UNINIT: ::std::mem::MaybeUninit<obs_hotkeys_translations> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_hotkeys_translations>(),
        304usize,
        concat!("Size of: ", stringify!(obs_hotkeys_translations))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_hotkeys_translations>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_hotkeys_translations))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).insert) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(insert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).del) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(del)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).home) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(home)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_up) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(page_up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_down) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(page_down)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_lock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(num_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scroll_lock) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(scroll_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caps_lock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(caps_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backspace) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(backspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tab) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).print) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pause) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(pause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).up) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).down) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(down)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).menu) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(menu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).space) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numpad_num) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numpad_divide) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_divide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numpad_multiply) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_multiply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numpad_minus) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_minus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numpad_plus) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_plus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numpad_decimal) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_decimal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apple_keypad_num) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apple_keypad_divide) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_divide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apple_keypad_multiply) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_multiply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apple_keypad_minus) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_minus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apple_keypad_plus) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_plus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apple_keypad_decimal) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_decimal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apple_keypad_equal) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouse_num) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(mouse_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).escape) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(escape)
        )
    );
}
impl Default for obs_hotkeys_translations {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn obs_hotkeys_set_translations_s(translations: *mut obs_hotkeys_translations, size: usize);
}
extern "C" {
    pub fn obs_hotkeys_set_audio_hotkeys_translations(
        mute: *const ::std::os::raw::c_char,
        unmute: *const ::std::os::raw::c_char,
        push_to_mute: *const ::std::os::raw::c_char,
        push_to_talk: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_hotkeys_set_sceneitem_hotkeys_translations(
        show: *const ::std::os::raw::c_char,
        hide: *const ::std::os::raw::c_char,
    );
}
pub type obs_hotkey_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id: obs_hotkey_id,
        hotkey: *mut obs_hotkey_t,
        pressed: bool,
    ),
>;
extern "C" {
    pub fn obs_hotkey_register_frontend(
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_register_encoder(
        encoder: *mut obs_encoder_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_register_output(
        output: *mut obs_output_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_register_service(
        service: *mut obs_service_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_register_source(
        source: *mut obs_source_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
pub type obs_hotkey_active_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id: obs_hotkey_pair_id,
        hotkey: *mut obs_hotkey_t,
        pressed: bool,
    ) -> bool,
>;
extern "C" {
    pub fn obs_hotkey_pair_register_frontend(
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_pair_register_encoder(
        encoder: *mut obs_encoder_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_pair_register_output(
        output: *mut obs_output_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_pair_register_service(
        service: *mut obs_service_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_pair_register_source(
        source: *mut obs_source_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_unregister(id: obs_hotkey_id);
}
extern "C" {
    pub fn obs_hotkey_pair_unregister(id: obs_hotkey_pair_id);
}
extern "C" {
    pub fn obs_hotkey_load_bindings(
        id: obs_hotkey_id,
        combinations: *mut obs_key_combination_t,
        num: usize,
    );
}
extern "C" {
    pub fn obs_hotkey_load(id: obs_hotkey_id, data: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_hotkeys_load_encoder(encoder: *mut obs_encoder_t, hotkeys: *mut obs_data_t);
}
extern "C" {
    pub fn obs_hotkeys_load_output(output: *mut obs_output_t, hotkeys: *mut obs_data_t);
}
extern "C" {
    pub fn obs_hotkeys_load_service(service: *mut obs_service_t, hotkeys: *mut obs_data_t);
}
extern "C" {
    pub fn obs_hotkeys_load_source(source: *mut obs_source_t, hotkeys: *mut obs_data_t);
}
extern "C" {
    pub fn obs_hotkey_pair_load(
        id: obs_hotkey_pair_id,
        data0: *mut obs_data_array_t,
        data1: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_hotkey_save(id: obs_hotkey_id) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_hotkey_pair_save(
        id: obs_hotkey_pair_id,
        p_data0: *mut *mut obs_data_array_t,
        p_data1: *mut *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_hotkeys_save_encoder(encoder: *mut obs_encoder_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_hotkeys_save_output(output: *mut obs_output_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_hotkeys_save_service(service: *mut obs_service_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_hotkeys_save_source(source: *mut obs_source_t) -> *mut obs_data_t;
}
pub type obs_hotkey_enum_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id: obs_hotkey_id,
        key: *mut obs_hotkey_t,
    ) -> bool,
>;
extern "C" {
    pub fn obs_enum_hotkeys(func: obs_hotkey_enum_func, data: *mut ::std::os::raw::c_void);
}
pub type obs_hotkey_binding_enum_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        idx: usize,
        binding: *mut obs_hotkey_binding_t,
    ) -> bool,
>;
extern "C" {
    pub fn obs_enum_hotkey_bindings(
        func: obs_hotkey_binding_enum_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_hotkey_inject_event(hotkey: obs_key_combination_t, pressed: bool);
}
extern "C" {
    pub fn obs_hotkey_enable_background_press(enable: bool);
}
extern "C" {
    pub fn obs_hotkey_enable_strict_modifiers(enable: bool);
}
pub type obs_hotkey_callback_router_func = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: obs_hotkey_id, pressed: bool),
>;
extern "C" {
    pub fn obs_hotkey_set_callback_routing_func(
        func: obs_hotkey_callback_router_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_hotkey_trigger_routed_callback(id: obs_hotkey_id, pressed: bool);
}
extern "C" {
    pub fn obs_hotkey_enable_callback_rerouting(enable: bool);
}
pub type obs_hotkey_atomic_update_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn obs_hotkey_update_atomic(
        func: obs_hotkey_atomic_update_func,
        data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dstr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obs_key_to_str(key: obs_key_t, str_: *mut dstr);
}
extern "C" {
    pub fn obs_key_combination_to_str(key: obs_key_combination_t, str_: *mut dstr);
}
extern "C" {
    pub fn obs_key_from_virtual_key(code: ::std::os::raw::c_int) -> obs_key_t;
}
extern "C" {
    pub fn obs_key_to_virtual_key(key: obs_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_key_to_name(key: obs_key_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_key_from_name(name: *const ::std::os::raw::c_char) -> obs_key_t;
}
pub const obs_order_movement_OBS_ORDER_MOVE_UP: obs_order_movement = 0;
pub const obs_order_movement_OBS_ORDER_MOVE_DOWN: obs_order_movement = 1;
pub const obs_order_movement_OBS_ORDER_MOVE_TOP: obs_order_movement = 2;
pub const obs_order_movement_OBS_ORDER_MOVE_BOTTOM: obs_order_movement = 3;
#[doc = " Used for changing the order of items (for example, filters in a source,\n or items in a scene)"]
pub type obs_order_movement = ::std::os::raw::c_uint;
pub const obs_allow_direct_render_OBS_NO_DIRECT_RENDERING: obs_allow_direct_render = 0;
pub const obs_allow_direct_render_OBS_ALLOW_DIRECT_RENDERING: obs_allow_direct_render = 1;
#[doc = " Used with obs_source_process_filter to specify whether the filter should\n render the source directly with the specified effect, or whether it should\n render it to a texture"]
pub type obs_allow_direct_render = ::std::os::raw::c_uint;
pub const obs_scale_type_OBS_SCALE_DISABLE: obs_scale_type = 0;
pub const obs_scale_type_OBS_SCALE_POINT: obs_scale_type = 1;
pub const obs_scale_type_OBS_SCALE_BICUBIC: obs_scale_type = 2;
pub const obs_scale_type_OBS_SCALE_BILINEAR: obs_scale_type = 3;
pub const obs_scale_type_OBS_SCALE_LANCZOS: obs_scale_type = 4;
pub const obs_scale_type_OBS_SCALE_AREA: obs_scale_type = 5;
pub type obs_scale_type = ::std::os::raw::c_uint;
pub const obs_blending_method_OBS_BLEND_METHOD_DEFAULT: obs_blending_method = 0;
pub const obs_blending_method_OBS_BLEND_METHOD_SRGB_OFF: obs_blending_method = 1;
pub type obs_blending_method = ::std::os::raw::c_uint;
pub const obs_blending_type_OBS_BLEND_NORMAL: obs_blending_type = 0;
pub const obs_blending_type_OBS_BLEND_ADDITIVE: obs_blending_type = 1;
pub const obs_blending_type_OBS_BLEND_SUBTRACT: obs_blending_type = 2;
pub const obs_blending_type_OBS_BLEND_SCREEN: obs_blending_type = 3;
pub const obs_blending_type_OBS_BLEND_MULTIPLY: obs_blending_type = 4;
pub const obs_blending_type_OBS_BLEND_LIGHTEN: obs_blending_type = 5;
pub const obs_blending_type_OBS_BLEND_DARKEN: obs_blending_type = 6;
pub type obs_blending_type = ::std::os::raw::c_uint;
#[doc = "< no bounds"]
pub const obs_bounds_type_OBS_BOUNDS_NONE: obs_bounds_type = 0;
#[doc = "< stretch (ignores base scale)"]
pub const obs_bounds_type_OBS_BOUNDS_STRETCH: obs_bounds_type = 1;
#[doc = "< scales to inner rectangle"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_INNER: obs_bounds_type = 2;
#[doc = "< scales to outer rectangle"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_OUTER: obs_bounds_type = 3;
#[doc = "< scales to the width"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_TO_WIDTH: obs_bounds_type = 4;
#[doc = "< scales to the height"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_TO_HEIGHT: obs_bounds_type = 5;
#[doc = "< no scaling, maximum size only"]
pub const obs_bounds_type_OBS_BOUNDS_MAX_ONLY: obs_bounds_type = 6;
#[doc = " Used with scene items to indicate the type of bounds to use for scene items.\n Mostly determines how the image will be scaled within those bounds, or\n whether to use bounds at all."]
pub type obs_bounds_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obs_transform_info {
    pub pos: vec2,
    pub rot: f32,
    pub scale: vec2,
    pub alignment: u32,
    pub bounds_type: obs_bounds_type,
    pub bounds_alignment: u32,
    pub bounds: vec2,
}
#[test]
fn bindgen_test_layout_obs_transform_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_transform_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_transform_info>(),
        40usize,
        concat!("Size of: ", stringify!(obs_transform_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_transform_info>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_transform_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rot) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(rot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bounds_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(bounds_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bounds_alignment) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(bounds_alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bounds) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(bounds)
        )
    );
}
impl Default for obs_transform_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Video initialization structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_video_info {
    #[doc = " Graphics module to use (usually \"libobs-opengl\" or \"libobs-d3d11\")"]
    pub graphics_module: *const ::std::os::raw::c_char,
    #[doc = "< Output FPS numerator"]
    pub fps_num: u32,
    #[doc = "< Output FPS denominator"]
    pub fps_den: u32,
    #[doc = "< Base compositing width"]
    pub base_width: u32,
    #[doc = "< Base compositing height"]
    pub base_height: u32,
    #[doc = "< Output width"]
    pub output_width: u32,
    #[doc = "< Output height"]
    pub output_height: u32,
    #[doc = "< Output format"]
    pub output_format: video_format,
    #[doc = " Video adapter index to use (NOTE: avoid for optimus laptops)"]
    pub adapter: u32,
    #[doc = " Use shaders to convert to different color formats"]
    pub gpu_conversion: bool,
    #[doc = "< YUV type (if YUV)"]
    pub colorspace: video_colorspace,
    #[doc = "< YUV range (if YUV)"]
    pub range: video_range_type,
    #[doc = "< How to scale if scaling"]
    pub scale_type: obs_scale_type,
}
#[test]
fn bindgen_test_layout_obs_video_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_video_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_video_info>(),
        56usize,
        concat!("Size of: ", stringify!(obs_video_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_video_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_video_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphics_module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(graphics_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(fps_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_den) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(fps_den)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(base_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(base_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(output_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_height) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(output_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_format) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(output_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapter) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(adapter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_conversion) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(gpu_conversion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_type) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(scale_type)
        )
    );
}
impl Default for obs_video_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Audio initialization structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_audio_info {
    pub samples_per_sec: u32,
    pub speakers: speaker_layout,
}
#[test]
fn bindgen_test_layout_obs_audio_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_audio_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_audio_info>(),
        8usize,
        concat!("Size of: ", stringify!(obs_audio_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_audio_info>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_audio_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_per_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_info),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_info),
            "::",
            stringify!(speakers)
        )
    );
}
impl Default for obs_audio_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_audio_info2 {
    pub samples_per_sec: u32,
    pub speakers: speaker_layout,
    pub max_buffering_ms: u32,
    pub fixed_buffering: bool,
}
#[test]
fn bindgen_test_layout_obs_audio_info2() {
    const UNINIT: ::std::mem::MaybeUninit<obs_audio_info2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_audio_info2>(),
        16usize,
        concat!("Size of: ", stringify!(obs_audio_info2))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_audio_info2>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_audio_info2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_per_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_info2),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_info2),
            "::",
            stringify!(speakers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_buffering_ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_info2),
            "::",
            stringify!(max_buffering_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed_buffering) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_info2),
            "::",
            stringify!(fixed_buffering)
        )
    );
}
impl Default for obs_audio_info2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Sent to source filters via the filter_audio callback to allow filtering of\n audio data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_audio_data {
    pub data: [*mut u8; 8usize],
    pub frames: u32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_obs_audio_data() {
    const UNINIT: ::std::mem::MaybeUninit<obs_audio_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_audio_data>(),
        80usize,
        concat!("Size of: ", stringify!(obs_audio_data))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_audio_data>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_audio_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_data),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_data),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for obs_audio_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Source audio output structure.  Used with obs_source_output_audio to output\n source audio.  Audio is automatically resampled and remixed as necessary."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_audio {
    pub data: [*const u8; 8usize],
    pub frames: u32,
    pub speakers: speaker_layout,
    pub format: audio_format,
    pub samples_per_sec: u32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_obs_source_audio() {
    const UNINIT: ::std::mem::MaybeUninit<obs_source_audio> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_source_audio>(),
        88usize,
        concat!("Size of: ", stringify!(obs_source_audio))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_audio>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_audio))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speakers) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(speakers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_per_sec) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for obs_source_audio {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_cea_708 {
    pub data: *const u8,
    pub packets: u32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_obs_source_cea_708() {
    const UNINIT: ::std::mem::MaybeUninit<obs_source_cea_708> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_source_cea_708>(),
        24usize,
        concat!("Size of: ", stringify!(obs_source_cea_708))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_cea_708>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_cea_708))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_cea_708),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_cea_708),
            "::",
            stringify!(packets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_cea_708),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for obs_source_cea_708 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Source asynchronous video output structure.  Used with\n obs_source_output_video to output asynchronous video.  Video is buffered as\n necessary to play according to timestamps.  When used with audio output,\n audio is synced to video as it is played.\n\n If a YUV format is specified, it will be automatically upsampled and\n converted to RGB via shader on the graphics processor.\n\n NOTE: Non-YUV formats will always be treated as full range with this\n structure!  Use obs_source_frame2 along with obs_source_output_video2\n instead if partial range support is desired for non-YUV video formats."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_frame {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub width: u32,
    pub height: u32,
    pub timestamp: u64,
    pub format: video_format,
    pub color_matrix: [f32; 16usize],
    pub full_range: bool,
    pub max_luminance: u16,
    pub color_range_min: [f32; 3usize],
    pub color_range_max: [f32; 3usize],
    pub flip: bool,
    pub flags: u8,
    pub trc: u8,
    pub refs: ::std::os::raw::c_long,
    pub prev_frame: bool,
}
#[test]
fn bindgen_test_layout_obs_source_frame() {
    const UNINIT: ::std::mem::MaybeUninit<obs_source_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_source_frame>(),
        232usize,
        concat!("Size of: ", stringify!(obs_source_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linesize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_matrix) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(color_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_range) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(full_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_luminance) as usize - ptr as usize },
        182usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(max_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range_min) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(color_range_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range_max) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(color_range_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flip) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(flip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        209usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trc) as usize - ptr as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(trc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev_frame) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(prev_frame)
        )
    );
}
impl Default for obs_source_frame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_frame2 {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub width: u32,
    pub height: u32,
    pub timestamp: u64,
    pub format: video_format,
    pub range: video_range_type,
    pub color_matrix: [f32; 16usize],
    pub color_range_min: [f32; 3usize],
    pub color_range_max: [f32; 3usize],
    pub flip: bool,
    pub flags: u8,
    pub trc: u8,
}
#[test]
fn bindgen_test_layout_obs_source_frame2() {
    const UNINIT: ::std::mem::MaybeUninit<obs_source_frame2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_source_frame2>(),
        216usize,
        concat!("Size of: ", stringify!(obs_source_frame2))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_frame2>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_frame2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linesize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_matrix) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(color_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range_min) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(color_range_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range_max) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(color_range_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flip) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(flip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        209usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trc) as usize - ptr as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(trc)
        )
    );
}
impl Default for obs_source_frame2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Access to the argc/argv used to start OBS. What you see is what you get."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_cmdline_args {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_cmdline_args() {
    const UNINIT: ::std::mem::MaybeUninit<obs_cmdline_args> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_cmdline_args>(),
        16usize,
        concat!("Size of: ", stringify!(obs_cmdline_args))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_cmdline_args>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_cmdline_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_cmdline_args),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_cmdline_args),
            "::",
            stringify!(argv)
        )
    );
}
impl Default for obs_cmdline_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Find a core libobs data file\n @param path name of the base file\n @return A string containing the full path to the file.\n          Use bfree after use."]
    pub fn obs_find_data_file(file: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add a path to search libobs data files in.\n @param path Full path to directory to look in.\n             The string is copied."]
    pub fn obs_add_data_path(path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Remove a path from libobs core data paths.\n @param path The path to compare to currently set paths.\n             It does not need to be the same pointer, but\n             the path string must match an entry fully.\n @return Whether or not the path was successfully removed.\n         If false, the path could not be found."]
    pub fn obs_remove_data_path(path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Initializes OBS\n\n @param  locale              The locale to use for modules\n @param  module_config_path  Path to module config storage directory\n                             (or NULL if none)\n @param  store               The profiler name store for OBS to use or NULL"]
    pub fn obs_startup(
        locale: *const ::std::os::raw::c_char,
        module_config_path: *const ::std::os::raw::c_char,
        store: *mut profiler_name_store_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Releases all data associated with OBS and terminates the OBS context"]
    pub fn obs_shutdown();
}
extern "C" {
    #[doc = " @return true if the main OBS context has been initialized"]
    pub fn obs_initialized() -> bool;
}
extern "C" {
    #[doc = " @return The current core version"]
    pub fn obs_get_version() -> u32;
}
extern "C" {
    #[doc = " @return The current core version string"]
    pub fn obs_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets things up for calls to obs_get_cmdline_args. Called only once at startup\n and safely copies argv/argc from main(). Subsequent calls do nothing.\n\n @param  argc  The count of command line arguments, from main()\n @param  argv  An array of command line arguments, copied from main() and ends\n               with NULL."]
    pub fn obs_set_cmdline_args(
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Get the argc/argv used to start OBS\n\n @return  The command line arguments used for main(). Don't modify this or\n          you'll mess things up for other callers."]
    pub fn obs_get_cmdline_args() -> obs_cmdline_args;
}
extern "C" {
    #[doc = " Sets a new locale to use for modules.  This will call obs_module_set_locale\n for each module with the new locale.\n\n @param  locale  The locale to use for modules"]
    pub fn obs_set_locale(locale: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @return the current locale"]
    pub fn obs_get_locale() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the profiler name store (see util/profiler.h) used by OBS, which is\n either a name store passed to obs_startup, an internal name store, or NULL\n in case obs_initialized() returns false."]
    pub fn obs_get_profiler_name_store() -> *mut profiler_name_store_t;
}
extern "C" {
    #[doc = " Sets base video output base resolution/fps/format.\n\n @note This data cannot be changed if an output is currently active.\n @note The graphics module cannot be changed without fully destroying the\n       OBS context.\n\n @param   ovi  Pointer to an obs_video_info structure containing the\n               specification of the graphics subsystem,\n @return       OBS_VIDEO_SUCCESS if successful\n               OBS_VIDEO_NOT_SUPPORTED if the adapter lacks capabilities\n               OBS_VIDEO_INVALID_PARAM if a parameter is invalid\n               OBS_VIDEO_CURRENTLY_ACTIVE if video is currently active\n               OBS_VIDEO_MODULE_NOT_FOUND if the graphics module is not found\n               OBS_VIDEO_FAIL for generic failure"]
    pub fn obs_reset_video(ovi: *mut obs_video_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets base audio output format/channels/samples/etc\n\n @note Cannot reset base audio if an output is currently active."]
    pub fn obs_reset_audio(oai: *const obs_audio_info) -> bool;
}
extern "C" {
    pub fn obs_reset_audio2(oai: *const obs_audio_info2) -> bool;
}
extern "C" {
    #[doc = " Gets the current video settings, returns false if no video"]
    pub fn obs_get_video_info(ovi: *mut obs_video_info) -> bool;
}
extern "C" {
    #[doc = " Gets the SDR white level, returns 300.f if no video"]
    pub fn obs_get_video_sdr_white_level() -> f32;
}
extern "C" {
    #[doc = " Gets the HDR nominal peak level, returns 1000.f if no video"]
    pub fn obs_get_video_hdr_nominal_peak_level() -> f32;
}
extern "C" {
    #[doc = " Sets the video levels"]
    pub fn obs_set_video_levels(sdr_white_level: f32, hdr_nominal_peak_level: f32);
}
extern "C" {
    #[doc = " Gets the current audio settings, returns false if no audio"]
    pub fn obs_get_audio_info(oai: *mut obs_audio_info) -> bool;
}
extern "C" {
    #[doc = " Opens a plugin module directly from a specific path.\n\n If the module already exists then the function will return successful, and\n the module parameter will be given the pointer to the existing module.\n\n This does not initialize the module, it only loads the module image.  To\n initialize the module, call obs_init_module.\n\n @param  module     The pointer to the created module.\n @param  path       Specifies the path to the module library file.  If the\n                    extension is not specified, it will use the extension\n                    appropriate to the operating system.\n @param  data_path  Specifies the path to the directory where the module's\n                    data files are stored.\n @returns           MODULE_SUCCESS if successful\n                    MODULE_ERROR if a generic error occurred\n                    MODULE_FILE_NOT_FOUND if the module was not found\n                    MODULE_MISSING_EXPORTS if required exports are missing\n                    MODULE_INCOMPATIBLE_VER if incompatible version"]
    pub fn obs_open_module(
        module: *mut *mut obs_module_t,
        path: *const ::std::os::raw::c_char,
        data_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes the module, which calls its obs_module_load export.  If the\n module is already loaded, then this function does nothing and returns\n successful."]
    pub fn obs_init_module(module: *mut obs_module_t) -> bool;
}
extern "C" {
    #[doc = " Returns a module based upon its name, or NULL if not found"]
    pub fn obs_get_module(name: *const ::std::os::raw::c_char) -> *mut obs_module_t;
}
extern "C" {
    #[doc = " Gets library of module"]
    pub fn obs_get_module_lib(module: *mut obs_module_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns locale text from a specific module"]
    pub fn obs_module_get_locale_string(
        mod_: *const obs_module_t,
        lookup_string: *const ::std::os::raw::c_char,
        translated_string: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_module_get_locale_text(
        mod_: *const obs_module_t,
        text: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Logs loaded modules"]
    pub fn obs_log_loaded_modules();
}
extern "C" {
    #[doc = " Returns the module file name"]
    pub fn obs_get_module_file_name(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module full name"]
    pub fn obs_get_module_name(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module author(s)"]
    pub fn obs_get_module_author(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module description"]
    pub fn obs_get_module_description(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module binary path"]
    pub fn obs_get_module_binary_path(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module data path"]
    pub fn obs_get_module_data_path(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Adds a module search path to be used with obs_find_modules.  If the search\n path strings contain %module%, that text will be replaced with the module\n name when used.\n\n @param  bin   Specifies the module's binary directory search path.\n @param  data  Specifies the module's data directory search path."]
    pub fn obs_add_module_path(
        bin: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Automatically loads all modules from module paths (convenience function)"]
    pub fn obs_load_all_modules();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_module_failure_info {
    pub failed_modules: *mut *mut ::std::os::raw::c_char,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_obs_module_failure_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_module_failure_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_module_failure_info>(),
        16usize,
        concat!("Size of: ", stringify!(obs_module_failure_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_module_failure_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_module_failure_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failed_modules) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_failure_info),
            "::",
            stringify!(failed_modules)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_failure_info),
            "::",
            stringify!(count)
        )
    );
}
impl Default for obs_module_failure_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn obs_module_failure_info_free(mfi: *mut obs_module_failure_info);
}
extern "C" {
    pub fn obs_load_all_modules2(mfi: *mut obs_module_failure_info);
}
extern "C" {
    #[doc = " Notifies modules that all modules have been loaded.  This function should\n be called after all modules have been loaded."]
    pub fn obs_post_load_modules();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_module_info {
    pub bin_path: *const ::std::os::raw::c_char,
    pub data_path: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_module_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_module_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_module_info>(),
        16usize,
        concat!("Size of: ", stringify!(obs_module_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_module_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_module_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bin_path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_info),
            "::",
            stringify!(bin_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_info),
            "::",
            stringify!(data_path)
        )
    );
}
impl Default for obs_module_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type obs_find_module_callback_t = ::std::option::Option<
    unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, info: *const obs_module_info),
>;
extern "C" {
    #[doc = " Finds all modules within the search paths added by obs_add_module_path."]
    pub fn obs_find_modules(
        callback: obs_find_module_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_module_info2 {
    pub bin_path: *const ::std::os::raw::c_char,
    pub data_path: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_module_info2() {
    const UNINIT: ::std::mem::MaybeUninit<obs_module_info2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_module_info2>(),
        24usize,
        concat!("Size of: ", stringify!(obs_module_info2))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_module_info2>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_module_info2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bin_path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_info2),
            "::",
            stringify!(bin_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_info2),
            "::",
            stringify!(data_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_info2),
            "::",
            stringify!(name)
        )
    );
}
impl Default for obs_module_info2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type obs_find_module_callback2_t = ::std::option::Option<
    unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, info: *const obs_module_info2),
>;
extern "C" {
    #[doc = " Finds all modules within the search paths added by obs_add_module_path."]
    pub fn obs_find_modules2(
        callback: obs_find_module_callback2_t,
        param: *mut ::std::os::raw::c_void,
    );
}
pub type obs_enum_module_callback_t = ::std::option::Option<
    unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, module: *mut obs_module_t),
>;
extern "C" {
    #[doc = " Enumerates all loaded modules"]
    pub fn obs_enum_modules(
        callback: obs_enum_module_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Helper function for using default module locale"]
    pub fn obs_module_load_locale(
        module: *mut obs_module_t,
        default_locale: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
    ) -> *mut lookup_t;
}
extern "C" {
    #[doc = " Returns the location of a plugin module data file.\n\n @note   Modules should use obs_module_file function defined in obs-module.h\n         as a more elegant means of getting their files without having to\n         specify the module parameter.\n\n @param  module  The module associated with the file to locate\n @param  file    The file to locate\n @return         Path string, or NULL if not found.  Use bfree to free string."]
    pub fn obs_find_module_file(
        module: *mut obs_module_t,
        file: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the path of a plugin module config file (whether it exists or not)\n\n @note   Modules should use obs_module_config_path function defined in\n         obs-module.h as a more elegant means of getting their files without\n         having to specify the module parameter.\n\n @param  module  The module associated with the path\n @param  file    The file to get a path to\n @return         Path string, or NULL if not found.  Use bfree to free string."]
    pub fn obs_module_get_config_path(
        module: *mut obs_module_t,
        file: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enumerates all source types (inputs, filters, transitions, etc)."]
    pub fn obs_enum_source_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available inputs source types.\n\n   Inputs are general source inputs (such as capture sources, device sources,\n etc)."]
    pub fn obs_enum_input_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_enum_input_types2(
        idx: usize,
        id: *mut *const ::std::os::raw::c_char,
        unversioned_id: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_get_latest_input_type_id(
        unversioned_id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enumerates all available filter source types.\n\n   Filters are sources that are used to modify the video/audio output of\n other sources."]
    pub fn obs_enum_filter_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available transition source types.\n\n   Transitions are sources used to transition between two or more other\n sources."]
    pub fn obs_enum_transition_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available output types."]
    pub fn obs_enum_output_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available encoder types."]
    pub fn obs_enum_encoder_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available service types."]
    pub fn obs_enum_service_types(idx: usize, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Helper function for entering the OBS graphics context"]
    pub fn obs_enter_graphics();
}
extern "C" {
    #[doc = " Helper function for leaving the OBS graphics context"]
    pub fn obs_leave_graphics();
}
extern "C" {
    #[doc = " Gets the main audio output handler for this OBS context"]
    pub fn obs_get_audio() -> *mut audio_t;
}
extern "C" {
    #[doc = " Gets the main video output handler for this OBS context"]
    pub fn obs_get_video() -> *mut video_t;
}
extern "C" {
    #[doc = " Returns true if video is active, false otherwise"]
    pub fn obs_video_active() -> bool;
}
extern "C" {
    #[doc = " Sets the primary output source for a channel."]
    pub fn obs_set_output_source(channel: u32, source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Gets the primary output source for a channel and increments the reference\n counter for that source.  Use obs_source_release to release."]
    pub fn obs_get_output_source(channel: u32) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Enumerates all input sources\n\n   Callback function returns true to continue enumeration, or false to end\n enumeration.\n\n   Use obs_source_get_ref or obs_source_get_weak_source if you want to retain\n a reference after obs_enum_sources finishes"]
    pub fn obs_enum_sources(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_source_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates scenes"]
    pub fn obs_enum_scenes(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_source_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates all sources (regardless of type)"]
    pub fn obs_enum_all_sources(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_source_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates outputs"]
    pub fn obs_enum_outputs(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_output_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates encoders"]
    pub fn obs_enum_encoders(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_encoder_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates encoders"]
    pub fn obs_enum_services(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_service_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Gets a source by its name.\n\n   Increments the source reference counter, use obs_source_release to\n release it when complete."]
    pub fn obs_get_source_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Gets a source by its UUID.\n\n   Increments the source reference counter, use obs_source_release to\n release it when complete."]
    pub fn obs_get_source_by_uuid(uuid: *const ::std::os::raw::c_char) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Get a transition source by its name."]
    pub fn obs_get_transition_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Get a transition source by its UUID."]
    pub fn obs_get_transition_by_uuid(uuid: *const ::std::os::raw::c_char) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Gets an output by its name."]
    pub fn obs_get_output_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_output_t;
}
extern "C" {
    #[doc = " Gets an encoder by its name."]
    pub fn obs_get_encoder_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Gets an service by its name."]
    pub fn obs_get_service_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_service_t;
}
#[doc = "< RGB/YUV"]
pub const obs_base_effect_OBS_EFFECT_DEFAULT: obs_base_effect = 0;
#[doc = "< RGB/YUV (using texture_rect)"]
pub const obs_base_effect_OBS_EFFECT_DEFAULT_RECT: obs_base_effect = 1;
#[doc = "< RGB/YUV (alpha set to 1.0)"]
pub const obs_base_effect_OBS_EFFECT_OPAQUE: obs_base_effect = 2;
#[doc = "< RGB/YUV (solid color only)"]
pub const obs_base_effect_OBS_EFFECT_SOLID: obs_base_effect = 3;
#[doc = "< Bicubic downscale"]
pub const obs_base_effect_OBS_EFFECT_BICUBIC: obs_base_effect = 4;
#[doc = "< Lanczos downscale"]
pub const obs_base_effect_OBS_EFFECT_LANCZOS: obs_base_effect = 5;
#[doc = "< Bilinear low resolution downscale"]
pub const obs_base_effect_OBS_EFFECT_BILINEAR_LOWRES: obs_base_effect = 6;
#[doc = "< Premultiplied alpha"]
pub const obs_base_effect_OBS_EFFECT_PREMULTIPLIED_ALPHA: obs_base_effect = 7;
#[doc = "< RGB/YUV (repeating)"]
pub const obs_base_effect_OBS_EFFECT_REPEAT: obs_base_effect = 8;
#[doc = "< Area rescale"]
pub const obs_base_effect_OBS_EFFECT_AREA: obs_base_effect = 9;
pub type obs_base_effect = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns a commonly used base effect"]
    pub fn obs_get_base_effect(effect: obs_base_effect) -> *mut gs_effect_t;
}
extern "C" {
    pub fn obs_get_default_rect_effect() -> *mut gs_effect_t;
}
extern "C" {
    #[doc = " Returns the primary obs signal handler"]
    pub fn obs_get_signal_handler() -> *mut signal_handler_t;
}
extern "C" {
    #[doc = " Returns the primary obs procedure handler"]
    pub fn obs_get_proc_handler() -> *mut proc_handler_t;
}
extern "C" {
    #[doc = " Renders the main view"]
    pub fn obs_render_main_view();
}
extern "C" {
    #[doc = " Renders the last main output texture"]
    pub fn obs_render_main_texture();
}
extern "C" {
    #[doc = " Renders the last main output texture ignoring background color"]
    pub fn obs_render_main_texture_src_color_only();
}
extern "C" {
    #[doc = " Returns the last main output texture.  This can return NULL if the texture\n is unavailable."]
    pub fn obs_get_main_texture() -> *mut gs_texture_t;
}
extern "C" {
    #[doc = " Sets the master user volume"]
    pub fn obs_set_master_volume(volume: f32);
}
extern "C" {
    #[doc = " Gets the master user volume"]
    pub fn obs_get_master_volume() -> f32;
}
extern "C" {
    #[doc = " Saves a source to settings data"]
    pub fn obs_save_source(source: *mut obs_source_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Loads a source from settings data"]
    pub fn obs_load_source(data: *mut obs_data_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Loads a private source from settings data"]
    pub fn obs_load_private_source(data: *mut obs_data_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Send a save signal to sources"]
    pub fn obs_source_save(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Send a load signal to sources (soft deprecated; does not load filters)"]
    pub fn obs_source_load(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Send a load signal to sources"]
    pub fn obs_source_load2(source: *mut obs_source_t);
}
pub type obs_load_source_cb = ::std::option::Option<
    unsafe extern "C" fn(private_data: *mut ::std::os::raw::c_void, source: *mut obs_source_t),
>;
extern "C" {
    #[doc = " Loads sources from a data array"]
    pub fn obs_load_sources(
        array: *mut obs_data_array_t,
        cb: obs_load_source_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Saves sources to a data array"]
    pub fn obs_save_sources() -> *mut obs_data_array_t;
}
pub type obs_save_source_filter_cb = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, source: *mut obs_source_t) -> bool,
>;
extern "C" {
    pub fn obs_save_sources_filtered(
        cb: obs_save_source_filter_cb,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut obs_data_array_t;
}
extern "C" {
    #[doc = " Reset source UUIDs. NOTE: this function is only to be used by the UI and\n  will be removed in a future version!"]
    pub fn obs_reset_source_uuids();
}
pub const obs_obj_type_OBS_OBJ_TYPE_INVALID: obs_obj_type = 0;
pub const obs_obj_type_OBS_OBJ_TYPE_SOURCE: obs_obj_type = 1;
pub const obs_obj_type_OBS_OBJ_TYPE_OUTPUT: obs_obj_type = 2;
pub const obs_obj_type_OBS_OBJ_TYPE_ENCODER: obs_obj_type = 3;
pub const obs_obj_type_OBS_OBJ_TYPE_SERVICE: obs_obj_type = 4;
pub type obs_obj_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_obj_get_type(obj: *mut ::std::os::raw::c_void) -> obs_obj_type;
}
extern "C" {
    pub fn obs_obj_get_id(obj: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_obj_invalid(obj: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn obs_obj_get_data(obj: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_obj_is_private(obj: *mut ::std::os::raw::c_void) -> bool;
}
pub type obs_enum_audio_device_cb = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
    ) -> bool,
>;
extern "C" {
    pub fn obs_audio_monitoring_available() -> bool;
}
extern "C" {
    pub fn obs_enum_audio_monitoring_devices(
        cb: obs_enum_audio_device_cb,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_set_audio_monitoring_device(
        name: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_get_audio_monitoring_device(
        name: *mut *const ::std::os::raw::c_char,
        id: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_add_tick_callback(
        tick: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, seconds: f32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_remove_tick_callback(
        tick: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, seconds: f32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_add_main_render_callback(
        draw: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_remove_main_render_callback(
        draw: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_add_main_rendered_callback(
        rendered: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_remove_main_rendered_callback(
        rendered: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_add_raw_video_callback(
        conversion: *const video_scale_info,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_remove_raw_video_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_add_raw_audio_callback(
        mix_idx: usize,
        conversion: *const audio_convert_info,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_remove_raw_audio_callback(
        mix_idx: usize,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_get_video_frame_time() -> u64;
}
extern "C" {
    pub fn obs_get_active_fps() -> f64;
}
extern "C" {
    pub fn obs_get_average_frame_time_ns() -> u64;
}
extern "C" {
    pub fn obs_get_frame_interval_ns() -> u64;
}
extern "C" {
    pub fn obs_get_total_frames() -> u32;
}
extern "C" {
    pub fn obs_get_lagged_frames() -> u32;
}
extern "C" {
    pub fn obs_nv12_tex_active() -> bool;
}
extern "C" {
    pub fn obs_p010_tex_active() -> bool;
}
extern "C" {
    pub fn obs_apply_private_data(settings: *mut obs_data_t);
}
extern "C" {
    pub fn obs_set_private_data(settings: *mut obs_data_t);
}
extern "C" {
    pub fn obs_get_private_data() -> *mut obs_data_t;
}
pub type obs_task_t =
    ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>;
pub const obs_task_type_OBS_TASK_UI: obs_task_type = 0;
pub const obs_task_type_OBS_TASK_GRAPHICS: obs_task_type = 1;
pub const obs_task_type_OBS_TASK_AUDIO: obs_task_type = 2;
pub const obs_task_type_OBS_TASK_DESTROY: obs_task_type = 3;
pub type obs_task_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_queue_task(
        type_: obs_task_type,
        task: obs_task_t,
        param: *mut ::std::os::raw::c_void,
        wait: bool,
    );
}
extern "C" {
    pub fn obs_in_task_thread(type_: obs_task_type) -> bool;
}
extern "C" {
    pub fn obs_wait_for_destroy_queue() -> bool;
}
pub type obs_task_handler_t = ::std::option::Option<
    unsafe extern "C" fn(task: obs_task_t, param: *mut ::std::os::raw::c_void, wait: bool),
>;
extern "C" {
    pub fn obs_set_ui_task_handler(handler: obs_task_handler_t);
}
extern "C" {
    pub fn obs_object_get_ref(object: *mut obs_object_t) -> *mut obs_object_t;
}
extern "C" {
    pub fn obs_object_release(object: *mut obs_object_t);
}
extern "C" {
    pub fn obs_weak_object_addref(weak: *mut obs_weak_object_t);
}
extern "C" {
    pub fn obs_weak_object_release(weak: *mut obs_weak_object_t);
}
extern "C" {
    pub fn obs_object_get_weak_object(object: *mut obs_object_t) -> *mut obs_weak_object_t;
}
extern "C" {
    pub fn obs_weak_object_get_object(weak: *mut obs_weak_object_t) -> *mut obs_object_t;
}
extern "C" {
    pub fn obs_weak_object_expired(weak: *mut obs_weak_object_t) -> bool;
}
extern "C" {
    pub fn obs_weak_object_references_object(
        weak: *mut obs_weak_object_t,
        object: *mut obs_object_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates a view context.\n\n   A view can be used for things like separate previews, or drawing\n sources separately."]
    pub fn obs_view_create() -> *mut obs_view_t;
}
extern "C" {
    #[doc = " Destroys this view context"]
    pub fn obs_view_destroy(view: *mut obs_view_t);
}
extern "C" {
    #[doc = " Sets the source to be used for this view context."]
    pub fn obs_view_set_source(view: *mut obs_view_t, channel: u32, source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Gets the source currently in use for this view context"]
    pub fn obs_view_get_source(view: *mut obs_view_t, channel: u32) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Renders the sources of this view context"]
    pub fn obs_view_render(view: *mut obs_view_t);
}
extern "C" {
    #[doc = " Adds a view to the main render loop, with current obs_get_video_info state"]
    pub fn obs_view_add(view: *mut obs_view_t) -> *mut video_t;
}
extern "C" {
    #[doc = " Adds a view to the main render loop, with custom video settings"]
    pub fn obs_view_add2(view: *mut obs_view_t, ovi: *mut obs_video_info) -> *mut video_t;
}
extern "C" {
    #[doc = " Removes a view from the main render loop"]
    pub fn obs_view_remove(view: *mut obs_view_t);
}
extern "C" {
    #[doc = " Gets the video settings currently in use for this view context, returns false if no video"]
    pub fn obs_view_get_video_info(view: *mut obs_view_t, ovi: *mut obs_video_info) -> bool;
}
extern "C" {
    #[doc = " Adds a new window display linked to the main render pipeline.  This creates\n a new swap chain which updates every frame.\n\n @param  graphics_data  The swap chain initialization data.\n @return                The new display context, or NULL if failed."]
    pub fn obs_display_create(
        graphics_data: *const gs_init_data,
        backround_color: u32,
    ) -> *mut obs_display_t;
}
extern "C" {
    #[doc = " Destroys a display context"]
    pub fn obs_display_destroy(display: *mut obs_display_t);
}
extern "C" {
    #[doc = " Changes the size of this display"]
    pub fn obs_display_resize(display: *mut obs_display_t, cx: u32, cy: u32);
}
extern "C" {
    #[doc = " Updates the color space of this display"]
    pub fn obs_display_update_color_space(display: *mut obs_display_t);
}
extern "C" {
    #[doc = " Adds a draw callback for this display context\n\n @param  display  The display context.\n @param  draw     The draw callback which is called each time a frame\n                  updates.\n @param  param    The user data to be associated with this draw callback."]
    pub fn obs_display_add_draw_callback(
        display: *mut obs_display_t,
        draw: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Removes a draw callback for this display context"]
    pub fn obs_display_remove_draw_callback(
        display: *mut obs_display_t,
        draw: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_display_set_enabled(display: *mut obs_display_t, enable: bool);
}
extern "C" {
    pub fn obs_display_enabled(display: *mut obs_display_t) -> bool;
}
extern "C" {
    pub fn obs_display_set_background_color(display: *mut obs_display_t, color: u32);
}
extern "C" {
    pub fn obs_display_size(display: *mut obs_display_t, width: *mut u32, height: *mut u32);
}
extern "C" {
    #[doc = " Returns the translated display name of a source"]
    pub fn obs_source_get_display_name(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a source of the specified type with the specified settings.\n\n   The \"source\" context is used for anything related to presenting\n or modifying video/audio.  Use obs_source_release to release it."]
    pub fn obs_source_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_source_create_private(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
    ) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_source_duplicate(
        source: *mut obs_source_t,
        desired_name: *const ::std::os::raw::c_char,
        create_private: bool,
    ) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Adds/releases a reference to a source.  When the last reference is\n released, the source is destroyed."]
    pub fn obs_source_addref(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_release(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_weak_source_addref(weak: *mut obs_weak_source_t);
}
extern "C" {
    pub fn obs_weak_source_release(weak: *mut obs_weak_source_t);
}
extern "C" {
    pub fn obs_source_get_ref(source: *mut obs_source_t) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_source_get_weak_source(source: *mut obs_source_t) -> *mut obs_weak_source_t;
}
extern "C" {
    pub fn obs_weak_source_get_source(weak: *mut obs_weak_source_t) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_weak_source_expired(weak: *mut obs_weak_source_t) -> bool;
}
extern "C" {
    pub fn obs_weak_source_references_source(
        weak: *mut obs_weak_source_t,
        source: *mut obs_source_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Notifies all references that the source should be released"]
    pub fn obs_source_remove(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Returns true if the source should be released"]
    pub fn obs_source_removed(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " The 'hidden' flag is not the same as a sceneitem's visibility. It is a\n property the determines if it can be found through searches. **/\n/** Simply sets a 'hidden' flag when the source is still alive but shouldn't be found"]
    pub fn obs_source_set_hidden(source: *mut obs_source_t, hidden: bool);
}
extern "C" {
    #[doc = " Returns the current 'hidden' state on the source"]
    pub fn obs_source_is_hidden(source: *mut obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Returns capability flags of a source"]
    pub fn obs_source_get_output_flags(source: *const obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Returns capability flags of a source type"]
    pub fn obs_get_source_output_flags(id: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    #[doc = " Gets the default settings for a source type"]
    pub fn obs_get_source_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_source_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
}
extern "C" {
    pub fn obs_source_get_missing_files(source: *const obs_source_t) -> *mut obs_missing_files_t;
}
extern "C" {
    pub fn obs_source_replace_missing_file(
        cb: obs_missing_file_cb,
        source: *mut obs_source_t,
        new_path: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns whether the source has custom properties or not"]
    pub fn obs_is_source_configurable(id: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_source_configurable(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Returns the properties list for a specific existing source.  Free with\n obs_properties_destroy"]
    pub fn obs_source_properties(source: *const obs_source_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Updates settings for this source"]
    pub fn obs_source_update(source: *mut obs_source_t, settings: *mut obs_data_t);
}
extern "C" {
    pub fn obs_source_reset_settings(source: *mut obs_source_t, settings: *mut obs_data_t);
}
extern "C" {
    #[doc = " Renders a video source."]
    pub fn obs_source_video_render(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Gets the width of a source (if it has video)"]
    pub fn obs_source_get_width(source: *mut obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Gets the height of a source (if it has video)"]
    pub fn obs_source_get_height(source: *mut obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Gets the color space of a source (if it has video)"]
    pub fn obs_source_get_color_space(
        source: *mut obs_source_t,
        count: usize,
        preferred_spaces: *const gs_color_space,
    ) -> gs_color_space;
}
extern "C" {
    #[doc = " Hints whether or not the source will blend texels"]
    pub fn obs_source_get_texcoords_centered(source: *mut obs_source_t) -> bool;
}
extern "C" {
    #[doc = " If the source is a filter, returns the parent source of the filter.  Only\n guaranteed to be valid inside of the video_render, filter_audio,\n filter_video, and filter_remove callbacks."]
    pub fn obs_filter_get_parent(filter: *const obs_source_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " If the source is a filter, returns the target source of the filter.  Only\n guaranteed to be valid inside of the video_render, filter_audio,\n filter_video, and filter_remove callbacks."]
    pub fn obs_filter_get_target(filter: *const obs_source_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Used to directly render a non-async source without any filter processing"]
    pub fn obs_source_default_render(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Adds a filter to the source (which is used whenever the source is used)"]
    pub fn obs_source_filter_add(source: *mut obs_source_t, filter: *mut obs_source_t);
}
extern "C" {
    #[doc = " Removes a filter from the source"]
    pub fn obs_source_filter_remove(source: *mut obs_source_t, filter: *mut obs_source_t);
}
extern "C" {
    #[doc = " Modifies the order of a specific filter"]
    pub fn obs_source_filter_set_order(
        source: *mut obs_source_t,
        filter: *mut obs_source_t,
        movement: obs_order_movement,
    );
}
extern "C" {
    #[doc = " Gets the settings string for a source"]
    pub fn obs_source_get_settings(source: *const obs_source_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Gets the name of a source"]
    pub fn obs_source_get_name(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the name of a source"]
    pub fn obs_source_set_name(source: *mut obs_source_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets the UUID of a source"]
    pub fn obs_source_get_uuid(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the source type"]
    pub fn obs_source_get_type(source: *const obs_source_t) -> obs_source_type;
}
extern "C" {
    #[doc = " Gets the source identifier"]
    pub fn obs_source_get_id(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_source_get_unversioned_id(
        source: *const obs_source_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the signal handler for a source"]
    pub fn obs_source_get_signal_handler(source: *const obs_source_t) -> *mut signal_handler_t;
}
extern "C" {
    #[doc = " Returns the procedure handler for a source"]
    pub fn obs_source_get_proc_handler(source: *const obs_source_t) -> *mut proc_handler_t;
}
extern "C" {
    #[doc = " Sets the user volume for a source that has audio output"]
    pub fn obs_source_set_volume(source: *mut obs_source_t, volume: f32);
}
extern "C" {
    #[doc = " Gets the user volume for a source that has audio output"]
    pub fn obs_source_get_volume(source: *const obs_source_t) -> f32;
}
extern "C" {
    pub fn obs_source_get_speaker_layout(source: *mut obs_source_t) -> speaker_layout;
}
extern "C" {
    #[doc = " Sets the balance value for a stereo audio source"]
    pub fn obs_source_set_balance_value(source: *mut obs_source_t, balance: f32);
}
extern "C" {
    #[doc = " Gets the balance value for a stereo audio source"]
    pub fn obs_source_get_balance_value(source: *const obs_source_t) -> f32;
}
extern "C" {
    #[doc = " Sets the audio sync offset (in nanoseconds) for a source"]
    pub fn obs_source_set_sync_offset(source: *mut obs_source_t, offset: i64);
}
extern "C" {
    #[doc = " Gets the audio sync offset (in nanoseconds) for a source"]
    pub fn obs_source_get_sync_offset(source: *const obs_source_t) -> i64;
}
extern "C" {
    #[doc = " Enumerates active child sources used by this source"]
    pub fn obs_source_enum_active_sources(
        source: *mut obs_source_t,
        enum_callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates the entire active child source tree used by this source"]
    pub fn obs_source_enum_active_tree(
        source: *mut obs_source_t,
        enum_callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_source_enum_full_tree(
        source: *mut obs_source_t,
        enum_callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns true if active, false if not"]
    pub fn obs_source_active(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Returns true if currently displayed somewhere (active or not), false if not"]
    pub fn obs_source_showing(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Sets source flags.  Note that these are different from the main output\n flags.  These are generally things that can be set by the source or user,\n while the output flags are more used to determine capabilities of a source."]
    pub fn obs_source_set_flags(source: *mut obs_source_t, flags: u32);
}
extern "C" {
    #[doc = " Gets source flags."]
    pub fn obs_source_get_flags(source: *const obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Sets audio mixer flags.  These flags are used to specify which mixers\n the source's audio should be applied to."]
    pub fn obs_source_set_audio_mixers(source: *mut obs_source_t, mixers: u32);
}
extern "C" {
    #[doc = " Gets audio mixer flags"]
    pub fn obs_source_get_audio_mixers(source: *const obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Increments the 'showing' reference counter to indicate that the source is\n being shown somewhere.  If the reference counter was 0, will call the 'show'\n callback."]
    pub fn obs_source_inc_showing(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Increments the 'active' reference counter to indicate that the source is\n fully active.  If the reference counter was 0, will call the 'activate'\n callback.\n\n Unlike obs_source_inc_showing, this will cause children of this source to be\n considered showing as well (currently used by transition previews to make\n the stinger transition show correctly).  obs_source_inc_showing should\n generally be used instead."]
    pub fn obs_source_inc_active(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Decrements the 'showing' reference counter to indicate that the source is\n no longer being shown somewhere.  If the reference counter is set to 0,\n will call the 'hide' callback"]
    pub fn obs_source_dec_showing(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Decrements the 'active' reference counter to indicate that the source is no\n longer fully active.  If the reference counter is set to 0, will call the\n 'deactivate' callback\n\n Unlike obs_source_dec_showing, this will cause children of this source to be\n considered not showing as well.  obs_source_dec_showing should generally be\n used instead."]
    pub fn obs_source_dec_active(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Enumerates filters assigned to the source"]
    pub fn obs_source_enum_filters(
        source: *mut obs_source_t,
        callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Gets a filter of a source by its display name."]
    pub fn obs_source_get_filter_by_name(
        source: *mut obs_source_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Gets the number of filters the source has."]
    pub fn obs_source_filter_count(source: *const obs_source_t) -> usize;
}
extern "C" {
    pub fn obs_source_copy_filters(dst: *mut obs_source_t, src: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_copy_single_filter(dst: *mut obs_source_t, filter: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_enabled(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_set_enabled(source: *mut obs_source_t, enabled: bool);
}
extern "C" {
    pub fn obs_source_muted(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_set_muted(source: *mut obs_source_t, muted: bool);
}
extern "C" {
    pub fn obs_source_push_to_mute_enabled(source: *mut obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_enable_push_to_mute(source: *mut obs_source_t, enabled: bool);
}
extern "C" {
    pub fn obs_source_get_push_to_mute_delay(source: *mut obs_source_t) -> u64;
}
extern "C" {
    pub fn obs_source_set_push_to_mute_delay(source: *mut obs_source_t, delay: u64);
}
extern "C" {
    pub fn obs_source_push_to_talk_enabled(source: *mut obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_enable_push_to_talk(source: *mut obs_source_t, enabled: bool);
}
extern "C" {
    pub fn obs_source_get_push_to_talk_delay(source: *mut obs_source_t) -> u64;
}
extern "C" {
    pub fn obs_source_set_push_to_talk_delay(source: *mut obs_source_t, delay: u64);
}
pub type obs_source_audio_capture_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        source: *mut obs_source_t,
        audio_data: *const audio_data,
        muted: bool,
    ),
>;
extern "C" {
    pub fn obs_source_add_audio_capture_callback(
        source: *mut obs_source_t,
        callback: obs_source_audio_capture_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_source_remove_audio_capture_callback(
        source: *mut obs_source_t,
        callback: obs_source_audio_capture_t,
        param: *mut ::std::os::raw::c_void,
    );
}
pub type obs_source_caption_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        source: *mut obs_source_t,
        captions: *const obs_source_cea_708,
    ),
>;
extern "C" {
    pub fn obs_source_add_caption_callback(
        source: *mut obs_source_t,
        callback: obs_source_caption_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_source_remove_caption_callback(
        source: *mut obs_source_t,
        callback: obs_source_caption_t,
        param: *mut ::std::os::raw::c_void,
    );
}
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_DISABLE: obs_deinterlace_mode = 0;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_DISCARD: obs_deinterlace_mode = 1;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_RETRO: obs_deinterlace_mode = 2;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_BLEND: obs_deinterlace_mode = 3;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_BLEND_2X: obs_deinterlace_mode = 4;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_LINEAR: obs_deinterlace_mode = 5;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_LINEAR_2X: obs_deinterlace_mode = 6;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_YADIF: obs_deinterlace_mode = 7;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_YADIF_2X: obs_deinterlace_mode = 8;
pub type obs_deinterlace_mode = ::std::os::raw::c_uint;
pub const obs_deinterlace_field_order_OBS_DEINTERLACE_FIELD_ORDER_TOP: obs_deinterlace_field_order =
    0;
pub const obs_deinterlace_field_order_OBS_DEINTERLACE_FIELD_ORDER_BOTTOM:
    obs_deinterlace_field_order = 1;
pub type obs_deinterlace_field_order = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_source_set_deinterlace_mode(source: *mut obs_source_t, mode: obs_deinterlace_mode);
}
extern "C" {
    pub fn obs_source_get_deinterlace_mode(source: *const obs_source_t) -> obs_deinterlace_mode;
}
extern "C" {
    pub fn obs_source_set_deinterlace_field_order(
        source: *mut obs_source_t,
        field_order: obs_deinterlace_field_order,
    );
}
extern "C" {
    pub fn obs_source_get_deinterlace_field_order(
        source: *const obs_source_t,
    ) -> obs_deinterlace_field_order;
}
pub const obs_monitoring_type_OBS_MONITORING_TYPE_NONE: obs_monitoring_type = 0;
pub const obs_monitoring_type_OBS_MONITORING_TYPE_MONITOR_ONLY: obs_monitoring_type = 1;
pub const obs_monitoring_type_OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT: obs_monitoring_type = 2;
pub type obs_monitoring_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_source_set_monitoring_type(source: *mut obs_source_t, type_: obs_monitoring_type);
}
extern "C" {
    pub fn obs_source_get_monitoring_type(source: *const obs_source_t) -> obs_monitoring_type;
}
extern "C" {
    #[doc = " Gets private front-end settings data.  This data is saved/loaded\n automatically.  Returns an incremented reference."]
    pub fn obs_source_get_private_settings(item: *mut obs_source_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_source_backup_filters(source: *mut obs_source_t) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_source_restore_filters(source: *mut obs_source_t, array: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_source_get_type_data(source: *mut obs_source_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Helper function to set the color matrix information when drawing the source.\n\n @param  color_matrix     The color matrix.  Assigns to the 'color_matrix'\n                          effect variable.\n @param  color_range_min  The minimum color range.  Assigns to the\n                          'color_range_min' effect variable.  If NULL,\n                          {0.0f, 0.0f, 0.0f} is used.\n @param  color_range_max  The maximum color range.  Assigns to the\n                          'color_range_max' effect variable.  If NULL,\n                          {1.0f, 1.0f, 1.0f} is used."]
    pub fn obs_source_draw_set_color_matrix(
        color_matrix: *const matrix4,
        color_range_min: *const vec3,
        color_range_max: *const vec3,
    );
}
extern "C" {
    #[doc = " Helper function to draw sprites for a source (synchronous video).\n\n @param  image   The sprite texture to draw.  Assigns to the 'image' variable\n                 of the current effect.\n @param  x       X position of the sprite.\n @param  y       Y position of the sprite.\n @param  cx      Width of the sprite.  If 0, uses the texture width.\n @param  cy      Height of the sprite.  If 0, uses the texture height.\n @param  flip    Specifies whether to flip the image vertically."]
    pub fn obs_source_draw(
        image: *mut gs_texture_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: u32,
        cy: u32,
        flip: bool,
    );
}
extern "C" {
    #[doc = " Outputs asynchronous video data.  Set to NULL to deactivate the texture\n\n NOTE: Non-YUV formats will always be treated as full range with this\n function!  Use obs_source_output_video2 instead if partial range support is\n desired for non-YUV video formats."]
    pub fn obs_source_output_video(source: *mut obs_source_t, frame: *const obs_source_frame);
}
extern "C" {
    pub fn obs_source_output_video2(source: *mut obs_source_t, frame: *const obs_source_frame2);
}
extern "C" {
    pub fn obs_source_set_async_rotation(
        source: *mut obs_source_t,
        rotation: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn obs_source_output_cea708(source: *mut obs_source_t, captions: *const obs_source_cea_708);
}
extern "C" {
    #[doc = " Preloads asynchronous video data to allow instantaneous playback\n\n NOTE: Non-YUV formats will always be treated as full range with this\n function!  Use obs_source_preload_video2 instead if partial range support is\n desired for non-YUV video formats."]
    pub fn obs_source_preload_video(source: *mut obs_source_t, frame: *const obs_source_frame);
}
extern "C" {
    pub fn obs_source_preload_video2(source: *mut obs_source_t, frame: *const obs_source_frame2);
}
extern "C" {
    #[doc = " Shows any preloaded video data"]
    pub fn obs_source_show_preloaded_video(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Sets current async video frame immediately\n\n NOTE: Non-YUV formats will always be treated as full range with this\n function!  Use obs_source_preload_video2 instead if partial range support is\n desired for non-YUV video formats."]
    pub fn obs_source_set_video_frame(source: *mut obs_source_t, frame: *const obs_source_frame);
}
extern "C" {
    pub fn obs_source_set_video_frame2(source: *mut obs_source_t, frame: *const obs_source_frame2);
}
extern "C" {
    #[doc = " Outputs audio data (always asynchronous)"]
    pub fn obs_source_output_audio(source: *mut obs_source_t, audio: *const obs_source_audio);
}
extern "C" {
    #[doc = " Signal an update to any currently used properties via 'update_properties'"]
    pub fn obs_source_update_properties(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Gets the current async video frame"]
    pub fn obs_source_get_frame(source: *mut obs_source_t) -> *mut obs_source_frame;
}
extern "C" {
    #[doc = " Releases the current async video frame"]
    pub fn obs_source_release_frame(source: *mut obs_source_t, frame: *mut obs_source_frame);
}
extern "C" {
    #[doc = " Default RGB filter handler for generic effect filters.  Processes the\n filter chain and renders them to texture if needed, then the filter is\n drawn with\n\n After calling this, set your parameters for the effect, then call\n obs_source_process_filter_end to draw the filter.\n\n Returns true if filtering should continue, false if the filter is bypassed\n for whatever reason."]
    pub fn obs_source_process_filter_begin(
        filter: *mut obs_source_t,
        format: gs_color_format,
        allow_direct: obs_allow_direct_render,
    ) -> bool;
}
extern "C" {
    pub fn obs_source_process_filter_begin_with_color_space(
        filter: *mut obs_source_t,
        format: gs_color_format,
        space: gs_color_space,
        allow_direct: obs_allow_direct_render,
    ) -> bool;
}
extern "C" {
    #[doc = " Draws the filter.\n\n Before calling this function, first call obs_source_process_filter_begin and\n then set the effect parameters, and then call this function to finalize the\n filter."]
    pub fn obs_source_process_filter_end(
        filter: *mut obs_source_t,
        effect: *mut gs_effect_t,
        width: u32,
        height: u32,
    );
}
extern "C" {
    #[doc = " Draws the filter with a specific technique.\n\n Before calling this function, first call obs_source_process_filter_begin and\n then set the effect parameters, and then call this function to finalize the\n filter."]
    pub fn obs_source_process_filter_tech_end(
        filter: *mut obs_source_t,
        effect: *mut gs_effect_t,
        width: u32,
        height: u32,
        tech_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Skips the filter if the filter is invalid and cannot be rendered"]
    pub fn obs_source_skip_video_filter(filter: *mut obs_source_t);
}
extern "C" {
    #[doc = " Adds an active child source.  Must be called by parent sources on child\n sources when the child is added and active.  This ensures that the source is\n properly activated if the parent is active.\n\n @returns true if source can be added, false if it causes recursion"]
    pub fn obs_source_add_active_child(parent: *mut obs_source_t, child: *mut obs_source_t)
        -> bool;
}
extern "C" {
    #[doc = " Removes an active child source.  Must be called by parent sources on child\n sources when the child is removed or inactive.  This ensures that the source\n is properly deactivated if the parent is no longer active."]
    pub fn obs_source_remove_active_child(parent: *mut obs_source_t, child: *mut obs_source_t);
}
extern "C" {
    #[doc = " Sends a mouse down/up event to a source"]
    pub fn obs_source_send_mouse_click(
        source: *mut obs_source_t,
        event: *const obs_mouse_event,
        type_: i32,
        mouse_up: bool,
        click_count: u32,
    );
}
extern "C" {
    #[doc = " Sends a mouse move event to a source."]
    pub fn obs_source_send_mouse_move(
        source: *mut obs_source_t,
        event: *const obs_mouse_event,
        mouse_leave: bool,
    );
}
extern "C" {
    #[doc = " Sends a mouse wheel event to a source"]
    pub fn obs_source_send_mouse_wheel(
        source: *mut obs_source_t,
        event: *const obs_mouse_event,
        x_delta: ::std::os::raw::c_int,
        y_delta: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sends a got-focus or lost-focus event to a source"]
    pub fn obs_source_send_focus(source: *mut obs_source_t, focus: bool);
}
extern "C" {
    #[doc = " Sends a key up/down event to a source"]
    pub fn obs_source_send_key_click(
        source: *mut obs_source_t,
        event: *const obs_key_event,
        key_up: bool,
    );
}
extern "C" {
    #[doc = " Sets the default source flags."]
    pub fn obs_source_set_default_flags(source: *mut obs_source_t, flags: u32);
}
extern "C" {
    #[doc = " Gets the base width for a source (not taking in to account filtering)"]
    pub fn obs_source_get_base_width(source: *mut obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Gets the base height for a source (not taking in to account filtering)"]
    pub fn obs_source_get_base_height(source: *mut obs_source_t) -> u32;
}
extern "C" {
    pub fn obs_source_audio_pending(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_get_audio_timestamp(source: *const obs_source_t) -> u64;
}
extern "C" {
    pub fn obs_source_get_audio_mix(source: *const obs_source_t, audio: *mut obs_source_audio_mix);
}
extern "C" {
    pub fn obs_source_set_async_unbuffered(source: *mut obs_source_t, unbuffered: bool);
}
extern "C" {
    pub fn obs_source_async_unbuffered(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Used to decouple audio from video so that audio doesn't attempt to sync up\n with video.  I.E. Audio acts independently.  Only works when in unbuffered\n mode."]
    pub fn obs_source_set_async_decoupled(source: *mut obs_source_t, decouple: bool);
}
extern "C" {
    pub fn obs_source_async_decoupled(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_set_audio_active(source: *mut obs_source_t, show: bool);
}
extern "C" {
    pub fn obs_source_audio_active(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_get_last_obs_version(source: *const obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Media controls"]
    pub fn obs_source_media_play_pause(source: *mut obs_source_t, pause: bool);
}
extern "C" {
    pub fn obs_source_media_restart(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_stop(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_next(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_previous(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_get_duration(source: *mut obs_source_t) -> i64;
}
extern "C" {
    pub fn obs_source_media_get_time(source: *mut obs_source_t) -> i64;
}
extern "C" {
    pub fn obs_source_media_set_time(source: *mut obs_source_t, ms: i64);
}
extern "C" {
    pub fn obs_source_media_get_state(source: *mut obs_source_t) -> obs_media_state;
}
extern "C" {
    pub fn obs_source_media_started(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_ended(source: *mut obs_source_t);
}
pub const obs_transition_target_OBS_TRANSITION_SOURCE_A: obs_transition_target = 0;
pub const obs_transition_target_OBS_TRANSITION_SOURCE_B: obs_transition_target = 1;
pub type obs_transition_target = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_transition_get_source(
        transition: *mut obs_source_t,
        target: obs_transition_target,
    ) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_transition_clear(transition: *mut obs_source_t);
}
extern "C" {
    pub fn obs_transition_get_active_source(transition: *mut obs_source_t) -> *mut obs_source_t;
}
pub const obs_transition_mode_OBS_TRANSITION_MODE_AUTO: obs_transition_mode = 0;
pub const obs_transition_mode_OBS_TRANSITION_MODE_MANUAL: obs_transition_mode = 1;
pub type obs_transition_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_transition_start(
        transition: *mut obs_source_t,
        mode: obs_transition_mode,
        duration_ms: u32,
        dest: *mut obs_source_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_transition_set(transition: *mut obs_source_t, source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_transition_set_manual_time(transition: *mut obs_source_t, t: f32);
}
extern "C" {
    pub fn obs_transition_set_manual_torque(transition: *mut obs_source_t, torque: f32, clamp: f32);
}
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_MAX_ONLY: obs_transition_scale_type = 0;
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_ASPECT: obs_transition_scale_type = 1;
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_STRETCH: obs_transition_scale_type = 2;
pub type obs_transition_scale_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn obs_transition_set_scale_type(
        transition: *mut obs_source_t,
        type_: obs_transition_scale_type,
    );
}
extern "C" {
    pub fn obs_transition_get_scale_type(
        transition: *const obs_source_t,
    ) -> obs_transition_scale_type;
}
extern "C" {
    pub fn obs_transition_set_alignment(transition: *mut obs_source_t, alignment: u32);
}
extern "C" {
    pub fn obs_transition_get_alignment(transition: *const obs_source_t) -> u32;
}
extern "C" {
    pub fn obs_transition_set_size(transition: *mut obs_source_t, cx: u32, cy: u32);
}
extern "C" {
    pub fn obs_transition_get_size(transition: *const obs_source_t, cx: *mut u32, cy: *mut u32);
}
extern "C" {
    #[doc = " Enables fixed transitions (videos or specific types of transitions that\n are of fixed duration and linearly interpolated"]
    pub fn obs_transition_enable_fixed(
        transition: *mut obs_source_t,
        enable: bool,
        duration_ms: u32,
    );
}
extern "C" {
    pub fn obs_transition_fixed(transition: *mut obs_source_t) -> bool;
}
pub type obs_transition_video_render_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        a: *mut gs_texture_t,
        b: *mut gs_texture_t,
        t: f32,
        cx: u32,
        cy: u32,
    ),
>;
pub type obs_transition_audio_mix_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, t: f32) -> f32>;
extern "C" {
    pub fn obs_transition_get_time(transition: *mut obs_source_t) -> f32;
}
extern "C" {
    pub fn obs_transition_force_stop(transition: *mut obs_source_t);
}
extern "C" {
    pub fn obs_transition_video_render(
        transition: *mut obs_source_t,
        callback: obs_transition_video_render_callback_t,
    );
}
extern "C" {
    pub fn obs_transition_video_render2(
        transition: *mut obs_source_t,
        callback: obs_transition_video_render_callback_t,
        placeholder_texture: *mut gs_texture_t,
    );
}
extern "C" {
    pub fn obs_transition_video_get_color_space(transition: *mut obs_source_t) -> gs_color_space;
}
extern "C" {
    #[doc = " Directly renders its sub-source instead of to texture.  Returns false if no\n longer transitioning"]
    pub fn obs_transition_video_render_direct(
        transition: *mut obs_source_t,
        target: obs_transition_target,
    ) -> bool;
}
extern "C" {
    pub fn obs_transition_audio_render(
        transition: *mut obs_source_t,
        ts_out: *mut u64,
        audio: *mut obs_source_audio_mix,
        mixers: u32,
        channels: usize,
        sample_rate: usize,
        mix_a_callback: obs_transition_audio_mix_callback_t,
        mix_b_callback: obs_transition_audio_mix_callback_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_transition_swap_begin(tr_dest: *mut obs_source_t, tr_source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_transition_swap_end(tr_dest: *mut obs_source_t, tr_source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Creates a scene.\n\n   A scene is a source which is a container of other sources with specific\n display orientations.  Scenes can also be used like any other source."]
    pub fn obs_scene_create(name: *const ::std::os::raw::c_char) -> *mut obs_scene_t;
}
extern "C" {
    pub fn obs_scene_create_private(name: *const ::std::os::raw::c_char) -> *mut obs_scene_t;
}
#[doc = "< Source refs only"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_REFS: obs_scene_duplicate_type = 0;
#[doc = "< Fully duplicate"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_COPY: obs_scene_duplicate_type = 1;
#[doc = "< Source refs only (as private)"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_PRIVATE_REFS: obs_scene_duplicate_type = 2;
#[doc = "< Fully duplicate (as private)"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_PRIVATE_COPY: obs_scene_duplicate_type = 3;
pub type obs_scene_duplicate_type = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Duplicates a scene."]
    pub fn obs_scene_duplicate(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        type_: obs_scene_duplicate_type,
    ) -> *mut obs_scene_t;
}
extern "C" {
    pub fn obs_scene_addref(scene: *mut obs_scene_t);
}
extern "C" {
    pub fn obs_scene_release(scene: *mut obs_scene_t);
}
extern "C" {
    pub fn obs_scene_get_ref(scene: *mut obs_scene_t) -> *mut obs_scene_t;
}
extern "C" {
    #[doc = " Gets the scene's source context"]
    pub fn obs_scene_get_source(scene: *const obs_scene_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Gets the scene from its source, or NULL if not a scene"]
    pub fn obs_scene_from_source(source: *const obs_source_t) -> *mut obs_scene_t;
}
extern "C" {
    #[doc = " Determines whether a source is within a scene"]
    pub fn obs_scene_find_source(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_find_source_recursive(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_find_sceneitem_by_id(scene: *mut obs_scene_t, id: i64)
        -> *mut obs_sceneitem_t;
}
extern "C" {
    #[doc = " Enumerates sources within a scene"]
    pub fn obs_scene_enum_items(
        scene: *mut obs_scene_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut obs_scene_t,
                arg2: *mut obs_sceneitem_t,
                arg3: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_scene_reorder_items(
        scene: *mut obs_scene_t,
        item_order: *const *mut obs_sceneitem_t,
        item_order_size: usize,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_sceneitem_order_info {
    pub group: *mut obs_sceneitem_t,
    pub item: *mut obs_sceneitem_t,
}
#[test]
fn bindgen_test_layout_obs_sceneitem_order_info() {
    const UNINIT: ::std::mem::MaybeUninit<obs_sceneitem_order_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_sceneitem_order_info>(),
        16usize,
        concat!("Size of: ", stringify!(obs_sceneitem_order_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_sceneitem_order_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_sceneitem_order_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_order_info),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_order_info),
            "::",
            stringify!(item)
        )
    );
}
impl Default for obs_sceneitem_order_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn obs_scene_reorder_items2(
        scene: *mut obs_scene_t,
        item_order: *mut obs_sceneitem_order_info,
        item_order_size: usize,
    ) -> bool;
}
extern "C" {
    pub fn obs_source_is_scene(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Adds/creates a new scene item for a source"]
    pub fn obs_scene_add(
        scene: *mut obs_scene_t,
        source: *mut obs_source_t,
    ) -> *mut obs_sceneitem_t;
}
pub type obs_scene_atomic_update_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, scene: *mut obs_scene_t),
>;
extern "C" {
    pub fn obs_scene_atomic_update(
        scene: *mut obs_scene_t,
        func: obs_scene_atomic_update_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_sceneitem_addref(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_release(item: *mut obs_sceneitem_t);
}
extern "C" {
    #[doc = " Removes a scene item."]
    pub fn obs_sceneitem_remove(item: *mut obs_sceneitem_t);
}
extern "C" {
    #[doc = " Adds a scene item."]
    pub fn obs_sceneitems_add(scene: *mut obs_scene_t, data: *mut obs_data_array_t);
}
extern "C" {
    #[doc = " Saves Sceneitem into an array, arr"]
    pub fn obs_sceneitem_save(item: *mut obs_sceneitem_t, arr: *mut obs_data_array_t);
}
extern "C" {
    #[doc = " Set the ID of a sceneitem"]
    pub fn obs_sceneitem_set_id(sceneitem: *mut obs_sceneitem_t, id: i64);
}
extern "C" {
    #[doc = " Tries to find the sceneitem of the source in a given scene. Returns NULL if not found"]
    pub fn obs_scene_sceneitem_from_source(
        scene: *mut obs_scene_t,
        source: *mut obs_source_t,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    #[doc = " Save all the transform states for a current scene's sceneitems"]
    pub fn obs_scene_save_transform_states(
        scene: *mut obs_scene_t,
        all_items: bool,
    ) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Load all the transform states of sceneitems in that scene"]
    pub fn obs_scene_load_transform_states(state: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "  Gets a sceneitem's order in its scene"]
    pub fn obs_sceneitem_get_order_position(item: *mut obs_sceneitem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the scene parent associated with the scene item."]
    pub fn obs_sceneitem_get_scene(item: *const obs_sceneitem_t) -> *mut obs_scene_t;
}
extern "C" {
    #[doc = " Gets the source of a scene item."]
    pub fn obs_sceneitem_get_source(item: *const obs_sceneitem_t) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_sceneitem_select(item: *mut obs_sceneitem_t, select: bool);
}
extern "C" {
    pub fn obs_sceneitem_selected(item: *const obs_sceneitem_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_locked(item: *const obs_sceneitem_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_set_locked(item: *mut obs_sceneitem_t, lock: bool) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_set_pos(item: *mut obs_sceneitem_t, pos: *const vec2);
}
extern "C" {
    pub fn obs_sceneitem_set_rot(item: *mut obs_sceneitem_t, rot_deg: f32);
}
extern "C" {
    pub fn obs_sceneitem_set_scale(item: *mut obs_sceneitem_t, scale: *const vec2);
}
extern "C" {
    pub fn obs_sceneitem_set_alignment(item: *mut obs_sceneitem_t, alignment: u32);
}
extern "C" {
    pub fn obs_sceneitem_set_order(item: *mut obs_sceneitem_t, movement: obs_order_movement);
}
extern "C" {
    pub fn obs_sceneitem_set_order_position(
        item: *mut obs_sceneitem_t,
        position: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn obs_sceneitem_set_bounds_type(item: *mut obs_sceneitem_t, type_: obs_bounds_type);
}
extern "C" {
    pub fn obs_sceneitem_set_bounds_alignment(item: *mut obs_sceneitem_t, alignment: u32);
}
extern "C" {
    pub fn obs_sceneitem_set_bounds(item: *mut obs_sceneitem_t, bounds: *const vec2);
}
extern "C" {
    pub fn obs_sceneitem_get_id(item: *const obs_sceneitem_t) -> i64;
}
extern "C" {
    pub fn obs_sceneitem_get_pos(item: *const obs_sceneitem_t, pos: *mut vec2);
}
extern "C" {
    pub fn obs_sceneitem_get_rot(item: *const obs_sceneitem_t) -> f32;
}
extern "C" {
    pub fn obs_sceneitem_get_scale(item: *const obs_sceneitem_t, scale: *mut vec2);
}
extern "C" {
    pub fn obs_sceneitem_get_alignment(item: *const obs_sceneitem_t) -> u32;
}
extern "C" {
    pub fn obs_sceneitem_get_bounds_type(item: *const obs_sceneitem_t) -> obs_bounds_type;
}
extern "C" {
    pub fn obs_sceneitem_get_bounds_alignment(item: *const obs_sceneitem_t) -> u32;
}
extern "C" {
    pub fn obs_sceneitem_get_bounds(item: *const obs_sceneitem_t, bounds: *mut vec2);
}
extern "C" {
    pub fn obs_sceneitem_get_info(item: *const obs_sceneitem_t, info: *mut obs_transform_info);
}
extern "C" {
    pub fn obs_sceneitem_set_info(item: *mut obs_sceneitem_t, info: *const obs_transform_info);
}
extern "C" {
    pub fn obs_sceneitem_get_draw_transform(item: *const obs_sceneitem_t, transform: *mut matrix4);
}
extern "C" {
    pub fn obs_sceneitem_get_box_transform(item: *const obs_sceneitem_t, transform: *mut matrix4);
}
extern "C" {
    pub fn obs_sceneitem_get_box_scale(item: *const obs_sceneitem_t, scale: *mut vec2);
}
extern "C" {
    pub fn obs_sceneitem_visible(item: *const obs_sceneitem_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_set_visible(item: *mut obs_sceneitem_t, visible: bool) -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct obs_sceneitem_crop {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_obs_sceneitem_crop() {
    const UNINIT: ::std::mem::MaybeUninit<obs_sceneitem_crop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_sceneitem_crop>(),
        16usize,
        concat!("Size of: ", stringify!(obs_sceneitem_crop))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_sceneitem_crop>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_sceneitem_crop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_crop),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_crop),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_crop),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_crop),
            "::",
            stringify!(bottom)
        )
    );
}
extern "C" {
    pub fn obs_sceneitem_set_crop(item: *mut obs_sceneitem_t, crop: *const obs_sceneitem_crop);
}
extern "C" {
    pub fn obs_sceneitem_get_crop(item: *const obs_sceneitem_t, crop: *mut obs_sceneitem_crop);
}
extern "C" {
    pub fn obs_sceneitem_set_scale_filter(item: *mut obs_sceneitem_t, filter: obs_scale_type);
}
extern "C" {
    pub fn obs_sceneitem_get_scale_filter(item: *mut obs_sceneitem_t) -> obs_scale_type;
}
extern "C" {
    pub fn obs_sceneitem_set_blending_method(
        item: *mut obs_sceneitem_t,
        method: obs_blending_method,
    );
}
extern "C" {
    pub fn obs_sceneitem_get_blending_method(item: *mut obs_sceneitem_t) -> obs_blending_method;
}
extern "C" {
    pub fn obs_sceneitem_set_blending_mode(item: *mut obs_sceneitem_t, type_: obs_blending_type);
}
extern "C" {
    pub fn obs_sceneitem_get_blending_mode(item: *mut obs_sceneitem_t) -> obs_blending_type;
}
extern "C" {
    pub fn obs_sceneitem_force_update_transform(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_defer_update_begin(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_defer_update_end(item: *mut obs_sceneitem_t);
}
extern "C" {
    #[doc = " Gets private front-end settings data.  This data is saved/loaded\n automatically.  Returns an incremented reference."]
    pub fn obs_sceneitem_get_private_settings(item: *mut obs_sceneitem_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_scene_add_group(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_insert_group(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        items: *mut *mut obs_sceneitem_t,
        count: usize,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_add_group2(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        signal: bool,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_insert_group2(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        items: *mut *mut obs_sceneitem_t,
        count: usize,
        signal: bool,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_get_group(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_sceneitem_is_group(item: *mut obs_sceneitem_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_group_get_scene(group: *const obs_sceneitem_t) -> *mut obs_scene_t;
}
extern "C" {
    pub fn obs_sceneitem_group_ungroup(group: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_group_ungroup2(group: *mut obs_sceneitem_t, signal: bool);
}
extern "C" {
    pub fn obs_sceneitem_group_add_item(group: *mut obs_sceneitem_t, item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_group_remove_item(group: *mut obs_sceneitem_t, item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_get_group(
        scene: *mut obs_scene_t,
        item: *mut obs_sceneitem_t,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_source_is_group(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_scene_is_group(scene: *const obs_scene_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_group_enum_items(
        group: *mut obs_sceneitem_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut obs_scene_t,
                arg2: *mut obs_sceneitem_t,
                arg3: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Gets the group from its source, or NULL if not a group"]
    pub fn obs_group_from_source(source: *const obs_source_t) -> *mut obs_scene_t;
}
extern "C" {
    pub fn obs_sceneitem_defer_group_resize_begin(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_defer_group_resize_end(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_set_show_transition(
        item: *mut obs_sceneitem_t,
        transition: *mut obs_source_t,
    );
}
extern "C" {
    pub fn obs_sceneitem_set_show_transition_duration(item: *mut obs_sceneitem_t, duration_ms: u32);
}
extern "C" {
    pub fn obs_sceneitem_get_show_transition(item: *mut obs_sceneitem_t) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_sceneitem_get_show_transition_duration(item: *mut obs_sceneitem_t) -> u32;
}
extern "C" {
    pub fn obs_sceneitem_set_hide_transition(
        item: *mut obs_sceneitem_t,
        transition: *mut obs_source_t,
    );
}
extern "C" {
    pub fn obs_sceneitem_set_hide_transition_duration(item: *mut obs_sceneitem_t, duration_ms: u32);
}
extern "C" {
    pub fn obs_sceneitem_get_hide_transition(item: *mut obs_sceneitem_t) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_sceneitem_get_hide_transition_duration(item: *mut obs_sceneitem_t) -> u32;
}
extern "C" {
    pub fn obs_sceneitem_set_transition(
        item: *mut obs_sceneitem_t,
        show: bool,
        transition: *mut obs_source_t,
    );
}
extern "C" {
    pub fn obs_sceneitem_get_transition(
        item: *mut obs_sceneitem_t,
        show: bool,
    ) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_sceneitem_set_transition_duration(
        item: *mut obs_sceneitem_t,
        show: bool,
        duration_ms: u32,
    );
}
extern "C" {
    pub fn obs_sceneitem_get_transition_duration(item: *mut obs_sceneitem_t, show: bool) -> u32;
}
extern "C" {
    pub fn obs_sceneitem_do_transition(item: *mut obs_sceneitem_t, visible: bool);
}
extern "C" {
    pub fn obs_sceneitem_transition_load(
        item: *mut obs_scene_item,
        data: *mut obs_data_t,
        show: bool,
    );
}
extern "C" {
    pub fn obs_sceneitem_transition_save(item: *mut obs_scene_item, show: bool) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_scene_prune_sources(scene: *mut obs_scene_t);
}
extern "C" {
    pub fn obs_output_get_display_name(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates an output.\n\n   Outputs allow outputting to file, outputting to network, outputting to\n directshow, or other custom outputs."]
    pub fn obs_output_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_output_t;
}
extern "C" {
    #[doc = " Adds/releases a reference to an output.  When the last reference is\n released, the output is destroyed."]
    pub fn obs_output_addref(output: *mut obs_output_t);
}
extern "C" {
    pub fn obs_output_release(output: *mut obs_output_t);
}
extern "C" {
    pub fn obs_weak_output_addref(weak: *mut obs_weak_output_t);
}
extern "C" {
    pub fn obs_weak_output_release(weak: *mut obs_weak_output_t);
}
extern "C" {
    pub fn obs_output_get_ref(output: *mut obs_output_t) -> *mut obs_output_t;
}
extern "C" {
    pub fn obs_output_get_weak_output(output: *mut obs_output_t) -> *mut obs_weak_output_t;
}
extern "C" {
    pub fn obs_weak_output_get_output(weak: *mut obs_weak_output_t) -> *mut obs_output_t;
}
extern "C" {
    pub fn obs_weak_output_references_output(
        weak: *mut obs_weak_output_t,
        output: *mut obs_output_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_output_get_name(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Starts the output."]
    pub fn obs_output_start(output: *mut obs_output_t) -> bool;
}
extern "C" {
    #[doc = " Stops the output."]
    pub fn obs_output_stop(output: *mut obs_output_t);
}
extern "C" {
    #[doc = " Sets the current output delay, in seconds (if the output supports delay).\n\n If delay is currently active, it will set the delay value, but will not\n affect the current delay, it will only affect the next time the output is\n activated."]
    pub fn obs_output_set_delay(output: *mut obs_output_t, delay_sec: u32, flags: u32);
}
extern "C" {
    #[doc = " Gets the currently set delay value, in seconds."]
    pub fn obs_output_get_delay(output: *const obs_output_t) -> u32;
}
extern "C" {
    #[doc = " If delay is active, gets the currently active delay value, in seconds."]
    pub fn obs_output_get_active_delay(output: *const obs_output_t) -> u32;
}
extern "C" {
    #[doc = " Forces the output to stop.  Usually only used with delay."]
    pub fn obs_output_force_stop(output: *mut obs_output_t);
}
extern "C" {
    #[doc = " Returns whether the output is active"]
    pub fn obs_output_active(output: *const obs_output_t) -> bool;
}
extern "C" {
    #[doc = " Returns output capability flags"]
    pub fn obs_output_get_flags(output: *const obs_output_t) -> u32;
}
extern "C" {
    #[doc = " Returns output capability flags"]
    pub fn obs_get_output_flags(id: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    #[doc = " Gets the default settings for an output type"]
    pub fn obs_output_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_output_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Returns the property list of an existing output, if any.  Free with\n obs_properties_destroy"]
    pub fn obs_output_properties(output: *const obs_output_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Updates the settings for this output context"]
    pub fn obs_output_update(output: *mut obs_output_t, settings: *mut obs_data_t);
}
extern "C" {
    #[doc = " Specifies whether the output can be paused"]
    pub fn obs_output_can_pause(output: *const obs_output_t) -> bool;
}
extern "C" {
    #[doc = " Pauses the output (if the functionality is allowed by the output"]
    pub fn obs_output_pause(output: *mut obs_output_t, pause: bool) -> bool;
}
extern "C" {
    #[doc = " Returns whether output is paused"]
    pub fn obs_output_paused(output: *const obs_output_t) -> bool;
}
extern "C" {
    pub fn obs_output_get_settings(output: *const obs_output_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the signal handler for an output"]
    pub fn obs_output_get_signal_handler(output: *const obs_output_t) -> *mut signal_handler_t;
}
extern "C" {
    #[doc = " Returns the procedure handler for an output"]
    pub fn obs_output_get_proc_handler(output: *const obs_output_t) -> *mut proc_handler_t;
}
extern "C" {
    #[doc = " Sets the current audio/video media contexts associated with this output,\n required for non-encoded outputs.  Can be null."]
    pub fn obs_output_set_media(
        output: *mut obs_output_t,
        video: *mut video_t,
        audio: *mut audio_t,
    );
}
extern "C" {
    #[doc = " Returns the video media context associated with this output"]
    pub fn obs_output_video(output: *const obs_output_t) -> *mut video_t;
}
extern "C" {
    #[doc = " Returns the audio media context associated with this output"]
    pub fn obs_output_audio(output: *const obs_output_t) -> *mut audio_t;
}
extern "C" {
    #[doc = " Sets the current audio mixer for non-encoded outputs"]
    pub fn obs_output_set_mixer(output: *mut obs_output_t, mixer_idx: usize);
}
extern "C" {
    #[doc = " Gets the current audio mixer for non-encoded outputs"]
    pub fn obs_output_get_mixer(output: *const obs_output_t) -> usize;
}
extern "C" {
    #[doc = " Sets the current audio mixes (mask) for a non-encoded multi-track output"]
    pub fn obs_output_set_mixers(output: *mut obs_output_t, mixers: usize);
}
extern "C" {
    #[doc = " Gets the current audio mixes (mask) for a non-encoded multi-track output"]
    pub fn obs_output_get_mixers(output: *const obs_output_t) -> usize;
}
extern "C" {
    #[doc = " Sets the current video encoder associated with this output,\n required for encoded outputs"]
    pub fn obs_output_set_video_encoder(output: *mut obs_output_t, encoder: *mut obs_encoder_t);
}
extern "C" {
    #[doc = " Sets the current audio encoder associated with this output,\n required for encoded outputs.\n\n The idx parameter specifies the audio encoder index to set the encoder to.\n Only used with outputs that have multiple audio outputs (RTMP typically),\n otherwise the parameter is ignored."]
    pub fn obs_output_set_audio_encoder(
        output: *mut obs_output_t,
        encoder: *mut obs_encoder_t,
        idx: usize,
    );
}
extern "C" {
    #[doc = " Returns the current video encoder associated with this output"]
    pub fn obs_output_get_video_encoder(output: *const obs_output_t) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Returns the current audio encoder associated with this output\n\n The idx parameter specifies the audio encoder index.  Only used with\n outputs that have multiple audio outputs, otherwise the parameter is\n ignored."]
    pub fn obs_output_get_audio_encoder(
        output: *const obs_output_t,
        idx: usize,
    ) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Sets the current service associated with this output."]
    pub fn obs_output_set_service(output: *mut obs_output_t, service: *mut obs_service_t);
}
extern "C" {
    #[doc = " Gets the current service associated with this output."]
    pub fn obs_output_get_service(output: *const obs_output_t) -> *mut obs_service_t;
}
extern "C" {
    #[doc = " Sets the reconnect settings.  Set retry_count to 0 to disable reconnecting."]
    pub fn obs_output_set_reconnect_settings(
        output: *mut obs_output_t,
        retry_count: ::std::os::raw::c_int,
        retry_sec: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn obs_output_get_total_bytes(output: *const obs_output_t) -> u64;
}
extern "C" {
    pub fn obs_output_get_frames_dropped(output: *const obs_output_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_output_get_total_frames(output: *const obs_output_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the preferred scaled resolution for this output.  Set width and height\n to 0 to disable scaling.\n\n If this output uses an encoder, it will call obs_encoder_set_scaled_size on\n the encoder before the stream is started.  If the encoder is already active,\n then this function will trigger a warning and do nothing."]
    pub fn obs_output_set_preferred_size(output: *mut obs_output_t, width: u32, height: u32);
}
extern "C" {
    #[doc = " For video outputs, returns the width of the encoded image"]
    pub fn obs_output_get_width(output: *const obs_output_t) -> u32;
}
extern "C" {
    #[doc = " For video outputs, returns the height of the encoded image"]
    pub fn obs_output_get_height(output: *const obs_output_t) -> u32;
}
extern "C" {
    pub fn obs_output_get_id(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_caption(output: *mut obs_output_t, captions: *const obs_source_cea_708);
}
extern "C" {
    pub fn obs_output_output_caption_text1(
        output: *mut obs_output_t,
        text: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_output_output_caption_text2(
        output: *mut obs_output_t,
        text: *const ::std::os::raw::c_char,
        display_duration: f64,
    );
}
extern "C" {
    pub fn obs_output_get_congestion(output: *mut obs_output_t) -> f32;
}
extern "C" {
    pub fn obs_output_get_connect_time_ms(output: *mut obs_output_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_output_reconnecting(output: *const obs_output_t) -> bool;
}
extern "C" {
    #[doc = " Pass a string of the last output error, for UI use"]
    pub fn obs_output_set_last_error(
        output: *mut obs_output_t,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_output_get_last_error(output: *mut obs_output_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_get_supported_video_codecs(
        output: *const obs_output_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_get_supported_audio_codecs(
        output: *const obs_output_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_get_protocols(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_is_output_protocol_registered(protocol: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_enum_output_protocols(
        idx: usize,
        protocol: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_enum_output_types_with_protocol(
        protocol: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        enum_cb: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                id: *const ::std::os::raw::c_char,
            ) -> bool,
        >,
    );
}
extern "C" {
    pub fn obs_get_output_supported_video_codecs(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_get_output_supported_audio_codecs(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_get_type_data(output: *mut obs_output_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Gets the video conversion info.  Used only for raw output"]
    pub fn obs_output_get_video_conversion(output: *mut obs_output_t) -> *const video_scale_info;
}
extern "C" {
    #[doc = " Optionally sets the video conversion info.  Used only for raw output"]
    pub fn obs_output_set_video_conversion(
        output: *mut obs_output_t,
        conversion: *const video_scale_info,
    );
}
extern "C" {
    #[doc = " Optionally sets the audio conversion info.  Used only for raw output"]
    pub fn obs_output_set_audio_conversion(
        output: *mut obs_output_t,
        conversion: *const audio_convert_info,
    );
}
extern "C" {
    #[doc = " Returns whether data capture can begin with the specified flags"]
    pub fn obs_output_can_begin_data_capture(output: *const obs_output_t, flags: u32) -> bool;
}
extern "C" {
    #[doc = " Initializes encoders (if any)"]
    pub fn obs_output_initialize_encoders(output: *mut obs_output_t, flags: u32) -> bool;
}
extern "C" {
    #[doc = " Begins data capture from media/encoders.\n\n @param  output  Output context\n @param  flags   Set this to 0 to use default output flags set in the\n                 obs_output_info structure, otherwise set to a either\n                 OBS_OUTPUT_VIDEO or OBS_OUTPUT_AUDIO to specify whether to\n                 connect audio or video.  This is useful for things like\n                 ffmpeg which may or may not always want to use both audio\n                 and video.\n @return         true if successful, false otherwise."]
    pub fn obs_output_begin_data_capture(output: *mut obs_output_t, flags: u32) -> bool;
}
extern "C" {
    #[doc = " Ends data capture from media/encoders"]
    pub fn obs_output_end_data_capture(output: *mut obs_output_t);
}
extern "C" {
    #[doc = " Signals that the output has stopped itself.\n\n @param  output  Output context\n @param  code    Error code (or OBS_OUTPUT_SUCCESS if not an error)"]
    pub fn obs_output_signal_stop(output: *mut obs_output_t, code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn obs_output_get_pause_offset(output: *mut obs_output_t) -> u64;
}
extern "C" {
    pub fn obs_encoder_get_display_name(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a video encoder context\n\n @param  id        Video encoder ID\n @param  name      Name to assign to this context\n @param  settings  Settings\n @return           The video encoder context, or NULL if failed or not found."]
    pub fn obs_video_encoder_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Creates an audio encoder context\n\n @param  id        Audio Encoder ID\n @param  name      Name to assign to this context\n @param  settings  Settings\n @param  mixer_idx Index of the mixer to use for this audio encoder\n @return           The video encoder context, or NULL if failed or not found."]
    pub fn obs_audio_encoder_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        mixer_idx: usize,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Adds/releases a reference to an encoder.  When the last reference is\n released, the encoder is destroyed."]
    pub fn obs_encoder_addref(encoder: *mut obs_encoder_t);
}
extern "C" {
    pub fn obs_encoder_release(encoder: *mut obs_encoder_t);
}
extern "C" {
    pub fn obs_weak_encoder_addref(weak: *mut obs_weak_encoder_t);
}
extern "C" {
    pub fn obs_weak_encoder_release(weak: *mut obs_weak_encoder_t);
}
extern "C" {
    pub fn obs_encoder_get_ref(encoder: *mut obs_encoder_t) -> *mut obs_encoder_t;
}
extern "C" {
    pub fn obs_encoder_get_weak_encoder(encoder: *mut obs_encoder_t) -> *mut obs_weak_encoder_t;
}
extern "C" {
    pub fn obs_weak_encoder_get_encoder(weak: *mut obs_weak_encoder_t) -> *mut obs_encoder_t;
}
extern "C" {
    pub fn obs_weak_encoder_references_encoder(
        weak: *mut obs_weak_encoder_t,
        encoder: *mut obs_encoder_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_encoder_set_name(encoder: *mut obs_encoder_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_encoder_get_name(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the codec of an encoder by the id"]
    pub fn obs_get_encoder_codec(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the type of an encoder by the id"]
    pub fn obs_get_encoder_type(id: *const ::std::os::raw::c_char) -> obs_encoder_type;
}
extern "C" {
    #[doc = " Returns the codec of the encoder"]
    pub fn obs_encoder_get_codec(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the type of an encoder"]
    pub fn obs_encoder_get_type(encoder: *const obs_encoder_t) -> obs_encoder_type;
}
extern "C" {
    #[doc = " Sets the scaled resolution for a video encoder.  Set width and height to 0\n to disable scaling.  If the encoder is active, this function will trigger\n a warning, and do nothing."]
    pub fn obs_encoder_set_scaled_size(encoder: *mut obs_encoder_t, width: u32, height: u32);
}
extern "C" {
    #[doc = " For video encoders, returns true if pre-encode scaling is enabled"]
    pub fn obs_encoder_scaling_enabled(encoder: *const obs_encoder_t) -> bool;
}
extern "C" {
    #[doc = " For video encoders, returns the width of the encoded image"]
    pub fn obs_encoder_get_width(encoder: *const obs_encoder_t) -> u32;
}
extern "C" {
    #[doc = " For video encoders, returns the height of the encoded image"]
    pub fn obs_encoder_get_height(encoder: *const obs_encoder_t) -> u32;
}
extern "C" {
    #[doc = " For audio encoders, returns the sample rate of the audio"]
    pub fn obs_encoder_get_sample_rate(encoder: *const obs_encoder_t) -> u32;
}
extern "C" {
    #[doc = " For audio encoders, returns the frame size of the audio packet"]
    pub fn obs_encoder_get_frame_size(encoder: *const obs_encoder_t) -> usize;
}
extern "C" {
    #[doc = " Sets the preferred video format for a video encoder.  If the encoder can use\n the format specified, it will force a conversion to that format if the\n obs output format does not match the preferred format.\n\n If the format is set to VIDEO_FORMAT_NONE, will revert to the default\n functionality of converting only when absolutely necessary."]
    pub fn obs_encoder_set_preferred_video_format(
        encoder: *mut obs_encoder_t,
        format: video_format,
    );
}
extern "C" {
    pub fn obs_encoder_get_preferred_video_format(encoder: *const obs_encoder_t) -> video_format;
}
extern "C" {
    #[doc = " Gets the default settings for an encoder type"]
    pub fn obs_encoder_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_encoder_get_defaults(encoder: *const obs_encoder_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_encoder_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Returns the property list of an existing encoder, if any.  Free with\n obs_properties_destroy"]
    pub fn obs_encoder_properties(encoder: *const obs_encoder_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Updates the settings of the encoder context.  Usually used for changing\n bitrate while active"]
    pub fn obs_encoder_update(encoder: *mut obs_encoder_t, settings: *mut obs_data_t);
}
extern "C" {
    #[doc = " Gets extra data (headers) associated with this context"]
    pub fn obs_encoder_get_extra_data(
        encoder: *const obs_encoder_t,
        extra_data: *mut *mut u8,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the current settings for this encoder"]
    pub fn obs_encoder_get_settings(encoder: *const obs_encoder_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Sets the video output context to be used with this encoder"]
    pub fn obs_encoder_set_video(encoder: *mut obs_encoder_t, video: *mut video_t);
}
extern "C" {
    #[doc = " Sets the audio output context to be used with this encoder"]
    pub fn obs_encoder_set_audio(encoder: *mut obs_encoder_t, audio: *mut audio_t);
}
extern "C" {
    #[doc = " Returns the video output context used with this encoder, or NULL if not\n a video context"]
    pub fn obs_encoder_video(encoder: *const obs_encoder_t) -> *mut video_t;
}
extern "C" {
    #[doc = " Returns the audio output context used with this encoder, or NULL if not\n a audio context"]
    pub fn obs_encoder_audio(encoder: *const obs_encoder_t) -> *mut audio_t;
}
extern "C" {
    #[doc = " Returns true if encoder is active, false otherwise"]
    pub fn obs_encoder_active(encoder: *const obs_encoder_t) -> bool;
}
extern "C" {
    pub fn obs_encoder_get_type_data(encoder: *mut obs_encoder_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_encoder_get_id(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_get_encoder_caps(encoder_id: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn obs_encoder_get_caps(encoder: *const obs_encoder_t) -> u32;
}
extern "C" {
    #[doc = " Duplicates an encoder packet"]
    pub fn obs_duplicate_encoder_packet(dst: *mut encoder_packet, src: *const encoder_packet);
}
extern "C" {
    pub fn obs_free_encoder_packet(packet: *mut encoder_packet);
}
extern "C" {
    pub fn obs_encoder_packet_ref(dst: *mut encoder_packet, src: *mut encoder_packet);
}
extern "C" {
    pub fn obs_encoder_packet_release(packet: *mut encoder_packet);
}
extern "C" {
    pub fn obs_encoder_create_rerouted(
        encoder: *mut obs_encoder_t,
        reroute_id: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns whether encoder is paused"]
    pub fn obs_encoder_paused(output: *const obs_encoder_t) -> bool;
}
extern "C" {
    pub fn obs_encoder_get_last_error(encoder: *mut obs_encoder_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_encoder_set_last_error(
        encoder: *mut obs_encoder_t,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_encoder_get_pause_offset(encoder: *const obs_encoder_t) -> u64;
}
extern "C" {
    pub fn obs_service_get_display_name(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_service_t;
}
extern "C" {
    pub fn obs_service_create_private(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
    ) -> *mut obs_service_t;
}
extern "C" {
    #[doc = " Adds/releases a reference to a service.  When the last reference is\n released, the service is destroyed."]
    pub fn obs_service_addref(service: *mut obs_service_t);
}
extern "C" {
    pub fn obs_service_release(service: *mut obs_service_t);
}
extern "C" {
    pub fn obs_weak_service_addref(weak: *mut obs_weak_service_t);
}
extern "C" {
    pub fn obs_weak_service_release(weak: *mut obs_weak_service_t);
}
extern "C" {
    pub fn obs_service_get_ref(service: *mut obs_service_t) -> *mut obs_service_t;
}
extern "C" {
    pub fn obs_service_get_weak_service(service: *mut obs_service_t) -> *mut obs_weak_service_t;
}
extern "C" {
    pub fn obs_weak_service_get_service(weak: *mut obs_weak_service_t) -> *mut obs_service_t;
}
extern "C" {
    pub fn obs_weak_service_references_service(
        weak: *mut obs_weak_service_t,
        service: *mut obs_service_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_service_get_name(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the default settings for a service"]
    pub fn obs_service_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_service_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Returns the property list of an existing service context, if any.  Free with\n obs_properties_destroy"]
    pub fn obs_service_properties(service: *const obs_service_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Gets the service type"]
    pub fn obs_service_get_type(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Updates the settings of the service context"]
    pub fn obs_service_update(service: *mut obs_service_t, settings: *mut obs_data_t);
}
extern "C" {
    #[doc = " Returns the current settings for this service"]
    pub fn obs_service_get_settings(service: *const obs_service_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the URL for this service context"]
    pub fn obs_service_get_url(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the stream key (if any) for this service context"]
    pub fn obs_service_get_key(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the username (if any) for this service context"]
    pub fn obs_service_get_username(service: *const obs_service_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the password (if any) for this service context"]
    pub fn obs_service_get_password(service: *const obs_service_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Applies service-specific video encoder settings.\n\n @param  video_encoder_settings  Video encoder settings.  Optional.\n @param  audio_encoder_settings  Audio encoder settings.  Optional."]
    pub fn obs_service_apply_encoder_settings(
        service: *mut obs_service_t,
        video_encoder_settings: *mut obs_data_t,
        audio_encoder_settings: *mut obs_data_t,
    );
}
extern "C" {
    pub fn obs_service_get_type_data(service: *mut obs_service_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_service_get_id(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_get_supported_resolutions(
        service: *const obs_service_t,
        resolutions: *mut *mut obs_service_resolution,
        count: *mut usize,
    );
}
extern "C" {
    pub fn obs_service_get_max_fps(service: *const obs_service_t, fps: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn obs_service_get_max_bitrate(
        service: *const obs_service_t,
        video_bitrate: *mut ::std::os::raw::c_int,
        audio_bitrate: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn obs_service_get_supported_video_codecs(
        service: *const obs_service_t,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_get_supported_audio_codecs(
        service: *const obs_service_t,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_get_output_type(
        service: *const obs_service_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the protocol for this service context"]
    pub fn obs_service_get_protocol(service: *const obs_service_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_get_preferred_output_type(
        service: *const obs_service_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_get_connect_info(
        service: *const obs_service_t,
        type_: u32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_can_try_to_connect(service: *const obs_service_t) -> bool;
}
extern "C" {
    pub fn obs_source_frame_init(
        frame: *mut obs_source_frame,
        format: video_format,
        width: u32,
        height: u32,
    );
}
extern "C" {
    pub fn obs_source_frame_copy(dst: *mut obs_source_frame, src: *const obs_source_frame);
}
extern "C" {
    pub fn obs_source_get_icon_type(id: *const ::std::os::raw::c_char) -> obs_icon_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_data {
    _unused: [u8; 0],
}
pub type config_t = config_data;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_STREAMING_STARTING: obs_frontend_event = 0;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_STREAMING_STARTED: obs_frontend_event = 1;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_STREAMING_STOPPING: obs_frontend_event = 2;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_STREAMING_STOPPED: obs_frontend_event = 3;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_RECORDING_STARTING: obs_frontend_event = 4;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_RECORDING_STARTED: obs_frontend_event = 5;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_RECORDING_STOPPING: obs_frontend_event = 6;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_RECORDING_STOPPED: obs_frontend_event = 7;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCENE_CHANGED: obs_frontend_event = 8;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCENE_LIST_CHANGED: obs_frontend_event = 9;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_TRANSITION_CHANGED: obs_frontend_event = 10;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_TRANSITION_STOPPED: obs_frontend_event = 11;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_TRANSITION_LIST_CHANGED: obs_frontend_event = 12;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCENE_COLLECTION_CHANGED: obs_frontend_event = 13;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCENE_COLLECTION_LIST_CHANGED: obs_frontend_event =
    14;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_PROFILE_CHANGED: obs_frontend_event = 15;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_PROFILE_LIST_CHANGED: obs_frontend_event = 16;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_EXIT: obs_frontend_event = 17;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_REPLAY_BUFFER_STARTING: obs_frontend_event = 18;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_REPLAY_BUFFER_STARTED: obs_frontend_event = 19;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_REPLAY_BUFFER_STOPPING: obs_frontend_event = 20;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_REPLAY_BUFFER_STOPPED: obs_frontend_event = 21;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_STUDIO_MODE_ENABLED: obs_frontend_event = 22;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_STUDIO_MODE_DISABLED: obs_frontend_event = 23;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_PREVIEW_SCENE_CHANGED: obs_frontend_event = 24;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCENE_COLLECTION_CLEANUP: obs_frontend_event = 25;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_FINISHED_LOADING: obs_frontend_event = 26;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_RECORDING_PAUSED: obs_frontend_event = 27;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_RECORDING_UNPAUSED: obs_frontend_event = 28;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_TRANSITION_DURATION_CHANGED: obs_frontend_event =
    29;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_REPLAY_BUFFER_SAVED: obs_frontend_event = 30;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_VIRTUALCAM_STARTED: obs_frontend_event = 31;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_VIRTUALCAM_STOPPED: obs_frontend_event = 32;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_TBAR_VALUE_CHANGED: obs_frontend_event = 33;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCENE_COLLECTION_CHANGING: obs_frontend_event = 34;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_PROFILE_CHANGING: obs_frontend_event = 35;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCRIPTING_SHUTDOWN: obs_frontend_event = 36;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_PROFILE_RENAMED: obs_frontend_event = 37;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCENE_COLLECTION_RENAMED: obs_frontend_event = 38;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_THEME_CHANGED: obs_frontend_event = 39;
pub const obs_frontend_event_OBS_FRONTEND_EVENT_SCREENSHOT_TAKEN: obs_frontend_event = 40;
pub type obs_frontend_event = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obs_frontend_source_list {
    pub sources: obs_frontend_source_list__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union obs_frontend_source_list__bindgen_ty_1 {
    pub da: darray,
    pub __bindgen_anon_1: obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1 {
    pub array: *mut *mut obs_source_t,
    pub num: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(capacity)
        )
    );
}
impl Default for obs_frontend_source_list__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_obs_frontend_source_list__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<obs_frontend_source_list__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_frontend_source_list__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(obs_frontend_source_list__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<obs_frontend_source_list__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(obs_frontend_source_list__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).da) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_frontend_source_list__bindgen_ty_1),
            "::",
            stringify!(da)
        )
    );
}
impl Default for obs_frontend_source_list__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_obs_frontend_source_list() {
    const UNINIT: ::std::mem::MaybeUninit<obs_frontend_source_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obs_frontend_source_list>(),
        24usize,
        concat!("Size of: ", stringify!(obs_frontend_source_list))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_frontend_source_list>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_frontend_source_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sources) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_frontend_source_list),
            "::",
            stringify!(sources)
        )
    );
}
impl Default for obs_frontend_source_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn obs_frontend_get_main_window() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_frontend_get_main_window_handle() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_frontend_get_system_tray() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_frontend_get_scene_names() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_get_scenes(sources: *mut obs_frontend_source_list);
}
extern "C" {
    pub fn obs_frontend_get_current_scene() -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_frontend_set_current_scene(scene: *mut obs_source_t);
}
extern "C" {
    pub fn obs_frontend_get_transitions(sources: *mut obs_frontend_source_list);
}
extern "C" {
    pub fn obs_frontend_get_current_transition() -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_frontend_set_current_transition(transition: *mut obs_source_t);
}
extern "C" {
    pub fn obs_frontend_get_transition_duration() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_frontend_set_transition_duration(duration: ::std::os::raw::c_int);
}
extern "C" {
    pub fn obs_frontend_release_tbar();
}
extern "C" {
    pub fn obs_frontend_set_tbar_position(position: ::std::os::raw::c_int);
}
extern "C" {
    pub fn obs_frontend_get_tbar_position() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_frontend_get_scene_collections() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_get_current_scene_collection() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_set_current_scene_collection(collection: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_frontend_add_scene_collection(name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_frontend_get_profiles() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_get_current_profile() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_get_current_profile_path() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_set_current_profile(profile: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_frontend_create_profile(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_frontend_duplicate_profile(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_frontend_delete_profile(profile: *const ::std::os::raw::c_char);
}
pub type obs_frontend_cb =
    ::std::option::Option<unsafe extern "C" fn(private_data: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn obs_frontend_add_tools_menu_qaction(
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_frontend_add_tools_menu_item(
        name: *const ::std::os::raw::c_char,
        callback: obs_frontend_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_frontend_add_dock(dock: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
pub type obs_frontend_event_cb = ::std::option::Option<
    unsafe extern "C" fn(event: obs_frontend_event, private_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn obs_frontend_add_event_callback(
        callback: obs_frontend_event_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_frontend_remove_event_callback(
        callback: obs_frontend_event_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
pub type obs_frontend_save_cb = ::std::option::Option<
    unsafe extern "C" fn(
        save_data: *mut obs_data_t,
        saving: bool,
        private_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn obs_frontend_add_save_callback(
        callback: obs_frontend_save_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_frontend_remove_save_callback(
        callback: obs_frontend_save_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_frontend_add_preload_callback(
        callback: obs_frontend_save_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_frontend_remove_preload_callback(
        callback: obs_frontend_save_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
pub type obs_frontend_translate_ui_cb = ::std::option::Option<
    unsafe extern "C" fn(
        text: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> bool,
>;
extern "C" {
    pub fn obs_frontend_push_ui_translation(translate: obs_frontend_translate_ui_cb);
}
extern "C" {
    pub fn obs_frontend_pop_ui_translation();
}
extern "C" {
    #[doc = "!SWIG"]
    pub fn obs_frontend_streaming_start();
}
extern "C" {
    pub fn obs_frontend_streaming_stop();
}
extern "C" {
    pub fn obs_frontend_streaming_active() -> bool;
}
extern "C" {
    pub fn obs_frontend_recording_start();
}
extern "C" {
    pub fn obs_frontend_recording_stop();
}
extern "C" {
    pub fn obs_frontend_recording_active() -> bool;
}
extern "C" {
    pub fn obs_frontend_recording_pause(pause: bool);
}
extern "C" {
    pub fn obs_frontend_recording_paused() -> bool;
}
extern "C" {
    pub fn obs_frontend_recording_split_file() -> bool;
}
extern "C" {
    pub fn obs_frontend_replay_buffer_start();
}
extern "C" {
    pub fn obs_frontend_replay_buffer_save();
}
extern "C" {
    pub fn obs_frontend_replay_buffer_stop();
}
extern "C" {
    pub fn obs_frontend_replay_buffer_active() -> bool;
}
extern "C" {
    pub fn obs_frontend_open_projector(
        type_: *const ::std::os::raw::c_char,
        monitor: ::std::os::raw::c_int,
        geometry: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_frontend_save();
}
extern "C" {
    pub fn obs_frontend_defer_save_begin();
}
extern "C" {
    pub fn obs_frontend_defer_save_end();
}
extern "C" {
    pub fn obs_frontend_get_streaming_output() -> *mut obs_output_t;
}
extern "C" {
    pub fn obs_frontend_get_recording_output() -> *mut obs_output_t;
}
extern "C" {
    pub fn obs_frontend_get_replay_buffer_output() -> *mut obs_output_t;
}
extern "C" {
    pub fn obs_frontend_get_profile_config() -> *mut config_t;
}
extern "C" {
    pub fn obs_frontend_get_global_config() -> *mut config_t;
}
extern "C" {
    pub fn obs_frontend_set_streaming_service(service: *mut obs_service_t);
}
extern "C" {
    pub fn obs_frontend_get_streaming_service() -> *mut obs_service_t;
}
extern "C" {
    pub fn obs_frontend_save_streaming_service();
}
extern "C" {
    pub fn obs_frontend_preview_program_mode_active() -> bool;
}
extern "C" {
    pub fn obs_frontend_set_preview_program_mode(enable: bool);
}
extern "C" {
    pub fn obs_frontend_preview_program_trigger_transition();
}
extern "C" {
    pub fn obs_frontend_set_preview_enabled(enable: bool);
}
extern "C" {
    pub fn obs_frontend_preview_enabled() -> bool;
}
extern "C" {
    pub fn obs_frontend_get_current_preview_scene() -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_frontend_set_current_preview_scene(scene: *mut obs_source_t);
}
extern "C" {
    pub fn obs_frontend_take_screenshot();
}
extern "C" {
    pub fn obs_frontend_take_source_screenshot(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_frontend_get_virtualcam_output() -> *mut obs_output_t;
}
extern "C" {
    pub fn obs_frontend_start_virtualcam();
}
extern "C" {
    pub fn obs_frontend_stop_virtualcam();
}
extern "C" {
    pub fn obs_frontend_virtualcam_active() -> bool;
}
extern "C" {
    pub fn obs_frontend_reset_video();
}
extern "C" {
    pub fn obs_frontend_open_source_properties(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_frontend_open_source_filters(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_frontend_open_source_interaction(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_frontend_open_sceneitem_edit_transform(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_frontend_get_current_record_output_path() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_get_locale_string(
        string: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_is_theme_dark() -> bool;
}
extern "C" {
    pub fn obs_frontend_get_last_recording() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_get_last_screenshot() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_frontend_get_last_replay() -> *mut ::std::os::raw::c_char;
}
pub type undo_redo_cb =
    ::std::option::Option<unsafe extern "C" fn(data: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn obs_frontend_add_undo_redo_action(
        name: *const ::std::os::raw::c_char,
        undo: undo_redo_cb,
        redo: undo_redo_cb,
        undo_data: *const ::std::os::raw::c_char,
        redo_data: *const ::std::os::raw::c_char,
        repeatable: bool,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
