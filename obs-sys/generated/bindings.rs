/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const KBC_ESCAPE: u32 = 0;
pub const KBC_1: u32 = 1;
pub const KBC_2: u32 = 2;
pub const KBC_3: u32 = 3;
pub const KBC_4: u32 = 4;
pub const KBC_5: u32 = 5;
pub const KBC_6: u32 = 6;
pub const KBC_7: u32 = 7;
pub const KBC_8: u32 = 8;
pub const KBC_9: u32 = 9;
pub const KBC_0: u32 = 10;
pub const KBC_MINUS: u32 = 11;
pub const KBC_EQUALS: u32 = 12;
pub const KBC_BACK: u32 = 13;
pub const KBC_TAB: u32 = 14;
pub const KBC_Q: u32 = 15;
pub const KBC_W: u32 = 16;
pub const KBC_E: u32 = 17;
pub const KBC_R: u32 = 18;
pub const KBC_T: u32 = 19;
pub const KBC_Y: u32 = 20;
pub const KBC_U: u32 = 21;
pub const KBC_I: u32 = 22;
pub const KBC_O: u32 = 23;
pub const KBC_P: u32 = 24;
pub const KBC_LBRACKET: u32 = 25;
pub const KBC_RBRACKET: u32 = 26;
pub const KBC_RETURN: u32 = 27;
pub const KBC_LCONTROL: u32 = 28;
pub const KBC_A: u32 = 29;
pub const KBC_S: u32 = 30;
pub const KBC_D: u32 = 31;
pub const KBC_F: u32 = 32;
pub const KBC_G: u32 = 33;
pub const KBC_H: u32 = 34;
pub const KBC_J: u32 = 35;
pub const KBC_K: u32 = 36;
pub const KBC_L: u32 = 37;
pub const KBC_SEMICOLON: u32 = 38;
pub const KBC_APOSTROPHE: u32 = 39;
pub const KBC_TILDE: u32 = 40;
pub const KBC_LSHIFT: u32 = 41;
pub const KBC_BACKSLASH: u32 = 42;
pub const KBC_Z: u32 = 43;
pub const KBC_X: u32 = 44;
pub const KBC_C: u32 = 45;
pub const KBC_V: u32 = 46;
pub const KBC_B: u32 = 47;
pub const KBC_N: u32 = 48;
pub const KBC_M: u32 = 49;
pub const KBC_COMMA: u32 = 50;
pub const KBC_PERIOD: u32 = 51;
pub const KBC_SLASH: u32 = 52;
pub const KBC_RSHIFT: u32 = 53;
pub const KBC_MULTIPLY: u32 = 54;
pub const KBC_LALT: u32 = 55;
pub const KBC_SPACE: u32 = 56;
pub const KBC_CAPSLOCK: u32 = 57;
pub const KBC_F1: u32 = 58;
pub const KBC_F2: u32 = 59;
pub const KBC_F3: u32 = 60;
pub const KBC_F4: u32 = 61;
pub const KBC_F5: u32 = 62;
pub const KBC_F6: u32 = 63;
pub const KBC_F7: u32 = 64;
pub const KBC_F8: u32 = 65;
pub const KBC_F9: u32 = 66;
pub const KBC_F10: u32 = 67;
pub const KBC_NUMLOCK: u32 = 68;
pub const KBC_SCROLLLOCK: u32 = 69;
pub const KBC_NUMPAD7: u32 = 70;
pub const KBC_NUMPAD8: u32 = 71;
pub const KBC_NUMPAD9: u32 = 72;
pub const KBC_SUBTRACT: u32 = 73;
pub const KBC_NUMPAD4: u32 = 74;
pub const KBC_NUMPAD5: u32 = 75;
pub const KBC_NUMPAD6: u32 = 76;
pub const KBC_ADD: u32 = 77;
pub const KBC_NUMPAD1: u32 = 78;
pub const KBC_NUMPAD2: u32 = 79;
pub const KBC_NUMPAD3: u32 = 80;
pub const KBC_NUMPAD0: u32 = 81;
pub const KBC_DECIMAL: u32 = 82;
pub const KBC_F11: u32 = 83;
pub const KBC_F12: u32 = 84;
pub const KBC_NUMPADENTER: u32 = 85;
pub const KBC_RCONTROL: u32 = 86;
pub const KBC_DIVIDE: u32 = 87;
pub const KBC_SYSRQ: u32 = 88;
pub const KBC_RALT: u32 = 89;
pub const KBC_PAUSE: u32 = 90;
pub const KBC_HOME: u32 = 91;
pub const KBC_UP: u32 = 92;
pub const KBC_PAGEDOWN: u32 = 93;
pub const KBC_LEFT: u32 = 94;
pub const KBC_RIGHT: u32 = 95;
pub const KBC_END: u32 = 96;
pub const KBC_DOWN: u32 = 97;
pub const KBC_PAGEUP: u32 = 98;
pub const KBC_INSERT: u32 = 99;
pub const KBC_DELETE: u32 = 100;
pub const MOUSE_LEFTBUTTON: u32 = 101;
pub const MOUSE_MIDDLEBUTTON: u32 = 102;
pub const MOUSE_RIGHTBUTTON: u32 = 103;
pub const MOUSE_WHEEL: u32 = 104;
pub const MOUSE_MOVE: u32 = 105;
pub const KBC_CONTROL: u32 = 4294967294;
pub const KBC_ALT: u32 = 4294967293;
pub const KBC_SHIFT: u32 = 4294967292;
pub const STATE_LBUTTONDOWN: u32 = 1;
pub const STATE_RBUTTONDOWN: u32 = 2;
pub const STATE_MBUTTONDOWN: u32 = 4;
pub const STATE_X4BUTTONDOWN: u32 = 8;
pub const STATE_X5BUTTONDOWN: u32 = 16;
pub const GS_MAX_TEXTURES: u32 = 8;
pub const GS_BUILD_MIPMAPS: u32 = 1;
pub const GS_DYNAMIC: u32 = 2;
pub const GS_RENDER_TARGET: u32 = 4;
pub const GS_GL_DUMMYTEX: u32 = 8;
pub const GS_DUP_BUFFER: u32 = 16;
pub const GS_SHARED_TEX: u32 = 32;
pub const GS_SHARED_KM_TEX: u32 = 64;
pub const GS_SUCCESS: u32 = 0;
pub const GS_ERROR_FAIL: i32 = -1;
pub const GS_ERROR_MODULE_NOT_FOUND: i32 = -2;
pub const GS_ERROR_NOT_SUPPORTED: i32 = -3;
pub const GS_DEVICE_OPENGL: u32 = 1;
pub const GS_DEVICE_DIRECT3D_11: u32 = 2;
pub const GS_FLIP_U: u32 = 1;
pub const GS_FLIP_V: u32 = 2;
pub const GS_CLEAR_COLOR: u32 = 1;
pub const GS_CLEAR_DEPTH: u32 = 2;
pub const GS_CLEAR_STENCIL: u32 = 4;
pub const GS_USE_DEBUG_MARKERS: u32 = 0;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const LARGE_EPSILON: f64 = 0.01;
pub const EPSILON: f64 = 0.0001;
pub const TINY_EPSILON: f64 = 0.00001;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const MAX_AV_PLANES: u32 = 8;
pub const MAX_AUDIO_MIXES: u32 = 6;
pub const MAX_AUDIO_CHANNELS: u32 = 8;
pub const AUDIO_OUTPUT_FRAMES: u32 = 1024;
pub const AUDIO_OUTPUT_SUCCESS: u32 = 0;
pub const AUDIO_OUTPUT_INVALIDPARAM: i32 = -1;
pub const AUDIO_OUTPUT_FAIL: i32 = -2;
pub const VIDEO_OUTPUT_SUCCESS: u32 = 0;
pub const VIDEO_OUTPUT_INVALIDPARAM: i32 = -1;
pub const VIDEO_OUTPUT_FAIL: i32 = -2;
pub const CALL_PARAM_IN: u32 = 1;
pub const CALL_PARAM_OUT: u32 = 2;
pub const LIBOBS_API_MAJOR_VER: u32 = 25;
pub const LIBOBS_API_MINOR_VER: u32 = 0;
pub const LIBOBS_API_PATCH_VER: u32 = 8;
pub const OBS_VERSION: &'static [u8; 8usize] = b"unknown\0";
pub const OBS_DATA_PATH: &'static [u8; 11usize] = b"../../data\0";
pub const OBS_INSTALL_PREFIX: &'static [u8; 1usize] = b"\0";
pub const OBS_PLUGIN_DESTINATION: &'static [u8; 12usize] = b"obs-plugins\0";
pub const OBS_RELATIVE_PREFIX: &'static [u8; 7usize] = b"../../\0";
pub const OBS_RELEASE_CANDIDATE_MAJOR: u32 = 0;
pub const OBS_RELEASE_CANDIDATE_MINOR: u32 = 0;
pub const OBS_RELEASE_CANDIDATE_PATCH: u32 = 0;
pub const OBS_RELEASE_CANDIDATE_VER: u32 = 0;
pub const OBS_RELEASE_CANDIDATE: u32 = 0;
pub const OBS_INSTALL_DATA_PATH: &'static [u8; 11usize] = b"../../data\0";
pub const MAX_CHANNELS: u32 = 64;
pub const OBS_ALIGN_CENTER: u32 = 0;
pub const OBS_ALIGN_LEFT: u32 = 1;
pub const OBS_ALIGN_RIGHT: u32 = 2;
pub const OBS_ALIGN_TOP: u32 = 4;
pub const OBS_ALIGN_BOTTOM: u32 = 8;
pub const MODULE_SUCCESS: u32 = 0;
pub const MODULE_ERROR: i32 = -1;
pub const MODULE_FILE_NOT_FOUND: i32 = -2;
pub const MODULE_MISSING_EXPORTS: i32 = -3;
pub const MODULE_INCOMPATIBLE_VER: i32 = -4;
pub const OBS_OUTPUT_SUCCESS: u32 = 0;
pub const OBS_OUTPUT_BAD_PATH: i32 = -1;
pub const OBS_OUTPUT_CONNECT_FAILED: i32 = -2;
pub const OBS_OUTPUT_INVALID_STREAM: i32 = -3;
pub const OBS_OUTPUT_ERROR: i32 = -4;
pub const OBS_OUTPUT_DISCONNECTED: i32 = -5;
pub const OBS_OUTPUT_UNSUPPORTED: i32 = -6;
pub const OBS_OUTPUT_NO_SPACE: i32 = -7;
pub const OBS_OUTPUT_ENCODE_ERROR: i32 = -8;
pub const OBS_VIDEO_SUCCESS: u32 = 0;
pub const OBS_VIDEO_FAIL: i32 = -1;
pub const OBS_VIDEO_NOT_SUPPORTED: i32 = -2;
pub const OBS_VIDEO_INVALID_PARAM: i32 = -3;
pub const OBS_VIDEO_CURRENTLY_ACTIVE: i32 = -4;
pub const OBS_VIDEO_MODULE_NOT_FOUND: i32 = -5;
pub const OBS_UI_SUCCESS: u32 = 0;
pub const OBS_UI_CANCEL: i32 = -1;
pub const OBS_UI_NOTFOUND: i32 = -2;
pub const OBS_PROPERTIES_DEFER_UPDATE: u32 = 1;
pub const OBS_FONT_BOLD: u32 = 1;
pub const OBS_FONT_ITALIC: u32 = 2;
pub const OBS_FONT_UNDERLINE: u32 = 4;
pub const OBS_FONT_STRIKEOUT: u32 = 8;
pub const OBS_SOURCE_VIDEO: u32 = 1;
pub const OBS_SOURCE_AUDIO: u32 = 2;
pub const OBS_SOURCE_ASYNC: u32 = 4;
pub const OBS_SOURCE_ASYNC_VIDEO: u32 = 5;
pub const OBS_SOURCE_CUSTOM_DRAW: u32 = 8;
pub const OBS_SOURCE_INTERACTION: u32 = 32;
pub const OBS_SOURCE_COMPOSITE: u32 = 64;
pub const OBS_SOURCE_DO_NOT_DUPLICATE: u32 = 128;
pub const OBS_SOURCE_DEPRECATED: u32 = 256;
pub const OBS_SOURCE_DO_NOT_SELF_MONITOR: u32 = 512;
pub const OBS_SOURCE_CAP_DISABLED: u32 = 1024;
pub const OBS_SOURCE_CAP_OBSOLETE: u32 = 1024;
pub const OBS_SOURCE_MONITOR_BY_DEFAULT: u32 = 2048;
pub const OBS_SOURCE_SUBMIX: u32 = 4096;
pub const OBS_SOURCE_CONTROLLABLE_MEDIA: u32 = 8192;
pub const OBS_ENCODER_CAP_DEPRECATED: u32 = 1;
pub const OBS_ENCODER_CAP_PASS_TEXTURE: u32 = 2;
pub const OBS_ENCODER_CAP_DYN_BITRATE: u32 = 4;
pub const OBS_ENCODER_CAP_INTERNAL: u32 = 8;
pub const OBS_OUTPUT_VIDEO: u32 = 1;
pub const OBS_OUTPUT_AUDIO: u32 = 2;
pub const OBS_OUTPUT_AV: u32 = 3;
pub const OBS_OUTPUT_ENCODED: u32 = 4;
pub const OBS_OUTPUT_SERVICE: u32 = 8;
pub const OBS_OUTPUT_MULTI_TRACK: u32 = 16;
pub const OBS_OUTPUT_CAN_PAUSE: u32 = 32;
pub const XINPUT_MOUSE_LEN: u32 = 33;
pub const OBS_MOUSE_BUTTON_DEFAULT: u32 = 1;
pub const OBS_SOURCE_FLAG_UNUSED_1: u32 = 1;
pub const OBS_SOURCE_FLAG_FORCE_MONO: u32 = 2;
pub const OBS_OUTPUT_DELAY_PRESERVE: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[doc = " Use if there's a problem that can potentially affect the program,"]
#[doc = " but isn't enough to require termination of the program."]
#[doc = ""]
#[doc = " Use in creation functions and core subsystem functions.  Places that"]
#[doc = " should definitely not fail."]
pub const LOG_ERROR: _bindgen_ty_1 = 100;
#[doc = " Use if a problem occurs that doesn't affect the program and is"]
#[doc = " recoverable."]
#[doc = ""]
#[doc = " Use in places where failure isn't entirely unexpected, and can"]
#[doc = " be handled safely."]
pub const LOG_WARNING: _bindgen_ty_1 = 200;
#[doc = " Informative message to be displayed in the log."]
pub const LOG_INFO: _bindgen_ty_1 = 300;
#[doc = " Debug message to be used mostly by developers."]
pub const LOG_DEBUG: _bindgen_ty_1 = 400;
pub type _bindgen_ty_1 = u32;
pub type log_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        lvl: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
        p: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn base_get_log_handler(
        handler: *mut log_handler_t,
        param: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn base_set_log_handler(handler: log_handler_t, param: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn base_set_crash_handler(
        handler: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut __va_list_tag,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn blogva(
        log_level: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn blog(log_level: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn bcrash(format: *const ::std::os::raw::c_char, ...);
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcscoll_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(
        __wcs: *const ::std::os::raw::c_int,
        __wc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn wmemchr(
        __s: *const ::std::os::raw::c_int,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemmove(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
        __p: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t, __ps: *mut mbstate_t)
        -> size_t;
}
extern "C" {
    pub fn __mbrlen(
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: size_t, __ps: *mut mbstate_t) -> size_t;
}
extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: size_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __nwc: size_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> u128;
}
extern "C" {
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut size_t) -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(
        __s: *mut wchar_t,
        __n: size_t,
        __format: *const wchar_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: size_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(
        __ws: *mut wchar_t,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: size_t,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct base_allocator {
    pub malloc:
        ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: size_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_base_allocator() {
    assert_eq!(
        ::std::mem::size_of::<base_allocator>(),
        24usize,
        concat!("Size of: ", stringify!(base_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<base_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(base_allocator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_allocator>())).malloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(base_allocator),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_allocator>())).realloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(base_allocator),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_allocator>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(base_allocator),
            "::",
            stringify!(free)
        )
    );
}
extern "C" {
    pub fn base_set_allocator(defs: *mut base_allocator);
}
extern "C" {
    pub fn bmalloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn brealloc(ptr: *mut ::std::os::raw::c_void, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bfree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn base_get_alignment() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bnum_allocs() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bmemdup(ptr: *const ::std::os::raw::c_void, size: size_t)
        -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct darray {
    pub array: *mut ::std::os::raw::c_void,
    pub num: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_darray() {
    assert_eq!(
        ::std::mem::size_of::<darray>(),
        24usize,
        concat!("Size of: ", stringify!(darray))
    );
    assert_eq!(
        ::std::mem::align_of::<darray>(),
        8usize,
        concat!("Alignment of ", stringify!(darray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<darray>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(darray),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<darray>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(darray),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<darray>())).capacity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(darray),
            "::",
            stringify!(capacity)
        )
    );
}
impl Default for darray {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_snapshot {
    _unused: [u8; 0],
}
pub type profiler_snapshot_t = profiler_snapshot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_snapshot_entry {
    _unused: [u8; 0],
}
pub type profiler_snapshot_entry_t = profiler_snapshot_entry;
pub type profiler_time_entry_t = profiler_time_entry;
extern "C" {
    pub fn profile_register_root(
        name: *const ::std::os::raw::c_char,
        expected_time_between_calls: u64,
    );
}
extern "C" {
    pub fn profile_start(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn profile_end(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn profile_reenable_thread();
}
extern "C" {
    pub fn profiler_start();
}
extern "C" {
    pub fn profiler_stop();
}
extern "C" {
    pub fn profiler_print(snap: *mut profiler_snapshot_t);
}
extern "C" {
    pub fn profiler_print_time_between_calls(snap: *mut profiler_snapshot_t);
}
extern "C" {
    pub fn profiler_free();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_name_store {
    _unused: [u8; 0],
}
pub type profiler_name_store_t = profiler_name_store;
extern "C" {
    pub fn profiler_name_store_create() -> *mut profiler_name_store_t;
}
extern "C" {
    pub fn profiler_name_store_free(store: *mut profiler_name_store_t);
}
extern "C" {
    pub fn profile_store_name(
        store: *mut profiler_name_store_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct profiler_time_entry {
    pub time_delta: u64,
    pub count: u64,
}
#[test]
fn bindgen_test_layout_profiler_time_entry() {
    assert_eq!(
        ::std::mem::size_of::<profiler_time_entry>(),
        16usize,
        concat!("Size of: ", stringify!(profiler_time_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<profiler_time_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(profiler_time_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<profiler_time_entry>())).time_delta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entry),
            "::",
            stringify!(time_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<profiler_time_entry>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entry),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union profiler_time_entries_t {
    pub da: darray,
    pub __bindgen_anon_1: profiler_time_entries_t__bindgen_ty_1,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profiler_time_entries_t__bindgen_ty_1 {
    pub array: *mut profiler_time_entry_t,
    pub num: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_profiler_time_entries_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<profiler_time_entries_t__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(profiler_time_entries_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<profiler_time_entries_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(profiler_time_entries_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<profiler_time_entries_t__bindgen_ty_1>())).array as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entries_t__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<profiler_time_entries_t__bindgen_ty_1>())).num as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entries_t__bindgen_ty_1),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<profiler_time_entries_t__bindgen_ty_1>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entries_t__bindgen_ty_1),
            "::",
            stringify!(capacity)
        )
    );
}
impl Default for profiler_time_entries_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_profiler_time_entries_t() {
    assert_eq!(
        ::std::mem::size_of::<profiler_time_entries_t>(),
        24usize,
        concat!("Size of: ", stringify!(profiler_time_entries_t))
    );
    assert_eq!(
        ::std::mem::align_of::<profiler_time_entries_t>(),
        8usize,
        concat!("Alignment of ", stringify!(profiler_time_entries_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<profiler_time_entries_t>())).da as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(profiler_time_entries_t),
            "::",
            stringify!(da)
        )
    );
}
impl Default for profiler_time_entries_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type profiler_entry_enum_func = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        entry: *mut profiler_snapshot_entry_t,
    ) -> bool,
>;
extern "C" {
    pub fn profile_snapshot_create() -> *mut profiler_snapshot_t;
}
extern "C" {
    pub fn profile_snapshot_free(snap: *mut profiler_snapshot_t);
}
extern "C" {
    pub fn profiler_snapshot_dump_csv(
        snap: *const profiler_snapshot_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn profiler_snapshot_dump_csv_gz(
        snap: *const profiler_snapshot_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn profiler_snapshot_num_roots(snap: *mut profiler_snapshot_t) -> size_t;
}
extern "C" {
    pub fn profiler_snapshot_enumerate_roots(
        snap: *mut profiler_snapshot_t,
        func: profiler_entry_enum_func,
        context: *mut ::std::os::raw::c_void,
    );
}
pub type profiler_name_filter_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        remove: *mut bool,
    ) -> bool,
>;
extern "C" {
    pub fn profiler_snapshot_filter_roots(
        snap: *mut profiler_snapshot_t,
        func: profiler_name_filter_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn profiler_snapshot_num_children(entry: *mut profiler_snapshot_entry_t) -> size_t;
}
extern "C" {
    pub fn profiler_snapshot_enumerate_children(
        entry: *mut profiler_snapshot_entry_t,
        func: profiler_entry_enum_func,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn profiler_snapshot_entry_name(
        entry: *mut profiler_snapshot_entry_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn profiler_snapshot_entry_times(
        entry: *mut profiler_snapshot_entry_t,
    ) -> *mut profiler_time_entries_t;
}
extern "C" {
    pub fn profiler_snapshot_entry_min_time(entry: *mut profiler_snapshot_entry_t) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_max_time(entry: *mut profiler_snapshot_entry_t) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_overall_count(entry: *mut profiler_snapshot_entry_t) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_times_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> *mut profiler_time_entries_t;
}
extern "C" {
    pub fn profiler_snapshot_entry_expected_time_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_min_time_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_max_time_between_calls(
        entry: *mut profiler_snapshot_entry_t,
    ) -> u64;
}
extern "C" {
    pub fn profiler_snapshot_entry_overall_between_calls_count(
        entry: *mut profiler_snapshot_entry_t,
    ) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct text_lookup {
    _unused: [u8; 0],
}
pub type lookup_t = text_lookup;
extern "C" {
    pub fn text_lookup_create(path: *const ::std::os::raw::c_char) -> *mut lookup_t;
}
extern "C" {
    pub fn text_lookup_add(lookup: *mut lookup_t, path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn text_lookup_destroy(lookup: *mut lookup_t);
}
extern "C" {
    pub fn text_lookup_getstr(
        lookup: *mut lookup_t,
        lookup_val: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct input_subsystem {
    _unused: [u8; 0],
}
pub type input_t = input_subsystem;
extern "C" {
    pub fn input_getbuttonstate(input: *mut input_t, button: u32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct axisang {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matrix3 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct matrix4 {
    _unused: [u8; 0],
}
pub const gs_draw_mode_GS_POINTS: gs_draw_mode = 0;
pub const gs_draw_mode_GS_LINES: gs_draw_mode = 1;
pub const gs_draw_mode_GS_LINESTRIP: gs_draw_mode = 2;
pub const gs_draw_mode_GS_TRIS: gs_draw_mode = 3;
pub const gs_draw_mode_GS_TRISTRIP: gs_draw_mode = 4;
pub type gs_draw_mode = u32;
pub const gs_color_format_GS_UNKNOWN: gs_color_format = 0;
pub const gs_color_format_GS_A8: gs_color_format = 1;
pub const gs_color_format_GS_R8: gs_color_format = 2;
pub const gs_color_format_GS_RGBA: gs_color_format = 3;
pub const gs_color_format_GS_BGRX: gs_color_format = 4;
pub const gs_color_format_GS_BGRA: gs_color_format = 5;
pub const gs_color_format_GS_R10G10B10A2: gs_color_format = 6;
pub const gs_color_format_GS_RGBA16: gs_color_format = 7;
pub const gs_color_format_GS_R16: gs_color_format = 8;
pub const gs_color_format_GS_RGBA16F: gs_color_format = 9;
pub const gs_color_format_GS_RGBA32F: gs_color_format = 10;
pub const gs_color_format_GS_RG16F: gs_color_format = 11;
pub const gs_color_format_GS_RG32F: gs_color_format = 12;
pub const gs_color_format_GS_R16F: gs_color_format = 13;
pub const gs_color_format_GS_R32F: gs_color_format = 14;
pub const gs_color_format_GS_DXT1: gs_color_format = 15;
pub const gs_color_format_GS_DXT3: gs_color_format = 16;
pub const gs_color_format_GS_DXT5: gs_color_format = 17;
pub const gs_color_format_GS_R8G8: gs_color_format = 18;
pub type gs_color_format = u32;
pub const gs_zstencil_format_GS_ZS_NONE: gs_zstencil_format = 0;
pub const gs_zstencil_format_GS_Z16: gs_zstencil_format = 1;
pub const gs_zstencil_format_GS_Z24_S8: gs_zstencil_format = 2;
pub const gs_zstencil_format_GS_Z32F: gs_zstencil_format = 3;
pub const gs_zstencil_format_GS_Z32F_S8X24: gs_zstencil_format = 4;
pub type gs_zstencil_format = u32;
pub const gs_index_type_GS_UNSIGNED_SHORT: gs_index_type = 0;
pub const gs_index_type_GS_UNSIGNED_LONG: gs_index_type = 1;
pub type gs_index_type = u32;
pub const gs_cull_mode_GS_BACK: gs_cull_mode = 0;
pub const gs_cull_mode_GS_FRONT: gs_cull_mode = 1;
pub const gs_cull_mode_GS_NEITHER: gs_cull_mode = 2;
pub type gs_cull_mode = u32;
pub const gs_blend_type_GS_BLEND_ZERO: gs_blend_type = 0;
pub const gs_blend_type_GS_BLEND_ONE: gs_blend_type = 1;
pub const gs_blend_type_GS_BLEND_SRCCOLOR: gs_blend_type = 2;
pub const gs_blend_type_GS_BLEND_INVSRCCOLOR: gs_blend_type = 3;
pub const gs_blend_type_GS_BLEND_SRCALPHA: gs_blend_type = 4;
pub const gs_blend_type_GS_BLEND_INVSRCALPHA: gs_blend_type = 5;
pub const gs_blend_type_GS_BLEND_DSTCOLOR: gs_blend_type = 6;
pub const gs_blend_type_GS_BLEND_INVDSTCOLOR: gs_blend_type = 7;
pub const gs_blend_type_GS_BLEND_DSTALPHA: gs_blend_type = 8;
pub const gs_blend_type_GS_BLEND_INVDSTALPHA: gs_blend_type = 9;
pub const gs_blend_type_GS_BLEND_SRCALPHASAT: gs_blend_type = 10;
pub type gs_blend_type = u32;
pub const gs_depth_test_GS_NEVER: gs_depth_test = 0;
pub const gs_depth_test_GS_LESS: gs_depth_test = 1;
pub const gs_depth_test_GS_LEQUAL: gs_depth_test = 2;
pub const gs_depth_test_GS_EQUAL: gs_depth_test = 3;
pub const gs_depth_test_GS_GEQUAL: gs_depth_test = 4;
pub const gs_depth_test_GS_GREATER: gs_depth_test = 5;
pub const gs_depth_test_GS_NOTEQUAL: gs_depth_test = 6;
pub const gs_depth_test_GS_ALWAYS: gs_depth_test = 7;
pub type gs_depth_test = u32;
pub const gs_stencil_side_GS_STENCIL_FRONT: gs_stencil_side = 1;
pub const gs_stencil_side_GS_STENCIL_BACK: gs_stencil_side = 2;
pub const gs_stencil_side_GS_STENCIL_BOTH: gs_stencil_side = 3;
pub type gs_stencil_side = u32;
pub const gs_stencil_op_type_GS_KEEP: gs_stencil_op_type = 0;
pub const gs_stencil_op_type_GS_ZERO: gs_stencil_op_type = 1;
pub const gs_stencil_op_type_GS_REPLACE: gs_stencil_op_type = 2;
pub const gs_stencil_op_type_GS_INCR: gs_stencil_op_type = 3;
pub const gs_stencil_op_type_GS_DECR: gs_stencil_op_type = 4;
pub const gs_stencil_op_type_GS_INVERT: gs_stencil_op_type = 5;
pub type gs_stencil_op_type = u32;
pub const gs_cube_sides_GS_POSITIVE_X: gs_cube_sides = 0;
pub const gs_cube_sides_GS_NEGATIVE_X: gs_cube_sides = 1;
pub const gs_cube_sides_GS_POSITIVE_Y: gs_cube_sides = 2;
pub const gs_cube_sides_GS_NEGATIVE_Y: gs_cube_sides = 3;
pub const gs_cube_sides_GS_POSITIVE_Z: gs_cube_sides = 4;
pub const gs_cube_sides_GS_NEGATIVE_Z: gs_cube_sides = 5;
pub type gs_cube_sides = u32;
pub const gs_sample_filter_GS_FILTER_POINT: gs_sample_filter = 0;
pub const gs_sample_filter_GS_FILTER_LINEAR: gs_sample_filter = 1;
pub const gs_sample_filter_GS_FILTER_ANISOTROPIC: gs_sample_filter = 2;
pub const gs_sample_filter_GS_FILTER_MIN_MAG_POINT_MIP_LINEAR: gs_sample_filter = 3;
pub const gs_sample_filter_GS_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT: gs_sample_filter = 4;
pub const gs_sample_filter_GS_FILTER_MIN_POINT_MAG_MIP_LINEAR: gs_sample_filter = 5;
pub const gs_sample_filter_GS_FILTER_MIN_LINEAR_MAG_MIP_POINT: gs_sample_filter = 6;
pub const gs_sample_filter_GS_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR: gs_sample_filter = 7;
pub const gs_sample_filter_GS_FILTER_MIN_MAG_LINEAR_MIP_POINT: gs_sample_filter = 8;
pub type gs_sample_filter = u32;
pub const gs_address_mode_GS_ADDRESS_CLAMP: gs_address_mode = 0;
pub const gs_address_mode_GS_ADDRESS_WRAP: gs_address_mode = 1;
pub const gs_address_mode_GS_ADDRESS_MIRROR: gs_address_mode = 2;
pub const gs_address_mode_GS_ADDRESS_BORDER: gs_address_mode = 3;
pub const gs_address_mode_GS_ADDRESS_MIRRORONCE: gs_address_mode = 4;
pub type gs_address_mode = u32;
pub const gs_texture_type_GS_TEXTURE_2D: gs_texture_type = 0;
pub const gs_texture_type_GS_TEXTURE_3D: gs_texture_type = 1;
pub const gs_texture_type_GS_TEXTURE_CUBE: gs_texture_type = 2;
pub type gs_texture_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_device_loss {
    pub device_loss_release:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub device_loss_rebuild: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ::std::os::raw::c_void,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gs_device_loss() {
    assert_eq!(
        ::std::mem::size_of::<gs_device_loss>(),
        24usize,
        concat!("Size of: ", stringify!(gs_device_loss))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_device_loss>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_device_loss))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gs_device_loss>())).device_loss_release as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_device_loss),
            "::",
            stringify!(device_loss_release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gs_device_loss>())).device_loss_rebuild as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_device_loss),
            "::",
            stringify!(device_loss_rebuild)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_device_loss>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_device_loss),
            "::",
            stringify!(data)
        )
    );
}
impl Default for gs_device_loss {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gs_monitor_info {
    pub rotation_degrees: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub cx: ::std::os::raw::c_long,
    pub cy: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_gs_monitor_info() {
    assert_eq!(
        ::std::mem::size_of::<gs_monitor_info>(),
        40usize,
        concat!("Size of: ", stringify!(gs_monitor_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_monitor_info>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_monitor_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gs_monitor_info>())).rotation_degrees as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(rotation_degrees)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_monitor_info>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_monitor_info>())).y as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_monitor_info>())).cx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_monitor_info>())).cy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_monitor_info),
            "::",
            stringify!(cy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_tvertarray {
    pub width: size_t,
    pub array: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gs_tvertarray() {
    assert_eq!(
        ::std::mem::size_of::<gs_tvertarray>(),
        16usize,
        concat!("Size of: ", stringify!(gs_tvertarray))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_tvertarray>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_tvertarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_tvertarray>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_tvertarray),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_tvertarray>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_tvertarray),
            "::",
            stringify!(array)
        )
    );
}
impl Default for gs_tvertarray {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_vb_data {
    pub num: size_t,
    pub points: *mut vec3,
    pub normals: *mut vec3,
    pub tangents: *mut vec3,
    pub colors: *mut u32,
    pub num_tex: size_t,
    pub tvarray: *mut gs_tvertarray,
}
#[test]
fn bindgen_test_layout_gs_vb_data() {
    assert_eq!(
        ::std::mem::size_of::<gs_vb_data>(),
        56usize,
        concat!("Size of: ", stringify!(gs_vb_data))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_vb_data>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_vb_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_vb_data>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_vb_data>())).points as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_vb_data>())).normals as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(normals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_vb_data>())).tangents as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(tangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_vb_data>())).colors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_vb_data>())).num_tex as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(num_tex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_vb_data>())).tvarray as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_vb_data),
            "::",
            stringify!(tvarray)
        )
    );
}
impl Default for gs_vb_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_sampler_info {
    pub filter: gs_sample_filter,
    pub address_u: gs_address_mode,
    pub address_v: gs_address_mode,
    pub address_w: gs_address_mode,
    pub max_anisotropy: ::std::os::raw::c_int,
    pub border_color: u32,
}
#[test]
fn bindgen_test_layout_gs_sampler_info() {
    assert_eq!(
        ::std::mem::size_of::<gs_sampler_info>(),
        24usize,
        concat!("Size of: ", stringify!(gs_sampler_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_sampler_info>(),
        4usize,
        concat!("Alignment of ", stringify!(gs_sampler_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_sampler_info>())).filter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_sampler_info>())).address_u as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(address_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_sampler_info>())).address_v as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(address_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_sampler_info>())).address_w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(address_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_sampler_info>())).max_anisotropy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(max_anisotropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_sampler_info>())).border_color as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_sampler_info),
            "::",
            stringify!(border_color)
        )
    );
}
impl Default for gs_sampler_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gs_display_mode {
    pub width: u32,
    pub height: u32,
    pub bits: u32,
    pub freq: u32,
}
#[test]
fn bindgen_test_layout_gs_display_mode() {
    assert_eq!(
        ::std::mem::size_of::<gs_display_mode>(),
        16usize,
        concat!("Size of: ", stringify!(gs_display_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_display_mode>(),
        4usize,
        concat!("Alignment of ", stringify!(gs_display_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_display_mode>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_display_mode),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_display_mode>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_display_mode),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_display_mode>())).bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_display_mode),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_display_mode>())).freq as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_display_mode),
            "::",
            stringify!(freq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gs_rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_gs_rect() {
    assert_eq!(
        ::std::mem::size_of::<gs_rect>(),
        16usize,
        concat!("Size of: ", stringify!(gs_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(gs_rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_rect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_rect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_rect>())).cx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_rect),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_rect>())).cy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_rect),
            "::",
            stringify!(cy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_stage_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_zstencil_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_vertex_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_index_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_sampler_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_swap_chain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_timer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texrender {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_technique {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_pass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct graphics_subsystem {
    _unused: [u8; 0],
}
pub type gs_texture_t = gs_texture;
pub type gs_stagesurf_t = gs_stage_surface;
pub type gs_zstencil_t = gs_zstencil_buffer;
pub type gs_vertbuffer_t = gs_vertex_buffer;
pub type gs_indexbuffer_t = gs_index_buffer;
pub type gs_samplerstate_t = gs_sampler_state;
pub type gs_swapchain_t = gs_swap_chain;
pub type gs_timer_t = gs_timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_timer_range {
    _unused: [u8; 0],
}
pub type gs_timer_range_t = gs_timer_range;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_texture_render {
    _unused: [u8; 0],
}
pub type gs_texrender_t = gs_texture_render;
pub type gs_shader_t = gs_shader;
pub type gs_sparam_t = gs_shader_param;
pub type gs_effect_t = gs_effect;
pub type gs_technique_t = gs_effect_technique;
pub type gs_epass_t = gs_effect_pass;
pub type gs_eparam_t = gs_effect_param;
pub type gs_device_t = gs_device;
pub type graphics_t = graphics_subsystem;
pub const gs_shader_param_type_GS_SHADER_PARAM_UNKNOWN: gs_shader_param_type = 0;
pub const gs_shader_param_type_GS_SHADER_PARAM_BOOL: gs_shader_param_type = 1;
pub const gs_shader_param_type_GS_SHADER_PARAM_FLOAT: gs_shader_param_type = 2;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT: gs_shader_param_type = 3;
pub const gs_shader_param_type_GS_SHADER_PARAM_STRING: gs_shader_param_type = 4;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC2: gs_shader_param_type = 5;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC3: gs_shader_param_type = 6;
pub const gs_shader_param_type_GS_SHADER_PARAM_VEC4: gs_shader_param_type = 7;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT2: gs_shader_param_type = 8;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT3: gs_shader_param_type = 9;
pub const gs_shader_param_type_GS_SHADER_PARAM_INT4: gs_shader_param_type = 10;
pub const gs_shader_param_type_GS_SHADER_PARAM_MATRIX4X4: gs_shader_param_type = 11;
pub const gs_shader_param_type_GS_SHADER_PARAM_TEXTURE: gs_shader_param_type = 12;
pub type gs_shader_param_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_shader_param_info {
    pub type_: gs_shader_param_type,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_gs_shader_param_info() {
    assert_eq!(
        ::std::mem::size_of::<gs_shader_param_info>(),
        16usize,
        concat!("Size of: ", stringify!(gs_shader_param_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_shader_param_info>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_shader_param_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_shader_param_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_shader_param_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_shader_param_info>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_shader_param_info),
            "::",
            stringify!(name)
        )
    );
}
impl Default for gs_shader_param_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const gs_shader_type_GS_SHADER_VERTEX: gs_shader_type = 0;
pub const gs_shader_type_GS_SHADER_PIXEL: gs_shader_type = 1;
pub type gs_shader_type = u32;
extern "C" {
    pub fn gs_shader_destroy(shader: *mut gs_shader_t);
}
extern "C" {
    pub fn gs_shader_get_num_params(shader: *const gs_shader_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gs_shader_get_param_by_idx(shader: *mut gs_shader_t, param: u32) -> *mut gs_sparam_t;
}
extern "C" {
    pub fn gs_shader_get_param_by_name(
        shader: *mut gs_shader_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_sparam_t;
}
extern "C" {
    pub fn gs_shader_get_viewproj_matrix(shader: *const gs_shader_t) -> *mut gs_sparam_t;
}
extern "C" {
    pub fn gs_shader_get_world_matrix(shader: *const gs_shader_t) -> *mut gs_sparam_t;
}
extern "C" {
    pub fn gs_shader_get_param_info(param: *const gs_sparam_t, info: *mut gs_shader_param_info);
}
extern "C" {
    pub fn gs_shader_set_bool(param: *mut gs_sparam_t, val: bool);
}
extern "C" {
    pub fn gs_shader_set_float(param: *mut gs_sparam_t, val: f32);
}
extern "C" {
    pub fn gs_shader_set_int(param: *mut gs_sparam_t, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_shader_set_matrix3(param: *mut gs_sparam_t, val: *const matrix3);
}
extern "C" {
    pub fn gs_shader_set_matrix4(param: *mut gs_sparam_t, val: *const matrix4);
}
extern "C" {
    pub fn gs_shader_set_vec2(param: *mut gs_sparam_t, val: *const vec2);
}
extern "C" {
    pub fn gs_shader_set_vec3(param: *mut gs_sparam_t, val: *const vec3);
}
extern "C" {
    pub fn gs_shader_set_vec4(param: *mut gs_sparam_t, val: *const vec4);
}
extern "C" {
    pub fn gs_shader_set_texture(param: *mut gs_sparam_t, val: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_shader_set_val(
        param: *mut gs_sparam_t,
        val: *const ::std::os::raw::c_void,
        size: size_t,
    );
}
extern "C" {
    pub fn gs_shader_set_default(param: *mut gs_sparam_t);
}
extern "C" {
    pub fn gs_shader_set_next_sampler(param: *mut gs_sparam_t, sampler: *mut gs_samplerstate_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_effect_param_info {
    pub name: *const ::std::os::raw::c_char,
    pub type_: gs_shader_param_type,
}
#[test]
fn bindgen_test_layout_gs_effect_param_info() {
    assert_eq!(
        ::std::mem::size_of::<gs_effect_param_info>(),
        16usize,
        concat!("Size of: ", stringify!(gs_effect_param_info))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_effect_param_info>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_effect_param_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_effect_param_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_effect_param_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_effect_param_info>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_effect_param_info),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for gs_effect_param_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gs_effect_destroy(effect: *mut gs_effect_t);
}
extern "C" {
    pub fn gs_effect_get_technique(
        effect: *const gs_effect_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_technique_t;
}
extern "C" {
    pub fn gs_effect_get_current_technique(effect: *const gs_effect_t) -> *mut gs_technique_t;
}
extern "C" {
    pub fn gs_technique_begin(technique: *mut gs_technique_t) -> size_t;
}
extern "C" {
    pub fn gs_technique_end(technique: *mut gs_technique_t);
}
extern "C" {
    pub fn gs_technique_begin_pass(technique: *mut gs_technique_t, pass: size_t) -> bool;
}
extern "C" {
    pub fn gs_technique_begin_pass_by_name(
        technique: *mut gs_technique_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn gs_technique_end_pass(technique: *mut gs_technique_t);
}
extern "C" {
    pub fn gs_technique_get_pass_by_idx(
        technique: *const gs_technique_t,
        pass: size_t,
    ) -> *mut gs_epass_t;
}
extern "C" {
    pub fn gs_technique_get_pass_by_name(
        technique: *const gs_technique_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_epass_t;
}
extern "C" {
    pub fn gs_effect_get_num_params(effect: *const gs_effect_t) -> size_t;
}
extern "C" {
    pub fn gs_effect_get_param_by_idx(
        effect: *const gs_effect_t,
        param: size_t,
    ) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_effect_get_param_by_name(
        effect: *const gs_effect_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_param_get_num_annotations(param: *const gs_eparam_t) -> size_t;
}
extern "C" {
    pub fn gs_param_get_annotation_by_idx(
        param: *const gs_eparam_t,
        annotation: size_t,
    ) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_param_get_annotation_by_name(
        param: *const gs_eparam_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut gs_eparam_t;
}
extern "C" {
    #[doc = " Helper function to simplify effect usage.  Use with a while loop that"]
    #[doc = " contains drawing functions.  Automatically handles techniques, passes, and"]
    #[doc = " unloading."]
    pub fn gs_effect_loop(effect: *mut gs_effect_t, name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " used internally"]
    pub fn gs_effect_update_params(effect: *mut gs_effect_t);
}
extern "C" {
    pub fn gs_effect_get_viewproj_matrix(effect: *const gs_effect_t) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_effect_get_world_matrix(effect: *const gs_effect_t) -> *mut gs_eparam_t;
}
extern "C" {
    pub fn gs_effect_get_param_info(param: *const gs_eparam_t, info: *mut gs_effect_param_info);
}
extern "C" {
    pub fn gs_effect_set_bool(param: *mut gs_eparam_t, val: bool);
}
extern "C" {
    pub fn gs_effect_set_float(param: *mut gs_eparam_t, val: f32);
}
extern "C" {
    pub fn gs_effect_set_int(param: *mut gs_eparam_t, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_effect_set_matrix4(param: *mut gs_eparam_t, val: *const matrix4);
}
extern "C" {
    pub fn gs_effect_set_vec2(param: *mut gs_eparam_t, val: *const vec2);
}
extern "C" {
    pub fn gs_effect_set_vec3(param: *mut gs_eparam_t, val: *const vec3);
}
extern "C" {
    pub fn gs_effect_set_vec4(param: *mut gs_eparam_t, val: *const vec4);
}
extern "C" {
    pub fn gs_effect_set_texture(param: *mut gs_eparam_t, val: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_effect_set_val(
        param: *mut gs_eparam_t,
        val: *const ::std::os::raw::c_void,
        size: size_t,
    );
}
extern "C" {
    pub fn gs_effect_set_default(param: *mut gs_eparam_t);
}
extern "C" {
    pub fn gs_effect_get_val_size(param: *mut gs_eparam_t) -> size_t;
}
extern "C" {
    pub fn gs_effect_get_val(param: *mut gs_eparam_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_effect_get_default_val_size(param: *mut gs_eparam_t) -> size_t;
}
extern "C" {
    pub fn gs_effect_get_default_val(param: *mut gs_eparam_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_effect_set_next_sampler(param: *mut gs_eparam_t, sampler: *mut gs_samplerstate_t);
}
extern "C" {
    pub fn gs_effect_set_color(param: *mut gs_eparam_t, argb: u32);
}
extern "C" {
    pub fn gs_texrender_create(
        format: gs_color_format,
        zsformat: gs_zstencil_format,
    ) -> *mut gs_texrender_t;
}
extern "C" {
    pub fn gs_texrender_destroy(texrender: *mut gs_texrender_t);
}
extern "C" {
    pub fn gs_texrender_begin(texrender: *mut gs_texrender_t, cx: u32, cy: u32) -> bool;
}
extern "C" {
    pub fn gs_texrender_end(texrender: *mut gs_texrender_t);
}
extern "C" {
    pub fn gs_texrender_reset(texrender: *mut gs_texrender_t);
}
extern "C" {
    pub fn gs_texrender_get_texture(texrender: *const gs_texrender_t) -> *mut gs_texture_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_window {
    pub id: u32,
    pub display: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gs_window() {
    assert_eq!(
        ::std::mem::size_of::<gs_window>(),
        16usize,
        concat!("Size of: ", stringify!(gs_window))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_window>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_window))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_window>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_window),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_window>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_window),
            "::",
            stringify!(display)
        )
    );
}
impl Default for gs_window {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gs_init_data {
    pub window: gs_window,
    pub cx: u32,
    pub cy: u32,
    pub num_backbuffers: u32,
    pub format: gs_color_format,
    pub zsformat: gs_zstencil_format,
    pub adapter: u32,
}
#[test]
fn bindgen_test_layout_gs_init_data() {
    assert_eq!(
        ::std::mem::size_of::<gs_init_data>(),
        40usize,
        concat!("Size of: ", stringify!(gs_init_data))
    );
    assert_eq!(
        ::std::mem::align_of::<gs_init_data>(),
        8usize,
        concat!("Alignment of ", stringify!(gs_init_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_init_data>())).window as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_init_data>())).cx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_init_data>())).cy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_init_data>())).num_backbuffers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(num_backbuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_init_data>())).format as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_init_data>())).zsformat as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(zsformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gs_init_data>())).adapter as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gs_init_data),
            "::",
            stringify!(adapter)
        )
    );
}
impl Default for gs_init_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gs_get_device_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gs_get_device_type() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gs_enum_adapters(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                param: *mut ::std::os::raw::c_void,
                name: *const ::std::os::raw::c_char,
                id: u32,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gs_create(
        graphics: *mut *mut graphics_t,
        module: *const ::std::os::raw::c_char,
        adapter: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gs_destroy(graphics: *mut graphics_t);
}
extern "C" {
    pub fn gs_enter_context(graphics: *mut graphics_t);
}
extern "C" {
    pub fn gs_leave_context();
}
extern "C" {
    pub fn gs_get_context() -> *mut graphics_t;
}
extern "C" {
    pub fn gs_get_device_obj() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_matrix_push();
}
extern "C" {
    pub fn gs_matrix_pop();
}
extern "C" {
    pub fn gs_matrix_identity();
}
extern "C" {
    pub fn gs_matrix_transpose();
}
extern "C" {
    pub fn gs_matrix_set(matrix: *const matrix4);
}
extern "C" {
    pub fn gs_matrix_get(dst: *mut matrix4);
}
extern "C" {
    pub fn gs_matrix_mul(matrix: *const matrix4);
}
extern "C" {
    pub fn gs_matrix_rotquat(rot: *const quat);
}
extern "C" {
    pub fn gs_matrix_rotaa(rot: *const axisang);
}
extern "C" {
    pub fn gs_matrix_translate(pos: *const vec3);
}
extern "C" {
    pub fn gs_matrix_scale(scale: *const vec3);
}
extern "C" {
    pub fn gs_matrix_rotaa4f(x: f32, y: f32, z: f32, angle: f32);
}
extern "C" {
    pub fn gs_matrix_translate3f(x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn gs_matrix_scale3f(x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn gs_render_start(b_new: bool);
}
extern "C" {
    pub fn gs_render_stop(mode: gs_draw_mode);
}
extern "C" {
    pub fn gs_render_save() -> *mut gs_vertbuffer_t;
}
extern "C" {
    pub fn gs_vertex2f(x: f32, y: f32);
}
extern "C" {
    pub fn gs_vertex3f(x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn gs_normal3f(x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn gs_color(color: u32);
}
extern "C" {
    pub fn gs_texcoord(x: f32, y: f32, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_vertex2v(v: *const vec2);
}
extern "C" {
    pub fn gs_vertex3v(v: *const vec3);
}
extern "C" {
    pub fn gs_normal3v(v: *const vec3);
}
extern "C" {
    pub fn gs_color4v(v: *const vec4);
}
extern "C" {
    pub fn gs_texcoord2v(v: *const vec2, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_get_input() -> *mut input_t;
}
extern "C" {
    pub fn gs_get_effect() -> *mut gs_effect_t;
}
extern "C" {
    pub fn gs_effect_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_effect_t;
}
extern "C" {
    pub fn gs_effect_create(
        effect_string: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_effect_t;
}
extern "C" {
    pub fn gs_vertexshader_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_pixelshader_create_from_file(
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_texture_create_from_file(file: *const ::std::os::raw::c_char) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_create_texture_file_data(
        file: *const ::std::os::raw::c_char,
        format: *mut gs_color_format,
        cx: *mut u32,
        cy: *mut u32,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Draws a 2D sprite"]
    #[doc = ""]
    #[doc = "   If width or height is 0, the width or height of the texture will be used."]
    #[doc = " The flip value specifies whether the texture should be flipped on the U or V"]
    #[doc = " axis with GS_FLIP_U and GS_FLIP_V."]
    pub fn gs_draw_sprite(tex: *mut gs_texture_t, flip: u32, width: u32, height: u32);
}
extern "C" {
    pub fn gs_draw_sprite_subregion(
        tex: *mut gs_texture_t,
        flip: u32,
        x: u32,
        y: u32,
        cx: u32,
        cy: u32,
    );
}
extern "C" {
    pub fn gs_draw_cube_backdrop(
        cubetex: *mut gs_texture_t,
        rot: *const quat,
        left: f32,
        right: f32,
        top: f32,
        bottom: f32,
        znear: f32,
    );
}
extern "C" {
    #[doc = " sets the viewport to current swap chain size"]
    pub fn gs_reset_viewport();
}
extern "C" {
    #[doc = " sets default screen-sized orthographic mode"]
    pub fn gs_set_2d_mode();
}
extern "C" {
    #[doc = " sets default screen-sized perspective mode"]
    pub fn gs_set_3d_mode(fovy: f64, znear: f64, zvar: f64);
}
extern "C" {
    pub fn gs_viewport_push();
}
extern "C" {
    pub fn gs_viewport_pop();
}
extern "C" {
    pub fn gs_texture_set_image(
        tex: *mut gs_texture_t,
        data: *const u8,
        linesize: u32,
        invert: bool,
    );
}
extern "C" {
    pub fn gs_cubetexture_set_image(
        cubetex: *mut gs_texture_t,
        side: u32,
        data: *const ::std::os::raw::c_void,
        linesize: u32,
        invert: bool,
    );
}
extern "C" {
    pub fn gs_perspective(fovy: f32, aspect: f32, znear: f32, zfar: f32);
}
extern "C" {
    pub fn gs_blend_state_push();
}
extern "C" {
    pub fn gs_blend_state_pop();
}
extern "C" {
    pub fn gs_reset_blend_state();
}
extern "C" {
    pub fn gs_swapchain_create(data: *const gs_init_data) -> *mut gs_swapchain_t;
}
extern "C" {
    pub fn gs_resize(x: u32, y: u32);
}
extern "C" {
    pub fn gs_get_size(x: *mut u32, y: *mut u32);
}
extern "C" {
    pub fn gs_get_width() -> u32;
}
extern "C" {
    pub fn gs_get_height() -> u32;
}
extern "C" {
    pub fn gs_texture_create(
        width: u32,
        height: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_cubetexture_create(
        size: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_voltexture_create(
        width: u32,
        height: u32,
        depth: u32,
        color_format: gs_color_format,
        levels: u32,
        data: *mut *const u8,
        flags: u32,
    ) -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_zstencil_create(
        width: u32,
        height: u32,
        format: gs_zstencil_format,
    ) -> *mut gs_zstencil_t;
}
extern "C" {
    pub fn gs_stagesurface_create(
        width: u32,
        height: u32,
        color_format: gs_color_format,
    ) -> *mut gs_stagesurf_t;
}
extern "C" {
    pub fn gs_samplerstate_create(info: *const gs_sampler_info) -> *mut gs_samplerstate_t;
}
extern "C" {
    pub fn gs_vertexshader_create(
        shader: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_pixelshader_create(
        shader: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        error_string: *mut *mut ::std::os::raw::c_char,
    ) -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_vertexbuffer_create(data: *mut gs_vb_data, flags: u32) -> *mut gs_vertbuffer_t;
}
extern "C" {
    pub fn gs_indexbuffer_create(
        type_: gs_index_type,
        indices: *mut ::std::os::raw::c_void,
        num: size_t,
        flags: u32,
    ) -> *mut gs_indexbuffer_t;
}
extern "C" {
    pub fn gs_timer_create() -> *mut gs_timer_t;
}
extern "C" {
    pub fn gs_timer_range_create() -> *mut gs_timer_range_t;
}
extern "C" {
    pub fn gs_get_texture_type(texture: *const gs_texture_t) -> gs_texture_type;
}
extern "C" {
    pub fn gs_load_vertexbuffer(vertbuffer: *mut gs_vertbuffer_t);
}
extern "C" {
    pub fn gs_load_indexbuffer(indexbuffer: *mut gs_indexbuffer_t);
}
extern "C" {
    pub fn gs_load_texture(tex: *mut gs_texture_t, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_load_samplerstate(samplerstate: *mut gs_samplerstate_t, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_load_vertexshader(vertshader: *mut gs_shader_t);
}
extern "C" {
    pub fn gs_load_pixelshader(pixelshader: *mut gs_shader_t);
}
extern "C" {
    pub fn gs_load_default_samplerstate(b_3d: bool, unit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gs_get_vertex_shader() -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_get_pixel_shader() -> *mut gs_shader_t;
}
extern "C" {
    pub fn gs_get_render_target() -> *mut gs_texture_t;
}
extern "C" {
    pub fn gs_get_zstencil_target() -> *mut gs_zstencil_t;
}
extern "C" {
    pub fn gs_set_render_target(tex: *mut gs_texture_t, zstencil: *mut gs_zstencil_t);
}
extern "C" {
    pub fn gs_set_cube_render_target(
        cubetex: *mut gs_texture_t,
        side: ::std::os::raw::c_int,
        zstencil: *mut gs_zstencil_t,
    );
}
extern "C" {
    pub fn gs_copy_texture(dst: *mut gs_texture_t, src: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_copy_texture_region(
        dst: *mut gs_texture_t,
        dst_x: u32,
        dst_y: u32,
        src: *mut gs_texture_t,
        src_x: u32,
        src_y: u32,
        src_w: u32,
        src_h: u32,
    );
}
extern "C" {
    pub fn gs_stage_texture(dst: *mut gs_stagesurf_t, src: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_begin_frame();
}
extern "C" {
    pub fn gs_begin_scene();
}
extern "C" {
    pub fn gs_draw(draw_mode: gs_draw_mode, start_vert: u32, num_verts: u32);
}
extern "C" {
    pub fn gs_end_scene();
}
extern "C" {
    pub fn gs_load_swapchain(swapchain: *mut gs_swapchain_t);
}
extern "C" {
    pub fn gs_clear(clear_flags: u32, color: *const vec4, depth: f32, stencil: u8);
}
extern "C" {
    pub fn gs_present();
}
extern "C" {
    pub fn gs_flush();
}
extern "C" {
    pub fn gs_set_cull_mode(mode: gs_cull_mode);
}
extern "C" {
    pub fn gs_get_cull_mode() -> gs_cull_mode;
}
extern "C" {
    pub fn gs_enable_blending(enable: bool);
}
extern "C" {
    pub fn gs_enable_depth_test(enable: bool);
}
extern "C" {
    pub fn gs_enable_stencil_test(enable: bool);
}
extern "C" {
    pub fn gs_enable_stencil_write(enable: bool);
}
extern "C" {
    pub fn gs_enable_color(red: bool, green: bool, blue: bool, alpha: bool);
}
extern "C" {
    pub fn gs_blend_function(src: gs_blend_type, dest: gs_blend_type);
}
extern "C" {
    pub fn gs_blend_function_separate(
        src_c: gs_blend_type,
        dest_c: gs_blend_type,
        src_a: gs_blend_type,
        dest_a: gs_blend_type,
    );
}
extern "C" {
    pub fn gs_depth_function(test: gs_depth_test);
}
extern "C" {
    pub fn gs_stencil_function(side: gs_stencil_side, test: gs_depth_test);
}
extern "C" {
    pub fn gs_stencil_op(
        side: gs_stencil_side,
        fail: gs_stencil_op_type,
        zfail: gs_stencil_op_type,
        zpass: gs_stencil_op_type,
    );
}
extern "C" {
    pub fn gs_set_viewport(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gs_get_viewport(rect: *mut gs_rect);
}
extern "C" {
    pub fn gs_set_scissor_rect(rect: *const gs_rect);
}
extern "C" {
    pub fn gs_ortho(left: f32, right: f32, top: f32, bottom: f32, znear: f32, zfar: f32);
}
extern "C" {
    pub fn gs_frustum(left: f32, right: f32, top: f32, bottom: f32, znear: f32, zfar: f32);
}
extern "C" {
    pub fn gs_projection_push();
}
extern "C" {
    pub fn gs_projection_pop();
}
extern "C" {
    pub fn gs_swapchain_destroy(swapchain: *mut gs_swapchain_t);
}
extern "C" {
    pub fn gs_texture_destroy(tex: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_texture_get_width(tex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_texture_get_height(tex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_texture_get_color_format(tex: *const gs_texture_t) -> gs_color_format;
}
extern "C" {
    pub fn gs_texture_map(tex: *mut gs_texture_t, ptr: *mut *mut u8, linesize: *mut u32) -> bool;
}
extern "C" {
    pub fn gs_texture_unmap(tex: *mut gs_texture_t);
}
extern "C" {
    #[doc = " special-case function (GL only) - specifies whether the texture is a"]
    #[doc = " GL_TEXTURE_RECTANGLE type, which doesn't use normalized texture"]
    #[doc = " coordinates, doesn't support mipmapping, and requires address clamping"]
    pub fn gs_texture_is_rect(tex: *const gs_texture_t) -> bool;
}
extern "C" {
    #[doc = " Gets a pointer to the context-specific object associated with the texture."]
    #[doc = " For example, for GL, this is a GLuint*.  For D3D11, ID3D11Texture2D*."]
    pub fn gs_texture_get_obj(tex: *mut gs_texture_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_cubetexture_destroy(cubetex: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_cubetexture_get_size(cubetex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_cubetexture_get_color_format(cubetex: *const gs_texture_t) -> gs_color_format;
}
extern "C" {
    pub fn gs_voltexture_destroy(voltex: *mut gs_texture_t);
}
extern "C" {
    pub fn gs_voltexture_get_width(voltex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_voltexture_get_height(voltex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_voltexture_get_depth(voltex: *const gs_texture_t) -> u32;
}
extern "C" {
    pub fn gs_voltexture_get_color_format(voltex: *const gs_texture_t) -> gs_color_format;
}
extern "C" {
    pub fn gs_stagesurface_destroy(stagesurf: *mut gs_stagesurf_t);
}
extern "C" {
    pub fn gs_stagesurface_get_width(stagesurf: *const gs_stagesurf_t) -> u32;
}
extern "C" {
    pub fn gs_stagesurface_get_height(stagesurf: *const gs_stagesurf_t) -> u32;
}
extern "C" {
    pub fn gs_stagesurface_get_color_format(stagesurf: *const gs_stagesurf_t) -> gs_color_format;
}
extern "C" {
    pub fn gs_stagesurface_map(
        stagesurf: *mut gs_stagesurf_t,
        data: *mut *mut u8,
        linesize: *mut u32,
    ) -> bool;
}
extern "C" {
    pub fn gs_stagesurface_unmap(stagesurf: *mut gs_stagesurf_t);
}
extern "C" {
    pub fn gs_zstencil_destroy(zstencil: *mut gs_zstencil_t);
}
extern "C" {
    pub fn gs_samplerstate_destroy(samplerstate: *mut gs_samplerstate_t);
}
extern "C" {
    pub fn gs_vertexbuffer_destroy(vertbuffer: *mut gs_vertbuffer_t);
}
extern "C" {
    pub fn gs_vertexbuffer_flush(vertbuffer: *mut gs_vertbuffer_t);
}
extern "C" {
    pub fn gs_vertexbuffer_flush_direct(vertbuffer: *mut gs_vertbuffer_t, data: *const gs_vb_data);
}
extern "C" {
    pub fn gs_vertexbuffer_get_data(vertbuffer: *const gs_vertbuffer_t) -> *mut gs_vb_data;
}
extern "C" {
    pub fn gs_indexbuffer_destroy(indexbuffer: *mut gs_indexbuffer_t);
}
extern "C" {
    pub fn gs_indexbuffer_flush(indexbuffer: *mut gs_indexbuffer_t);
}
extern "C" {
    pub fn gs_indexbuffer_flush_direct(
        indexbuffer: *mut gs_indexbuffer_t,
        data: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gs_indexbuffer_get_data(
        indexbuffer: *const gs_indexbuffer_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gs_indexbuffer_get_num_indices(indexbuffer: *const gs_indexbuffer_t) -> size_t;
}
extern "C" {
    pub fn gs_indexbuffer_get_type(indexbuffer: *const gs_indexbuffer_t) -> gs_index_type;
}
extern "C" {
    pub fn gs_timer_destroy(timer: *mut gs_timer_t);
}
extern "C" {
    pub fn gs_timer_begin(timer: *mut gs_timer_t);
}
extern "C" {
    pub fn gs_timer_end(timer: *mut gs_timer_t);
}
extern "C" {
    pub fn gs_timer_get_data(timer: *mut gs_timer_t, ticks: *mut u64) -> bool;
}
extern "C" {
    pub fn gs_timer_range_destroy(timer: *mut gs_timer_range_t);
}
extern "C" {
    pub fn gs_timer_range_begin(range: *mut gs_timer_range_t);
}
extern "C" {
    pub fn gs_timer_range_end(range: *mut gs_timer_range_t);
}
extern "C" {
    pub fn gs_timer_range_get_data(
        range: *mut gs_timer_range_t,
        disjoint: *mut bool,
        frequency: *mut u64,
    ) -> bool;
}
extern "C" {
    pub fn gs_nv12_available() -> bool;
}
extern "C" {
    pub fn gs_debug_marker_begin(color: *const f32, markername: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gs_debug_marker_begin_format(
        color: *const f32,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn gs_debug_marker_end();
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vec2 {
    pub __bindgen_anon_1: vec2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vec2__bindgen_ty_1 {
    pub __bindgen_anon_1: vec2__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 2usize],
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vec2__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_vec2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vec2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vec2__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vec2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec2__bindgen_ty_1__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec2__bindgen_ty_1__bindgen_ty_1>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vec2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout_vec2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vec2__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vec2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec2__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(vec2__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vec2__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec2__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
impl Default for vec2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_vec2() {
    assert_eq!(
        ::std::mem::size_of::<vec2>(),
        8usize,
        concat!("Size of: ", stringify!(vec2))
    );
    assert_eq!(
        ::std::mem::align_of::<vec2>(),
        4usize,
        concat!("Alignment of ", stringify!(vec2))
    );
}
impl Default for vec2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn vec2_abs(dst: *mut vec2, v: *const vec2);
}
extern "C" {
    pub fn vec2_floor(dst: *mut vec2, v: *const vec2);
}
extern "C" {
    pub fn vec2_ceil(dst: *mut vec2, v: *const vec2);
}
extern "C" {
    pub fn vec2_close(v1: *const vec2, v2: *const vec2, epsilon: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vec2_norm(dst: *mut vec2, v: *const vec2);
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct vec4 {
    pub __bindgen_anon_1: vec4__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union vec4__bindgen_ty_1 {
    pub __bindgen_anon_1: vec4__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 4usize],
    pub m: __m128,
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vec4__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_vec4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vec4__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vec4__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec4__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec4__bindgen_ty_1__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec4__bindgen_ty_1__bindgen_ty_1>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec4__bindgen_ty_1__bindgen_ty_1>())).z as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec4__bindgen_ty_1__bindgen_ty_1>())).w as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(w)
        )
    );
}
#[test]
fn bindgen_test_layout_vec4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vec4__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vec4__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec4__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(vec4__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vec4__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vec4__bindgen_ty_1>())).m as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec4__bindgen_ty_1),
            "::",
            stringify!(m)
        )
    );
}
impl Default for vec4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_vec4() {
    assert_eq!(
        ::std::mem::size_of::<vec4>(),
        16usize,
        concat!("Size of: ", stringify!(vec4))
    );
    assert_eq!(
        ::std::mem::align_of::<vec4>(),
        16usize,
        concat!("Alignment of ", stringify!(vec4))
    );
}
impl Default for vec4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn vec4_from_vec3(dst: *mut vec4, v: *const vec3);
}
extern "C" {
    pub fn vec4_transform(dst: *mut vec4, v: *const vec4, m: *const matrix4);
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct vec3 {
    pub __bindgen_anon_1: vec3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union vec3__bindgen_ty_1 {
    pub __bindgen_anon_1: vec3__bindgen_ty_1__bindgen_ty_1,
    pub ptr: [f32; 4usize],
    pub m: __m128,
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vec3__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_vec3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vec3__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vec3__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec3__bindgen_ty_1__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec3__bindgen_ty_1__bindgen_ty_1>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec3__bindgen_ty_1__bindgen_ty_1>())).z as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vec3__bindgen_ty_1__bindgen_ty_1>())).w as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(w)
        )
    );
}
#[test]
fn bindgen_test_layout_vec3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vec3__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vec3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vec3__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(vec3__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vec3__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vec3__bindgen_ty_1>())).m as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vec3__bindgen_ty_1),
            "::",
            stringify!(m)
        )
    );
}
impl Default for vec3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_vec3() {
    assert_eq!(
        ::std::mem::size_of::<vec3>(),
        16usize,
        concat!("Size of: ", stringify!(vec3))
    );
    assert_eq!(
        ::std::mem::align_of::<vec3>(),
        16usize,
        concat!("Alignment of ", stringify!(vec3))
    );
}
impl Default for vec3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn vec3_from_vec4(dst: *mut vec3, v: *const vec4);
}
extern "C" {
    pub fn vec3_plane_dist(v: *const vec3, p: *const plane) -> f32;
}
extern "C" {
    pub fn vec3_transform(dst: *mut vec3, v: *const vec3, m: *const matrix4);
}
extern "C" {
    pub fn vec3_rotate(dst: *mut vec3, v: *const vec3, m: *const matrix3);
}
extern "C" {
    pub fn vec3_transform3x4(dst: *mut vec3, v: *const vec3, m: *const matrix3);
}
extern "C" {
    pub fn vec3_mirror(dst: *mut vec3, v: *const vec3, p: *const plane);
}
extern "C" {
    pub fn vec3_mirrorv(dst: *mut vec3, v: *const vec3, vec: *const vec3);
}
extern "C" {
    pub fn vec3_rand(dst: *mut vec3, positive_only: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct util_uint128 {
    pub __bindgen_anon_1: util_uint128__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union util_uint128__bindgen_ty_1 {
    pub i32: [u32; 4usize],
    pub __bindgen_anon_1: util_uint128__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct util_uint128__bindgen_ty_1__bindgen_ty_1 {
    pub low: u64,
    pub high: u64,
}
#[test]
fn bindgen_test_layout_util_uint128__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<util_uint128__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(util_uint128__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<util_uint128__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(util_uint128__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<util_uint128__bindgen_ty_1__bindgen_ty_1>())).low as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(util_uint128__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<util_uint128__bindgen_ty_1__bindgen_ty_1>())).high as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(util_uint128__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(high)
        )
    );
}
#[test]
fn bindgen_test_layout_util_uint128__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<util_uint128__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(util_uint128__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<util_uint128__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(util_uint128__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<util_uint128__bindgen_ty_1>())).i32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(util_uint128__bindgen_ty_1),
            "::",
            stringify!(i32)
        )
    );
}
impl Default for util_uint128__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_util_uint128() {
    assert_eq!(
        ::std::mem::size_of::<util_uint128>(),
        16usize,
        concat!("Size of: ", stringify!(util_uint128))
    );
    assert_eq!(
        ::std::mem::align_of::<util_uint128>(),
        8usize,
        concat!("Alignment of ", stringify!(util_uint128))
    );
}
impl Default for util_uint128 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type util_uint128_t = util_uint128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_output {
    _unused: [u8; 0],
}
pub type audio_t = audio_output;
pub const audio_format_AUDIO_FORMAT_UNKNOWN: audio_format = 0;
pub const audio_format_AUDIO_FORMAT_U8BIT: audio_format = 1;
pub const audio_format_AUDIO_FORMAT_16BIT: audio_format = 2;
pub const audio_format_AUDIO_FORMAT_32BIT: audio_format = 3;
pub const audio_format_AUDIO_FORMAT_FLOAT: audio_format = 4;
pub const audio_format_AUDIO_FORMAT_U8BIT_PLANAR: audio_format = 5;
pub const audio_format_AUDIO_FORMAT_16BIT_PLANAR: audio_format = 6;
pub const audio_format_AUDIO_FORMAT_32BIT_PLANAR: audio_format = 7;
pub const audio_format_AUDIO_FORMAT_FLOAT_PLANAR: audio_format = 8;
pub type audio_format = u32;
#[doc = "< Unknown setting, fallback is stereo."]
pub const speaker_layout_SPEAKERS_UNKNOWN: speaker_layout = 0;
#[doc = "< Channels: MONO"]
pub const speaker_layout_SPEAKERS_MONO: speaker_layout = 1;
#[doc = "< Channels: FL, FR"]
pub const speaker_layout_SPEAKERS_STEREO: speaker_layout = 2;
#[doc = "< Channels: FL, FR, LFE"]
pub const speaker_layout_SPEAKERS_2POINT1: speaker_layout = 3;
#[doc = "< Channels: FL, FR, FC, RC"]
pub const speaker_layout_SPEAKERS_4POINT0: speaker_layout = 4;
#[doc = "< Channels: FL, FR, FC, LFE, RC"]
pub const speaker_layout_SPEAKERS_4POINT1: speaker_layout = 5;
#[doc = "< Channels: FL, FR, FC, LFE, RL, RR"]
pub const speaker_layout_SPEAKERS_5POINT1: speaker_layout = 6;
#[doc = "< Channels: FL, FR, FC, LFE, RL, RR, SL, SR"]
pub const speaker_layout_SPEAKERS_7POINT1: speaker_layout = 8;
#[doc = " The speaker layout describes where the speakers are located in the room."]
#[doc = " For OBS it dictates:"]
#[doc = "  *  how many channels are available and"]
#[doc = "  *  which channels are used for which speakers."]
#[doc = ""]
#[doc = " Standard channel layouts where retrieved from ffmpeg documentation at:"]
#[doc = "     https://trac.ffmpeg.org/wiki/AudioChannelManipulation"]
pub type speaker_layout = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_data {
    pub data: [*mut u8; 8usize],
    pub frames: u32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_audio_data() {
    assert_eq!(
        ::std::mem::size_of::<audio_data>(),
        80usize,
        concat!("Size of: ", stringify!(audio_data))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_data>(),
        8usize,
        concat!("Alignment of ", stringify!(audio_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_data>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_data>())).frames as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_data),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_data>())).timestamp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_data),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for audio_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_output_data {
    pub data: [*mut f32; 8usize],
}
#[test]
fn bindgen_test_layout_audio_output_data() {
    assert_eq!(
        ::std::mem::size_of::<audio_output_data>(),
        64usize,
        concat!("Size of: ", stringify!(audio_output_data))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_output_data>(),
        8usize,
        concat!("Alignment of ", stringify!(audio_output_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_output_data>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for audio_output_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type audio_input_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        start_ts: u64,
        end_ts: u64,
        new_ts: *mut u64,
        active_mixers: u32,
        mixes: *mut audio_output_data,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_output_info {
    pub name: *const ::std::os::raw::c_char,
    pub samples_per_sec: u32,
    pub format: audio_format,
    pub speakers: speaker_layout,
    pub input_callback: audio_input_callback_t,
    pub input_param: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_audio_output_info() {
    assert_eq!(
        ::std::mem::size_of::<audio_output_info>(),
        40usize,
        concat!("Size of: ", stringify!(audio_output_info))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_output_info>(),
        8usize,
        concat!("Alignment of ", stringify!(audio_output_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_output_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<audio_output_info>())).samples_per_sec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_output_info>())).format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_output_info>())).speakers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(speakers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<audio_output_info>())).input_callback as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(input_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_output_info>())).input_param as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_output_info),
            "::",
            stringify!(input_param)
        )
    );
}
impl Default for audio_output_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_convert_info {
    pub samples_per_sec: u32,
    pub format: audio_format,
    pub speakers: speaker_layout,
}
#[test]
fn bindgen_test_layout_audio_convert_info() {
    assert_eq!(
        ::std::mem::size_of::<audio_convert_info>(),
        12usize,
        concat!("Size of: ", stringify!(audio_convert_info))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_convert_info>(),
        4usize,
        concat!("Alignment of ", stringify!(audio_convert_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<audio_convert_info>())).samples_per_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_convert_info),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_convert_info>())).format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_convert_info),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audio_convert_info>())).speakers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_convert_info),
            "::",
            stringify!(speakers)
        )
    );
}
impl Default for audio_convert_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn audio_output_open(
        audio: *mut *mut audio_t,
        info: *mut audio_output_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn audio_output_close(audio: *mut audio_t);
}
pub type audio_output_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        mix_idx: size_t,
        data: *mut audio_data,
    ),
>;
extern "C" {
    pub fn audio_output_connect(
        video: *mut audio_t,
        mix_idx: size_t,
        conversion: *const audio_convert_info,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn audio_output_disconnect(
        video: *mut audio_t,
        mix_idx: size_t,
        callback: audio_output_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn audio_output_active(audio: *const audio_t) -> bool;
}
extern "C" {
    pub fn audio_output_get_block_size(audio: *const audio_t) -> size_t;
}
extern "C" {
    pub fn audio_output_get_planes(audio: *const audio_t) -> size_t;
}
extern "C" {
    pub fn audio_output_get_channels(audio: *const audio_t) -> size_t;
}
extern "C" {
    pub fn audio_output_get_sample_rate(audio: *const audio_t) -> u32;
}
extern "C" {
    pub fn audio_output_get_info(audio: *const audio_t) -> *const audio_output_info;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_frame {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_output {
    _unused: [u8; 0],
}
pub type video_t = video_output;
pub const video_format_VIDEO_FORMAT_NONE: video_format = 0;
pub const video_format_VIDEO_FORMAT_I420: video_format = 1;
pub const video_format_VIDEO_FORMAT_NV12: video_format = 2;
pub const video_format_VIDEO_FORMAT_YVYU: video_format = 3;
pub const video_format_VIDEO_FORMAT_YUY2: video_format = 4;
pub const video_format_VIDEO_FORMAT_UYVY: video_format = 5;
pub const video_format_VIDEO_FORMAT_RGBA: video_format = 6;
pub const video_format_VIDEO_FORMAT_BGRA: video_format = 7;
pub const video_format_VIDEO_FORMAT_BGRX: video_format = 8;
pub const video_format_VIDEO_FORMAT_Y800: video_format = 9;
pub const video_format_VIDEO_FORMAT_I444: video_format = 10;
pub const video_format_VIDEO_FORMAT_BGR3: video_format = 11;
pub const video_format_VIDEO_FORMAT_I422: video_format = 12;
pub const video_format_VIDEO_FORMAT_I40A: video_format = 13;
pub const video_format_VIDEO_FORMAT_I42A: video_format = 14;
pub const video_format_VIDEO_FORMAT_YUVA: video_format = 15;
pub const video_format_VIDEO_FORMAT_AYUV: video_format = 16;
pub type video_format = u32;
pub const video_colorspace_VIDEO_CS_DEFAULT: video_colorspace = 0;
pub const video_colorspace_VIDEO_CS_601: video_colorspace = 1;
pub const video_colorspace_VIDEO_CS_709: video_colorspace = 2;
pub const video_colorspace_VIDEO_CS_SRGB: video_colorspace = 3;
pub type video_colorspace = u32;
pub const video_range_type_VIDEO_RANGE_DEFAULT: video_range_type = 0;
pub const video_range_type_VIDEO_RANGE_PARTIAL: video_range_type = 1;
pub const video_range_type_VIDEO_RANGE_FULL: video_range_type = 2;
pub type video_range_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_data {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_video_data() {
    assert_eq!(
        ::std::mem::size_of::<video_data>(),
        104usize,
        concat!("Size of: ", stringify!(video_data))
    );
    assert_eq!(
        ::std::mem::align_of::<video_data>(),
        8usize,
        concat!("Alignment of ", stringify!(video_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_data>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_data>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(video_data),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_data>())).timestamp as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(video_data),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for video_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_output_info {
    pub name: *const ::std::os::raw::c_char,
    pub format: video_format,
    pub fps_num: u32,
    pub fps_den: u32,
    pub width: u32,
    pub height: u32,
    pub cache_size: size_t,
    pub colorspace: video_colorspace,
    pub range: video_range_type,
}
#[test]
fn bindgen_test_layout_video_output_info() {
    assert_eq!(
        ::std::mem::size_of::<video_output_info>(),
        48usize,
        concat!("Size of: ", stringify!(video_output_info))
    );
    assert_eq!(
        ::std::mem::align_of::<video_output_info>(),
        8usize,
        concat!("Alignment of ", stringify!(video_output_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).fps_num as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(fps_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).fps_den as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(fps_den)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).width as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).height as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).cache_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).colorspace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_output_info>())).range as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(video_output_info),
            "::",
            stringify!(range)
        )
    );
}
impl Default for video_output_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const video_scale_type_VIDEO_SCALE_DEFAULT: video_scale_type = 0;
pub const video_scale_type_VIDEO_SCALE_POINT: video_scale_type = 1;
pub const video_scale_type_VIDEO_SCALE_FAST_BILINEAR: video_scale_type = 2;
pub const video_scale_type_VIDEO_SCALE_BILINEAR: video_scale_type = 3;
pub const video_scale_type_VIDEO_SCALE_BICUBIC: video_scale_type = 4;
pub type video_scale_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_scale_info {
    pub format: video_format,
    pub width: u32,
    pub height: u32,
    pub range: video_range_type,
    pub colorspace: video_colorspace,
}
#[test]
fn bindgen_test_layout_video_scale_info() {
    assert_eq!(
        ::std::mem::size_of::<video_scale_info>(),
        20usize,
        concat!("Size of: ", stringify!(video_scale_info))
    );
    assert_eq!(
        ::std::mem::align_of::<video_scale_info>(),
        4usize,
        concat!("Alignment of ", stringify!(video_scale_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_scale_info>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_scale_info>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_scale_info>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_scale_info>())).range as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<video_scale_info>())).colorspace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(video_scale_info),
            "::",
            stringify!(colorspace)
        )
    );
}
impl Default for video_scale_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn video_format_from_fourcc(fourcc: u32) -> video_format;
}
extern "C" {
    pub fn video_format_get_parameters(
        color_space: video_colorspace,
        range: video_range_type,
        matrix: *mut f32,
        min_range: *mut f32,
        max_range: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn video_output_open(
        video: *mut *mut video_t,
        info: *mut video_output_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn video_output_close(video: *mut video_t);
}
extern "C" {
    pub fn video_output_connect(
        video: *mut video_t,
        conversion: *const video_scale_info,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn video_output_disconnect(
        video: *mut video_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn video_output_active(video: *const video_t) -> bool;
}
extern "C" {
    pub fn video_output_get_info(video: *const video_t) -> *const video_output_info;
}
extern "C" {
    pub fn video_output_lock_frame(
        video: *mut video_t,
        frame: *mut video_frame,
        count: ::std::os::raw::c_int,
        timestamp: u64,
    ) -> bool;
}
extern "C" {
    pub fn video_output_unlock_frame(video: *mut video_t);
}
extern "C" {
    pub fn video_output_get_frame_time(video: *const video_t) -> u64;
}
extern "C" {
    pub fn video_output_stop(video: *mut video_t);
}
extern "C" {
    pub fn video_output_stopped(video: *mut video_t) -> bool;
}
extern "C" {
    pub fn video_output_get_format(video: *const video_t) -> video_format;
}
extern "C" {
    pub fn video_output_get_width(video: *const video_t) -> u32;
}
extern "C" {
    pub fn video_output_get_height(video: *const video_t) -> u32;
}
extern "C" {
    pub fn video_output_get_frame_rate(video: *const video_t) -> f64;
}
extern "C" {
    pub fn video_output_get_skipped_frames(video: *const video_t) -> u32;
}
extern "C" {
    pub fn video_output_get_total_frames(video: *const video_t) -> u32;
}
extern "C" {
    pub fn video_output_inc_texture_encoders(video: *mut video_t);
}
extern "C" {
    pub fn video_output_dec_texture_encoders(video: *mut video_t);
}
extern "C" {
    pub fn video_output_inc_texture_frames(video: *mut video_t);
}
extern "C" {
    pub fn video_output_inc_texture_skipped_frames(video: *mut video_t);
}
pub const call_param_type_CALL_PARAM_TYPE_VOID: call_param_type = 0;
pub const call_param_type_CALL_PARAM_TYPE_INT: call_param_type = 1;
pub const call_param_type_CALL_PARAM_TYPE_FLOAT: call_param_type = 2;
pub const call_param_type_CALL_PARAM_TYPE_BOOL: call_param_type = 3;
pub const call_param_type_CALL_PARAM_TYPE_PTR: call_param_type = 4;
pub const call_param_type_CALL_PARAM_TYPE_STRING: call_param_type = 5;
pub type call_param_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct calldata {
    pub stack: *mut u8,
    pub size: size_t,
    pub capacity: size_t,
    pub fixed: bool,
}
#[test]
fn bindgen_test_layout_calldata() {
    assert_eq!(
        ::std::mem::size_of::<calldata>(),
        32usize,
        concat!("Size of: ", stringify!(calldata))
    );
    assert_eq!(
        ::std::mem::align_of::<calldata>(),
        8usize,
        concat!("Alignment of ", stringify!(calldata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<calldata>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(calldata),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<calldata>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(calldata),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<calldata>())).capacity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(calldata),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<calldata>())).fixed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(calldata),
            "::",
            stringify!(fixed)
        )
    );
}
impl Default for calldata {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type calldata_t = calldata;
extern "C" {
    pub fn calldata_get_data(
        data: *const calldata_t,
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn calldata_set_data(
        data: *mut calldata_t,
        name: *const ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_void,
        new_size: size_t,
    );
}
extern "C" {
    pub fn calldata_get_string(
        data: *const calldata_t,
        name: *const ::std::os::raw::c_char,
        str: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_handler {
    _unused: [u8; 0],
}
pub type signal_handler_t = signal_handler;
pub type global_signal_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut calldata_t,
    ),
>;
pub type signal_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut calldata_t),
>;
extern "C" {
    pub fn signal_handler_create() -> *mut signal_handler_t;
}
extern "C" {
    pub fn signal_handler_destroy(handler: *mut signal_handler_t);
}
extern "C" {
    pub fn signal_handler_add(
        handler: *mut signal_handler_t,
        signal_decl: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn signal_handler_connect(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_connect_ref(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_disconnect(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        callback: signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_connect_global(
        handler: *mut signal_handler_t,
        callback: global_signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_disconnect_global(
        handler: *mut signal_handler_t,
        callback: global_signal_callback_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn signal_handler_remove_current();
}
extern "C" {
    pub fn signal_handler_signal(
        handler: *mut signal_handler_t,
        signal: *const ::std::os::raw::c_char,
        params: *mut calldata_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_handler {
    _unused: [u8; 0],
}
pub type proc_handler_t = proc_handler;
pub type proc_handler_proc_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut calldata_t),
>;
extern "C" {
    pub fn proc_handler_create() -> *mut proc_handler_t;
}
extern "C" {
    pub fn proc_handler_destroy(handler: *mut proc_handler_t);
}
extern "C" {
    pub fn proc_handler_add(
        handler: *mut proc_handler_t,
        decl_string: *const ::std::os::raw::c_char,
        proc_: proc_handler_proc_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Calls a function in a procedure handler.  Returns false if the named"]
    #[doc = " procedure is not found."]
    pub fn proc_handler_call(
        handler: *mut proc_handler_t,
        name: *const ::std::os::raw::c_char,
        params: *mut calldata_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct media_frames_per_second {
    pub numerator: u32,
    pub denominator: u32,
}
#[test]
fn bindgen_test_layout_media_frames_per_second() {
    assert_eq!(
        ::std::mem::size_of::<media_frames_per_second>(),
        8usize,
        concat!("Size of: ", stringify!(media_frames_per_second))
    );
    assert_eq!(
        ::std::mem::align_of::<media_frames_per_second>(),
        4usize,
        concat!("Alignment of ", stringify!(media_frames_per_second))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<media_frames_per_second>())).numerator as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(media_frames_per_second),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<media_frames_per_second>())).denominator as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(media_frames_per_second),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_data_array {
    _unused: [u8; 0],
}
pub type obs_data_t = obs_data;
pub type obs_data_item_t = obs_data_item;
pub type obs_data_array_t = obs_data_array;
pub const obs_data_type_OBS_DATA_NULL: obs_data_type = 0;
pub const obs_data_type_OBS_DATA_STRING: obs_data_type = 1;
pub const obs_data_type_OBS_DATA_NUMBER: obs_data_type = 2;
pub const obs_data_type_OBS_DATA_BOOLEAN: obs_data_type = 3;
pub const obs_data_type_OBS_DATA_OBJECT: obs_data_type = 4;
pub const obs_data_type_OBS_DATA_ARRAY: obs_data_type = 5;
pub type obs_data_type = u32;
pub const obs_data_number_type_OBS_DATA_NUM_INVALID: obs_data_number_type = 0;
pub const obs_data_number_type_OBS_DATA_NUM_INT: obs_data_number_type = 1;
pub const obs_data_number_type_OBS_DATA_NUM_DOUBLE: obs_data_number_type = 2;
pub type obs_data_number_type = u32;
extern "C" {
    pub fn obs_data_create() -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_create_from_json(json_string: *const ::std::os::raw::c_char)
        -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_create_from_json_file(
        json_file: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_create_from_json_file_safe(
        json_file: *const ::std::os::raw::c_char,
        backup_ext: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_addref(data: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_release(data: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_get_json(data: *mut obs_data_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_save_json(data: *mut obs_data_t, file: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_data_save_json_safe(
        data: *mut obs_data_t,
        file: *const ::std::os::raw::c_char,
        temp_ext: *const ::std::os::raw::c_char,
        backup_ext: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_apply(target: *mut obs_data_t, apply_data: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_erase(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_data_clear(data: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_set_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_set_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    pub fn obs_data_set_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char, val: bool);
}
extern "C" {
    pub fn obs_data_set_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        obj: *mut obs_data_t,
    );
}
extern "C" {
    pub fn obs_data_set_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        array: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_set_default_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_default_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_set_default_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    pub fn obs_data_set_default_bool(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: bool,
    );
}
extern "C" {
    pub fn obs_data_set_default_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        obj: *mut obs_data_t,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_bool(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: bool,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        obj: *mut obs_data_t,
    );
}
extern "C" {
    pub fn obs_data_get_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_get_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_get_double(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn obs_data_get_bool(data: *mut obs_data_t, name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_data_get_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_get_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_get_default_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_get_default_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_get_default_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn obs_data_get_default_bool(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_get_default_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_get_default_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_get_autoselect_string(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_get_autoselect_int(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_get_autoselect_double(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn obs_data_get_autoselect_bool(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_get_autoselect_obj(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_get_autoselect_array(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_array_create() -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_array_addref(array: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_data_array_release(array: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_data_array_count(array: *mut obs_data_array_t) -> size_t;
}
extern "C" {
    pub fn obs_data_array_item(array: *mut obs_data_array_t, idx: size_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_array_push_back(array: *mut obs_data_array_t, obj: *mut obs_data_t) -> size_t;
}
extern "C" {
    pub fn obs_data_array_insert(array: *mut obs_data_array_t, idx: size_t, obj: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_array_push_back_array(
        array: *mut obs_data_array_t,
        array2: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_array_erase(array: *mut obs_data_array_t, idx: size_t);
}
extern "C" {
    pub fn obs_data_has_user_value(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_has_default_value(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_has_autoselect_value(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_item_has_user_value(data: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_has_default_value(data: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_has_autoselect_value(data: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_unset_user_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_data_unset_default_value(data: *mut obs_data_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_data_unset_autoselect_value(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_unset_user_value(data: *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_item_unset_default_value(data: *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_item_unset_autoselect_value(data: *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_first(data: *mut obs_data_t) -> *mut obs_data_item_t;
}
extern "C" {
    pub fn obs_data_item_byname(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_data_item_t;
}
extern "C" {
    pub fn obs_data_item_next(item: *mut *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_release(item: *mut *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_item_remove(item: *mut *mut obs_data_item_t);
}
extern "C" {
    pub fn obs_data_item_gettype(item: *mut obs_data_item_t) -> obs_data_type;
}
extern "C" {
    pub fn obs_data_item_numtype(item: *mut obs_data_item_t) -> obs_data_number_type;
}
extern "C" {
    pub fn obs_data_item_get_name(item: *mut obs_data_item_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_item_set_string(
        item: *mut *mut obs_data_item_t,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_int(item: *mut *mut obs_data_item_t, val: ::std::os::raw::c_longlong);
}
extern "C" {
    pub fn obs_data_item_set_double(item: *mut *mut obs_data_item_t, val: f64);
}
extern "C" {
    pub fn obs_data_item_set_bool(item: *mut *mut obs_data_item_t, val: bool);
}
extern "C" {
    pub fn obs_data_item_set_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_item_set_array(item: *mut *mut obs_data_item_t, val: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_data_item_set_default_string(
        item: *mut *mut obs_data_item_t,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_default_int(
        item: *mut *mut obs_data_item_t,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_item_set_default_double(item: *mut *mut obs_data_item_t, val: f64);
}
extern "C" {
    pub fn obs_data_item_set_default_bool(item: *mut *mut obs_data_item_t, val: bool);
}
extern "C" {
    pub fn obs_data_item_set_default_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_item_set_default_array(
        item: *mut *mut obs_data_item_t,
        val: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_item_set_autoselect_string(
        item: *mut *mut obs_data_item_t,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_autoselect_int(
        item: *mut *mut obs_data_item_t,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_data_item_set_autoselect_double(item: *mut *mut obs_data_item_t, val: f64);
}
extern "C" {
    pub fn obs_data_item_set_autoselect_bool(item: *mut *mut obs_data_item_t, val: bool);
}
extern "C" {
    pub fn obs_data_item_set_autoselect_obj(item: *mut *mut obs_data_item_t, val: *mut obs_data_t);
}
extern "C" {
    pub fn obs_data_item_set_autoselect_array(
        item: *mut *mut obs_data_item_t,
        val: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_data_item_get_string(item: *mut obs_data_item_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_item_get_int(item: *mut obs_data_item_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_item_get_double(item: *mut obs_data_item_t) -> f64;
}
extern "C" {
    pub fn obs_data_item_get_bool(item: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_item_get_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_item_get_default_string(
        item: *mut obs_data_item_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_item_get_default_int(item: *mut obs_data_item_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_item_get_default_double(item: *mut obs_data_item_t) -> f64;
}
extern "C" {
    pub fn obs_data_item_get_default_bool(item: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_default_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_item_get_default_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_string(
        item: *mut obs_data_item_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_int(
        item: *mut obs_data_item_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_double(item: *mut obs_data_item_t) -> f64;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_bool(item: *mut obs_data_item_t) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_obj(item: *mut obs_data_item_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_array(item: *mut obs_data_item_t) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_data_set_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec2,
    );
}
extern "C" {
    pub fn obs_data_set_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec3,
    );
}
extern "C" {
    pub fn obs_data_set_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec4,
    );
}
extern "C" {
    pub fn obs_data_set_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const quat,
    );
}
extern "C" {
    pub fn obs_data_set_default_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec2,
    );
}
extern "C" {
    pub fn obs_data_set_default_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec3,
    );
}
extern "C" {
    pub fn obs_data_set_default_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec4,
    );
}
extern "C" {
    pub fn obs_data_set_default_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const quat,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec2,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec3,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const vec4,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *const quat,
    );
}
extern "C" {
    pub fn obs_data_get_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec2,
    );
}
extern "C" {
    pub fn obs_data_get_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec3,
    );
}
extern "C" {
    pub fn obs_data_get_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec4,
    );
}
extern "C" {
    pub fn obs_data_get_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut quat,
    );
}
extern "C" {
    pub fn obs_data_get_default_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec2,
    );
}
extern "C" {
    pub fn obs_data_get_default_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec3,
    );
}
extern "C" {
    pub fn obs_data_get_default_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec4,
    );
}
extern "C" {
    pub fn obs_data_get_default_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut quat,
    );
}
extern "C" {
    pub fn obs_data_get_autoselect_vec2(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec2,
    );
}
extern "C" {
    pub fn obs_data_get_autoselect_vec3(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec3,
    );
}
extern "C" {
    pub fn obs_data_get_autoselect_vec4(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut vec4,
    );
}
extern "C" {
    pub fn obs_data_get_autoselect_quat(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        val: *mut quat,
    );
}
extern "C" {
    pub fn obs_data_set_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_default_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_set_autoselect_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_get_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_get_default_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_get_autoselect_frames_per_second(
        data: *mut obs_data_t,
        name: *const ::std::os::raw::c_char,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_item_set_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_default_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_set_autoselect_frames_per_second(
        item: *mut *mut obs_data_item_t,
        fps: media_frames_per_second,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_data_item_get_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_default_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_data_item_get_autoselect_frames_per_second(
        item: *mut obs_data_item_t,
        fps: *mut media_frames_per_second,
        option: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
#[doc = " Modal UI definition structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_modal_ui {
    #[doc = "< Identifier associated with this UI"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< Task of the UI"]
    pub task: *const ::std::os::raw::c_char,
    #[doc = "< UI target (UI toolkit or program name)"]
    pub target: *const ::std::os::raw::c_char,
    #[doc = " Callback to execute modal interface."]
    #[doc = ""]
    #[doc = " The @b object variable points to the input/output/encoder/etc.  The"]
    #[doc = " @b ui_data variable points to the UI parent or UI-specific data to"]
    #[doc = " be used with the custom user interface."]
    #[doc = ""]
    #[doc = " What @b ui_data points to differs depending on the target, and you"]
    #[doc = " should use discretion and consistency when using this variable to"]
    #[doc = " relay information to the UI function.  For example, it would be"]
    #[doc = " ideal to have @b ui_data point to a parent, QWidget for Qt, or a"]
    #[doc = " wxWindow for wxWidgets, etc., though it's up to the discretion of"]
    #[doc = " the developer to define that value.  Because of the nature of void"]
    #[doc = " pointers, discretion and consistency is advised."]
    #[doc = ""]
    #[doc = " @param  object   Pointer/handle to the data associated with this"]
    #[doc = "                  call."]
    #[doc = " @param  ui_data  UI data to pass associated with this specific"]
    #[doc = "                  target, if any."]
    #[doc = " @return          @b true if user completed the task, or"]
    #[doc = "                  @b false if user cancelled the task."]
    pub exec: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ui_data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_obs_modal_ui() {
    assert_eq!(
        ::std::mem::size_of::<obs_modal_ui>(),
        48usize,
        concat!("Size of: ", stringify!(obs_modal_ui))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_modal_ui>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_modal_ui))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modal_ui>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modal_ui>())).task as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modal_ui>())).target as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modal_ui>())).exec as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(exec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modal_ui>())).type_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modal_ui>())).free_type_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modal_ui),
            "::",
            stringify!(free_type_data)
        )
    );
}
impl Default for obs_modal_ui {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Registers a modal UI definition to the current obs context.  This should be"]
    #[doc = " used in obs_module_load."]
    #[doc = ""]
    #[doc = " @param  info  Pointer to the modal definition structure"]
    pub fn obs_register_modal_ui(info: *const obs_modal_ui);
}
#[doc = " Modeless UI definition structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_modeless_ui {
    #[doc = "< Identifier associated with this UI"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< Task of the UI"]
    pub task: *const ::std::os::raw::c_char,
    #[doc = "< UI target (UI toolkit or program name)"]
    pub target: *const ::std::os::raw::c_char,
    #[doc = " Callback to create modeless interface."]
    #[doc = ""]
    #[doc = " This function is almost identical to the modal exec function,"]
    #[doc = " except modeless UI calls return immediately, and typically are"]
    #[doc = " supposed to return a pointer or handle to the specific UI object"]
    #[doc = " that was created.  For example, a Qt object would ideally return a"]
    #[doc = " pointer to a QWidget.  Again, discretion and consistency is advised"]
    #[doc = " for the return value."]
    #[doc = ""]
    #[doc = " @param   object  Pointer/handle to the data associated with this"]
    #[doc = "                  call."]
    #[doc = " @param  ui_data  UI data to pass associated with this specific"]
    #[doc = "                  target, if any."]
    #[doc = " @return          Pointer/handle to the modeless UI associated with"]
    #[doc = "                  the specific target."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ui_data: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_obs_modeless_ui() {
    assert_eq!(
        ::std::mem::size_of::<obs_modeless_ui>(),
        48usize,
        concat!("Size of: ", stringify!(obs_modeless_ui))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_modeless_ui>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_modeless_ui))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modeless_ui>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modeless_ui>())).task as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modeless_ui>())).target as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modeless_ui>())).create as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modeless_ui>())).type_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_modeless_ui>())).free_type_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_modeless_ui),
            "::",
            stringify!(free_type_data)
        )
    );
}
impl Default for obs_modeless_ui {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Registers a modeless UI definition to the current obs context.  This should"]
    #[doc = " be used in obs_module_load."]
    #[doc = ""]
    #[doc = " @param  info  Pointer to the modal definition structure"]
    pub fn obs_register_modeless_ui(info: *const obs_modeless_ui);
}
extern "C" {
    #[doc = " Requests modal UI to be displayed.  Returns when user is complete."]
    #[doc = ""]
    #[doc = " @param    name  Name of the input/output/etc type that UI was requested for"]
    #[doc = " @param    task  Task of the user interface (usually \"config\")"]
    #[doc = " @param  target  Desired target (i.e. \"qt\", \"wx\", \"gtk3\", \"win32\", etc)"]
    #[doc = " @param    data  Pointer to the obs input/output/etc"]
    #[doc = " @param ui_data  UI-specific data, usually a parent pointer/handle (if any)"]
    #[doc = ""]
    #[doc = " @return         OBS_UI_SUCCESS if the UI was successful,"]
    #[doc = "                 OBS_UI_CANCEL if the UI was cancelled by the user, or"]
    #[doc = "                 OBS_UI_NOTFOUND if the UI callback was not found"]
    pub fn obs_exec_ui(
        id: *const ::std::os::raw::c_char,
        task: *const ::std::os::raw::c_char,
        target: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        ui_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Requests modeless UI to be created.  Returns immediately."]
    #[doc = ""]
    #[doc = " @param    name  Name of the input/output/etc type that UI was requested for"]
    #[doc = " @param    task  Task of the user interface"]
    #[doc = " @param  target  Desired target (i.e. \"qt\", \"wx\", \"gtk3\", \"win32\", etc)"]
    #[doc = " @param    data  Pointer to the obs input/output/etc"]
    #[doc = " @param ui_data  UI-specific data, usually a parent pointer/handle (if any)"]
    #[doc = ""]
    #[doc = " @return         Pointer/handle to the target-specific modeless object, or"]
    #[doc = "                 NULL if not found or failed."]
    pub fn obs_create_ui(
        id: *const ::std::os::raw::c_char,
        task: *const ::std::os::raw::c_char,
        target: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        ui_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub const obs_property_type_OBS_PROPERTY_INVALID: obs_property_type = 0;
pub const obs_property_type_OBS_PROPERTY_BOOL: obs_property_type = 1;
pub const obs_property_type_OBS_PROPERTY_INT: obs_property_type = 2;
pub const obs_property_type_OBS_PROPERTY_FLOAT: obs_property_type = 3;
pub const obs_property_type_OBS_PROPERTY_TEXT: obs_property_type = 4;
pub const obs_property_type_OBS_PROPERTY_PATH: obs_property_type = 5;
pub const obs_property_type_OBS_PROPERTY_LIST: obs_property_type = 6;
pub const obs_property_type_OBS_PROPERTY_COLOR: obs_property_type = 7;
pub const obs_property_type_OBS_PROPERTY_BUTTON: obs_property_type = 8;
pub const obs_property_type_OBS_PROPERTY_FONT: obs_property_type = 9;
pub const obs_property_type_OBS_PROPERTY_EDITABLE_LIST: obs_property_type = 10;
pub const obs_property_type_OBS_PROPERTY_FRAME_RATE: obs_property_type = 11;
pub const obs_property_type_OBS_PROPERTY_GROUP: obs_property_type = 12;
pub type obs_property_type = u32;
pub const obs_combo_format_OBS_COMBO_FORMAT_INVALID: obs_combo_format = 0;
pub const obs_combo_format_OBS_COMBO_FORMAT_INT: obs_combo_format = 1;
pub const obs_combo_format_OBS_COMBO_FORMAT_FLOAT: obs_combo_format = 2;
pub const obs_combo_format_OBS_COMBO_FORMAT_STRING: obs_combo_format = 3;
pub type obs_combo_format = u32;
pub const obs_combo_type_OBS_COMBO_TYPE_INVALID: obs_combo_type = 0;
pub const obs_combo_type_OBS_COMBO_TYPE_EDITABLE: obs_combo_type = 1;
pub const obs_combo_type_OBS_COMBO_TYPE_LIST: obs_combo_type = 2;
pub type obs_combo_type = u32;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_STRINGS: obs_editable_list_type = 0;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_FILES: obs_editable_list_type = 1;
pub const obs_editable_list_type_OBS_EDITABLE_LIST_TYPE_FILES_AND_URLS: obs_editable_list_type = 2;
pub type obs_editable_list_type = u32;
pub const obs_path_type_OBS_PATH_FILE: obs_path_type = 0;
pub const obs_path_type_OBS_PATH_FILE_SAVE: obs_path_type = 1;
pub const obs_path_type_OBS_PATH_DIRECTORY: obs_path_type = 2;
pub type obs_path_type = u32;
pub const obs_text_type_OBS_TEXT_DEFAULT: obs_text_type = 0;
pub const obs_text_type_OBS_TEXT_PASSWORD: obs_text_type = 1;
pub const obs_text_type_OBS_TEXT_MULTILINE: obs_text_type = 2;
pub type obs_text_type = u32;
pub const obs_number_type_OBS_NUMBER_SCROLLER: obs_number_type = 0;
pub const obs_number_type_OBS_NUMBER_SLIDER: obs_number_type = 1;
pub type obs_number_type = u32;
pub const obs_group_type_OBS_COMBO_INVALID: obs_group_type = 0;
pub const obs_group_type_OBS_GROUP_NORMAL: obs_group_type = 1;
pub const obs_group_type_OBS_GROUP_CHECKABLE: obs_group_type = 2;
pub type obs_group_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_properties {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_property {
    _unused: [u8; 0],
}
pub type obs_properties_t = obs_properties;
pub type obs_property_t = obs_property;
extern "C" {
    pub fn obs_properties_create() -> *mut obs_properties_t;
}
extern "C" {
    pub fn obs_properties_create_param(
        param: *mut ::std::os::raw::c_void,
        destroy: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
    ) -> *mut obs_properties_t;
}
extern "C" {
    pub fn obs_properties_destroy(props: *mut obs_properties_t);
}
extern "C" {
    pub fn obs_properties_set_flags(props: *mut obs_properties_t, flags: u32);
}
extern "C" {
    pub fn obs_properties_get_flags(props: *mut obs_properties_t) -> u32;
}
extern "C" {
    pub fn obs_properties_set_param(
        props: *mut obs_properties_t,
        param: *mut ::std::os::raw::c_void,
        destroy: ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn obs_properties_get_param(props: *mut obs_properties_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_properties_first(props: *mut obs_properties_t) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_get(
        props: *mut obs_properties_t,
        property: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_get_parent(props: *mut obs_properties_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Remove a property from a properties list."]
    #[doc = ""]
    #[doc = " Removes a property from a properties list. Only valid in either"]
    #[doc = " get_properties or modified_callback(2). modified_callback(2) must return"]
    #[doc = " true so that all UI properties are rebuilt and returning false is undefined"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param props Properties to remove from."]
    #[doc = " @param property Name of the property to remove."]
    pub fn obs_properties_remove_by_name(
        props: *mut obs_properties_t,
        property: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Applies settings to the properties by calling all the necessary"]
    #[doc = " modification callbacks"]
    pub fn obs_properties_apply_settings(props: *mut obs_properties_t, settings: *mut obs_data_t);
}
#[doc = " Callback for when a button property is clicked.  If the properties"]
#[doc = " need to be refreshed due to changes to the property layout, return true,"]
#[doc = " otherwise return false."]
pub type obs_property_clicked_t = ::std::option::Option<
    unsafe extern "C" fn(
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn obs_properties_add_bool(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_int(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_float(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: f64,
        max: f64,
        step: f64,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_int_slider(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_float_slider(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        min: f64,
        max: f64,
        step: f64,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_text(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_text_type,
    ) -> *mut obs_property_t;
}
extern "C" {
    #[doc = " Adds a 'path' property.  Can be a directory or a file."]
    #[doc = ""]
    #[doc = " If target is a file path, the filters should be this format, separated by"]
    #[doc = " double semi-colens, and extensions separated by space:"]
    #[doc = "   \"Example types 1 and 2 (*.ex1 *.ex2);;Example type 3 (*.ex3)\""]
    #[doc = ""]
    #[doc = " @param  props        Properties object"]
    #[doc = " @param  name         Settings name"]
    #[doc = " @param  description  Description (display name) of the property"]
    #[doc = " @param  type         Type of path (directory or file)"]
    #[doc = " @param  filter       If type is a file path, then describes the file filter"]
    #[doc = "                      that the user can browse.  Items are separated via"]
    #[doc = "                      double semi-colens.  If multiple file types in a"]
    #[doc = "                      filter, separate with space."]
    pub fn obs_properties_add_path(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_path_type,
        filter: *const ::std::os::raw::c_char,
        default_path: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_list(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_combo_type,
        format: obs_combo_format,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_color(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_button(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
        callback: obs_property_clicked_t,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_button2(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
        callback: obs_property_clicked_t,
        priv_: *mut ::std::os::raw::c_void,
    ) -> *mut obs_property_t;
}
extern "C" {
    #[doc = " Adds a font selection property."]
    #[doc = ""]
    #[doc = " A font is an obs_data sub-object which contains the following items:"]
    #[doc = "   face:   face name string"]
    #[doc = "   style:  style name string"]
    #[doc = "   size:   size integer"]
    #[doc = "   flags:  font flags integer (OBS_FONT_* defined above)"]
    pub fn obs_properties_add_font(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_editable_list(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_editable_list_type,
        filter: *const ::std::os::raw::c_char,
        default_path: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_frame_rate(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> *mut obs_property_t;
}
extern "C" {
    pub fn obs_properties_add_group(
        props: *mut obs_properties_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: obs_group_type,
        group: *mut obs_properties_t,
    ) -> *mut obs_property_t;
}
#[doc = " Optional callback for when a property is modified.  If the properties"]
#[doc = " need to be refreshed due to changes to the property layout, return true,"]
#[doc = " otherwise return false."]
pub type obs_property_modified_t = ::std::option::Option<
    unsafe extern "C" fn(
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        settings: *mut obs_data_t,
    ) -> bool,
>;
pub type obs_property_modified2_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        props: *mut obs_properties_t,
        property: *mut obs_property_t,
        settings: *mut obs_data_t,
    ) -> bool,
>;
extern "C" {
    pub fn obs_property_set_modified_callback(
        p: *mut obs_property_t,
        modified: obs_property_modified_t,
    );
}
extern "C" {
    pub fn obs_property_set_modified_callback2(
        p: *mut obs_property_t,
        modified: obs_property_modified2_t,
        priv_: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_property_modified(p: *mut obs_property_t, settings: *mut obs_data_t) -> bool;
}
extern "C" {
    pub fn obs_property_button_clicked(
        p: *mut obs_property_t,
        obj: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn obs_property_set_visible(p: *mut obs_property_t, visible: bool);
}
extern "C" {
    pub fn obs_property_set_enabled(p: *mut obs_property_t, enabled: bool);
}
extern "C" {
    pub fn obs_property_set_description(
        p: *mut obs_property_t,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_set_long_description(
        p: *mut obs_property_t,
        long_description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_name(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_description(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_long_description(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_get_type(p: *mut obs_property_t) -> obs_property_type;
}
extern "C" {
    pub fn obs_property_enabled(p: *mut obs_property_t) -> bool;
}
extern "C" {
    pub fn obs_property_visible(p: *mut obs_property_t) -> bool;
}
extern "C" {
    pub fn obs_property_next(p: *mut *mut obs_property_t) -> bool;
}
extern "C" {
    pub fn obs_property_int_min(p: *mut obs_property_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_property_int_max(p: *mut obs_property_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_property_int_step(p: *mut obs_property_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_property_int_type(p: *mut obs_property_t) -> obs_number_type;
}
extern "C" {
    pub fn obs_property_int_suffix(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_float_min(p: *mut obs_property_t) -> f64;
}
extern "C" {
    pub fn obs_property_float_max(p: *mut obs_property_t) -> f64;
}
extern "C" {
    pub fn obs_property_float_step(p: *mut obs_property_t) -> f64;
}
extern "C" {
    pub fn obs_property_float_type(p: *mut obs_property_t) -> obs_number_type;
}
extern "C" {
    pub fn obs_property_float_suffix(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_text_type(p: *mut obs_property_t) -> obs_text_type;
}
extern "C" {
    pub fn obs_property_text_monospace(p: *mut obs_property_t) -> obs_text_type;
}
extern "C" {
    pub fn obs_property_path_type(p: *mut obs_property_t) -> obs_path_type;
}
extern "C" {
    pub fn obs_property_path_filter(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_path_default_path(p: *mut obs_property_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_list_type(p: *mut obs_property_t) -> obs_combo_type;
}
extern "C" {
    pub fn obs_property_list_format(p: *mut obs_property_t) -> obs_combo_format;
}
extern "C" {
    pub fn obs_property_int_set_limits(
        p: *mut obs_property_t,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        step: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn obs_property_float_set_limits(p: *mut obs_property_t, min: f64, max: f64, step: f64);
}
extern "C" {
    pub fn obs_property_int_set_suffix(
        p: *mut obs_property_t,
        suffix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_float_set_suffix(
        p: *mut obs_property_t,
        suffix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_text_set_monospace(p: *mut obs_property_t, monospace: bool);
}
extern "C" {
    pub fn obs_property_list_clear(p: *mut obs_property_t);
}
extern "C" {
    pub fn obs_property_list_add_string(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn obs_property_list_add_int(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    ) -> size_t;
}
extern "C" {
    pub fn obs_property_list_add_float(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    ) -> size_t;
}
extern "C" {
    pub fn obs_property_list_insert_string(
        p: *mut obs_property_t,
        idx: size_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_list_insert_int(
        p: *mut obs_property_t,
        idx: size_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn obs_property_list_insert_float(
        p: *mut obs_property_t,
        idx: size_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    pub fn obs_property_list_item_disable(p: *mut obs_property_t, idx: size_t, disabled: bool);
}
extern "C" {
    pub fn obs_property_list_item_disabled(p: *mut obs_property_t, idx: size_t) -> bool;
}
extern "C" {
    pub fn obs_property_list_item_remove(p: *mut obs_property_t, idx: size_t);
}
extern "C" {
    pub fn obs_property_list_item_count(p: *mut obs_property_t) -> size_t;
}
extern "C" {
    pub fn obs_property_list_item_name(
        p: *mut obs_property_t,
        idx: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_list_item_string(
        p: *mut obs_property_t,
        idx: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_list_item_int(
        p: *mut obs_property_t,
        idx: size_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn obs_property_list_item_float(p: *mut obs_property_t, idx: size_t) -> f64;
}
extern "C" {
    pub fn obs_property_editable_list_type(p: *mut obs_property_t) -> obs_editable_list_type;
}
extern "C" {
    pub fn obs_property_editable_list_filter(
        p: *mut obs_property_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_editable_list_default_path(
        p: *mut obs_property_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_frame_rate_clear(p: *mut obs_property_t);
}
extern "C" {
    pub fn obs_property_frame_rate_options_clear(p: *mut obs_property_t);
}
extern "C" {
    pub fn obs_property_frame_rate_fps_ranges_clear(p: *mut obs_property_t);
}
extern "C" {
    pub fn obs_property_frame_rate_option_add(
        p: *mut obs_property_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn obs_property_frame_rate_fps_range_add(
        p: *mut obs_property_t,
        min: media_frames_per_second,
        max: media_frames_per_second,
    ) -> size_t;
}
extern "C" {
    pub fn obs_property_frame_rate_option_insert(
        p: *mut obs_property_t,
        idx: size_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_property_frame_rate_fps_range_insert(
        p: *mut obs_property_t,
        idx: size_t,
        min: media_frames_per_second,
        max: media_frames_per_second,
    );
}
extern "C" {
    pub fn obs_property_frame_rate_options_count(p: *mut obs_property_t) -> size_t;
}
extern "C" {
    pub fn obs_property_frame_rate_option_name(
        p: *mut obs_property_t,
        idx: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_frame_rate_option_description(
        p: *mut obs_property_t,
        idx: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_property_frame_rate_fps_ranges_count(p: *mut obs_property_t) -> size_t;
}
extern "C" {
    pub fn obs_property_frame_rate_fps_range_min(
        p: *mut obs_property_t,
        idx: size_t,
    ) -> media_frames_per_second;
}
extern "C" {
    pub fn obs_property_frame_rate_fps_range_max(
        p: *mut obs_property_t,
        idx: size_t,
    ) -> media_frames_per_second;
}
extern "C" {
    pub fn obs_property_group_type(p: *mut obs_property_t) -> obs_group_type;
}
extern "C" {
    pub fn obs_property_group_content(p: *mut obs_property_t) -> *mut obs_properties_t;
}
extern "C" {
    pub fn obs_proprety_text_type(p: *mut obs_property_t) -> obs_text_type;
}
pub const obs_interaction_flags_INTERACT_NONE: obs_interaction_flags = 0;
pub const obs_interaction_flags_INTERACT_CAPS_KEY: obs_interaction_flags = 1;
pub const obs_interaction_flags_INTERACT_SHIFT_KEY: obs_interaction_flags = 2;
pub const obs_interaction_flags_INTERACT_CONTROL_KEY: obs_interaction_flags = 4;
pub const obs_interaction_flags_INTERACT_ALT_KEY: obs_interaction_flags = 8;
pub const obs_interaction_flags_INTERACT_MOUSE_LEFT: obs_interaction_flags = 16;
pub const obs_interaction_flags_INTERACT_MOUSE_MIDDLE: obs_interaction_flags = 32;
pub const obs_interaction_flags_INTERACT_MOUSE_RIGHT: obs_interaction_flags = 64;
pub const obs_interaction_flags_INTERACT_COMMAND_KEY: obs_interaction_flags = 128;
pub const obs_interaction_flags_INTERACT_NUMLOCK_KEY: obs_interaction_flags = 256;
pub const obs_interaction_flags_INTERACT_IS_KEY_PAD: obs_interaction_flags = 512;
pub const obs_interaction_flags_INTERACT_IS_LEFT: obs_interaction_flags = 1024;
pub const obs_interaction_flags_INTERACT_IS_RIGHT: obs_interaction_flags = 2048;
pub type obs_interaction_flags = u32;
pub const obs_mouse_button_type_MOUSE_LEFT: obs_mouse_button_type = 0;
pub const obs_mouse_button_type_MOUSE_MIDDLE: obs_mouse_button_type = 1;
pub const obs_mouse_button_type_MOUSE_RIGHT: obs_mouse_button_type = 2;
pub type obs_mouse_button_type = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct obs_mouse_event {
    pub modifiers: u32,
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_obs_mouse_event() {
    assert_eq!(
        ::std::mem::size_of::<obs_mouse_event>(),
        12usize,
        concat!("Size of: ", stringify!(obs_mouse_event))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_mouse_event>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_mouse_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_mouse_event>())).modifiers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_mouse_event),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_mouse_event>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_mouse_event),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_mouse_event>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_mouse_event),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_key_event {
    pub modifiers: u32,
    pub text: *mut ::std::os::raw::c_char,
    pub native_modifiers: u32,
    pub native_scancode: u32,
    pub native_vkey: u32,
}
#[test]
fn bindgen_test_layout_obs_key_event() {
    assert_eq!(
        ::std::mem::size_of::<obs_key_event>(),
        32usize,
        concat!("Size of: ", stringify!(obs_key_event))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_key_event>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_key_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_key_event>())).modifiers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_key_event>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_key_event>())).native_modifiers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(native_modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_key_event>())).native_scancode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(native_scancode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_key_event>())).native_vkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_event),
            "::",
            stringify!(native_vkey)
        )
    );
}
impl Default for obs_key_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_display {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_view {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_scene {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_scene_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_encoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_service {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_fader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_volmeter {
    _unused: [u8; 0],
}
pub type obs_display_t = obs_display;
pub type obs_view_t = obs_view;
pub type obs_source_t = obs_source;
pub type obs_scene_t = obs_scene;
pub type obs_sceneitem_t = obs_scene_item;
pub type obs_output_t = obs_output;
pub type obs_encoder_t = obs_encoder;
pub type obs_service_t = obs_service;
pub type obs_module_t = obs_module;
pub type obs_fader_t = obs_fader;
pub type obs_volmeter_t = obs_volmeter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_source {
    _unused: [u8; 0],
}
pub type obs_weak_source_t = obs_weak_source;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_output {
    _unused: [u8; 0],
}
pub type obs_weak_output_t = obs_weak_output;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_encoder {
    _unused: [u8; 0],
}
pub type obs_weak_encoder_t = obs_weak_encoder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_weak_service {
    _unused: [u8; 0],
}
pub type obs_weak_service_t = obs_weak_service;
pub const obs_source_type_OBS_SOURCE_TYPE_INPUT: obs_source_type = 0;
pub const obs_source_type_OBS_SOURCE_TYPE_FILTER: obs_source_type = 1;
pub const obs_source_type_OBS_SOURCE_TYPE_TRANSITION: obs_source_type = 2;
pub const obs_source_type_OBS_SOURCE_TYPE_SCENE: obs_source_type = 3;
pub type obs_source_type = u32;
pub const obs_balance_type_OBS_BALANCE_TYPE_SINE_LAW: obs_balance_type = 0;
pub const obs_balance_type_OBS_BALANCE_TYPE_SQUARE_LAW: obs_balance_type = 1;
pub const obs_balance_type_OBS_BALANCE_TYPE_LINEAR: obs_balance_type = 2;
pub type obs_balance_type = u32;
pub const obs_icon_type_OBS_ICON_TYPE_UNKNOWN: obs_icon_type = 0;
pub const obs_icon_type_OBS_ICON_TYPE_IMAGE: obs_icon_type = 1;
pub const obs_icon_type_OBS_ICON_TYPE_COLOR: obs_icon_type = 2;
pub const obs_icon_type_OBS_ICON_TYPE_SLIDESHOW: obs_icon_type = 3;
pub const obs_icon_type_OBS_ICON_TYPE_AUDIO_INPUT: obs_icon_type = 4;
pub const obs_icon_type_OBS_ICON_TYPE_AUDIO_OUTPUT: obs_icon_type = 5;
pub const obs_icon_type_OBS_ICON_TYPE_DESKTOP_CAPTURE: obs_icon_type = 6;
pub const obs_icon_type_OBS_ICON_TYPE_WINDOW_CAPTURE: obs_icon_type = 7;
pub const obs_icon_type_OBS_ICON_TYPE_GAME_CAPTURE: obs_icon_type = 8;
pub const obs_icon_type_OBS_ICON_TYPE_CAMERA: obs_icon_type = 9;
pub const obs_icon_type_OBS_ICON_TYPE_TEXT: obs_icon_type = 10;
pub const obs_icon_type_OBS_ICON_TYPE_MEDIA: obs_icon_type = 11;
pub const obs_icon_type_OBS_ICON_TYPE_BROWSER: obs_icon_type = 12;
pub const obs_icon_type_OBS_ICON_TYPE_CUSTOM: obs_icon_type = 13;
pub type obs_icon_type = u32;
pub const obs_media_state_OBS_MEDIA_STATE_NONE: obs_media_state = 0;
pub const obs_media_state_OBS_MEDIA_STATE_PLAYING: obs_media_state = 1;
pub const obs_media_state_OBS_MEDIA_STATE_OPENING: obs_media_state = 2;
pub const obs_media_state_OBS_MEDIA_STATE_BUFFERING: obs_media_state = 3;
pub const obs_media_state_OBS_MEDIA_STATE_PAUSED: obs_media_state = 4;
pub const obs_media_state_OBS_MEDIA_STATE_STOPPED: obs_media_state = 5;
pub const obs_media_state_OBS_MEDIA_STATE_ENDED: obs_media_state = 6;
pub const obs_media_state_OBS_MEDIA_STATE_ERROR: obs_media_state = 7;
pub type obs_media_state = u32;
#[doc = " @}"]
pub type obs_source_enum_proc_t = ::std::option::Option<
    unsafe extern "C" fn(
        parent: *mut obs_source_t,
        child: *mut obs_source_t,
        param: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_audio_mix {
    pub output: [audio_output_data; 6usize],
}
#[test]
fn bindgen_test_layout_obs_source_audio_mix() {
    assert_eq!(
        ::std::mem::size_of::<obs_source_audio_mix>(),
        384usize,
        concat!("Size of: ", stringify!(obs_source_audio_mix))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_audio_mix>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_audio_mix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_audio_mix>())).output as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio_mix),
            "::",
            stringify!(output)
        )
    );
}
impl Default for obs_source_audio_mix {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Source definition structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_info {
    #[doc = " Unique string identifier for the source"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = " Type of source."]
    #[doc = ""]
    #[doc = " OBS_SOURCE_TYPE_INPUT for input sources,"]
    #[doc = " OBS_SOURCE_TYPE_FILTER for filter sources, and"]
    #[doc = " OBS_SOURCE_TYPE_TRANSITION for transition sources."]
    pub type_: obs_source_type,
    #[doc = " Source output flags"]
    pub output_flags: u32,
    #[doc = " Get the translated name of the source type"]
    #[doc = ""]
    #[doc = " @param  type_data  The type_data variable of this structure"]
    #[doc = " @return               The translated name of the source type"]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            type_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Creates the source data for the source"]
    #[doc = ""]
    #[doc = " @param  settings  Settings to initialize the source with"]
    #[doc = " @param  source    Source that this data is associated with"]
    #[doc = " @return           The data associated with this source"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut obs_data_t,
            source: *mut obs_source_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroys the private data for the source"]
    #[doc = ""]
    #[doc = " Async sources must not call obs_source_output_video after returning"]
    #[doc = " from destroy"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Returns the width of the source.  Required if this is an input"]
    #[doc = " source and has non-async video"]
    pub get_width:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " Returns the height of the source.  Required if this is an input"]
    #[doc = " source and has non-async video"]
    pub get_height:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " Gets the default settings for this source"]
    #[doc = ""]
    #[doc = " @param[out]  settings  Data to assign default settings to"]
    #[doc = " @deprecated            Use get_defaults2 if type_data is needed"]
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    #[doc = " Gets the property information of this source"]
    #[doc = ""]
    #[doc = " @return         The properties data"]
    #[doc = " @deprecated     Use get_properties2 if type_data is needed"]
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t,
    >,
    #[doc = " Updates the settings for this source"]
    #[doc = ""]
    #[doc = " @param data      Source data"]
    #[doc = " @param settings  New settings for this source"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    #[doc = " Called when the source has been activated in the main view"]
    pub activate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source has been deactivated from the main view"]
    #[doc = " (no longer being played/displayed)"]
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source is visible"]
    pub show: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called when the source is no longer visible"]
    pub hide: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Called each video frame with the time elapsed"]
    #[doc = ""]
    #[doc = " @param  data     Source data"]
    #[doc = " @param  seconds  Seconds elapsed since the last frame"]
    pub video_tick: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, seconds: f32),
    >,
    #[doc = " Called when rendering the source with the graphics subsystem."]
    #[doc = ""]
    #[doc = " If this is an input/transition source, this is called to draw the"]
    #[doc = " source texture with the graphics subsystem using the specified"]
    #[doc = " effect."]
    #[doc = ""]
    #[doc = " If this is a filter source, it wraps source draw calls (for"]
    #[doc = " example applying a custom effect with custom parameters to a"]
    #[doc = " source).  In this case, it's highly recommended to use the"]
    #[doc = " obs_source_process_filter function to automatically handle"]
    #[doc = " effect-based filter processing.  However, you can implement custom"]
    #[doc = " draw handling as desired as well."]
    #[doc = ""]
    #[doc = " If the source output flags do not include SOURCE_CUSTOM_DRAW, all"]
    #[doc = " a source needs to do is set the \"image\" parameter of the effect to"]
    #[doc = " the desired texture, and then draw.  If the output flags include"]
    #[doc = " SOURCE_COLOR_MATRIX, you may optionally set the \"color_matrix\""]
    #[doc = " parameter of the effect to a custom 4x4 conversion matrix (by"]
    #[doc = " default it will be set to an YUV->RGB conversion matrix)"]
    #[doc = ""]
    #[doc = " @param data    Source data"]
    #[doc = " @param effect  Effect to be used with this source.  If the source"]
    #[doc = "                output flags include SOURCE_CUSTOM_DRAW, this will"]
    #[doc = "                be NULL, and the source is expected to process with"]
    #[doc = "                an effect manually."]
    pub video_render: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, effect: *mut gs_effect_t),
    >,
    #[doc = " Called to filter raw async video data."]
    #[doc = ""]
    #[doc = " @note          This function is only used with filter sources."]
    #[doc = ""]
    #[doc = " @param  data   Filter data"]
    #[doc = " @param  frame  Video frame to filter"]
    #[doc = " @return        New video frame data.  This can defer video data to"]
    #[doc = "                be drawn later if time is needed for processing"]
    pub filter_video: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            frame: *mut obs_source_frame,
        ) -> *mut obs_source_frame,
    >,
    #[doc = " Called to filter raw audio data."]
    #[doc = ""]
    #[doc = " @note          This function is only used with filter sources."]
    #[doc = ""]
    #[doc = " @param  data   Filter data"]
    #[doc = " @param  audio  Audio data to filter."]
    #[doc = " @return        Modified or new audio data.  You can directly modify"]
    #[doc = "                the data passed and return it, or you can defer audio"]
    #[doc = "                data for later if time is needed for processing.  If"]
    #[doc = "                you are returning new data, that data must exist"]
    #[doc = "                until the next call to the filter_audio callback or"]
    #[doc = "                until the filter is removed/destroyed."]
    pub filter_audio: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            audio: *mut obs_audio_data,
        ) -> *mut obs_audio_data,
    >,
    #[doc = " Called to enumerate all active sources being used within this"]
    #[doc = " source.  If the source has children that render audio/video it must"]
    #[doc = " implement this callback."]
    #[doc = ""]
    #[doc = " @param  data           Filter data"]
    #[doc = " @param  enum_callback  Enumeration callback"]
    #[doc = " @param  param          User data to pass to callback"]
    pub enum_active_sources: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            enum_callback: obs_source_enum_proc_t,
            param: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Called when saving a source.  This is a separate function because"]
    #[doc = " sometimes a source needs to know when it is being saved so it"]
    #[doc = " doesn't always have to update the current settings until a certain"]
    #[doc = " point."]
    #[doc = ""]
    #[doc = " @param  data      Source data"]
    #[doc = " @param  settings  Settings"]
    pub save: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    #[doc = " Called when loading a source from saved data.  This should be called"]
    #[doc = " after all the loading sources have actually been created because"]
    #[doc = " sometimes there are sources that depend on each other."]
    #[doc = ""]
    #[doc = " @param  data      Source data"]
    #[doc = " @param  settings  Settings"]
    pub load: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    #[doc = " Called when interacting with a source and a mouse-down or mouse-up"]
    #[doc = " occurs."]
    #[doc = ""]
    #[doc = " @param data         Source data"]
    #[doc = " @param event        Mouse event properties"]
    #[doc = " @param type         Mouse button pushed"]
    #[doc = " @param mouse_up     Mouse event type (true if mouse-up)"]
    #[doc = " @param click_count  Mouse click count (1 for single click, etc.)"]
    pub mouse_click: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_mouse_event,
            type_: i32,
            mouse_up: bool,
            click_count: u32,
        ),
    >,
    #[doc = " Called when interacting with a source and a mouse-move occurs."]
    #[doc = ""]
    #[doc = " @param data         Source data"]
    #[doc = " @param event        Mouse event properties"]
    #[doc = " @param mouse_leave  Mouse leave state (true if mouse left source)"]
    pub mouse_move: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_mouse_event,
            mouse_leave: bool,
        ),
    >,
    #[doc = " Called when interacting with a source and a mouse-wheel occurs."]
    #[doc = ""]
    #[doc = " @param data         Source data"]
    #[doc = " @param event        Mouse event properties"]
    #[doc = " @param x_delta      Movement delta in the horizontal direction"]
    #[doc = " @param y_delta      Movement delta in the vertical direction"]
    pub mouse_wheel: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_mouse_event,
            x_delta: ::std::os::raw::c_int,
            y_delta: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Called when interacting with a source and gain focus/lost focus event"]
    #[doc = " occurs."]
    #[doc = ""]
    #[doc = " @param data         Source data"]
    #[doc = " @param focus        Focus state (true if focus gained)"]
    pub focus:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, focus: bool)>,
    #[doc = " Called when interacting with a source and a key-up or key-down"]
    #[doc = " occurs."]
    #[doc = ""]
    #[doc = " @param data         Source data"]
    #[doc = " @param event        Key event properties"]
    #[doc = " @param focus        Key event type (true if mouse-up)"]
    pub key_click: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const obs_key_event,
            key_up: bool,
        ),
    >,
    #[doc = " Called when the filter is removed from a source"]
    #[doc = ""]
    #[doc = " @param  data    Filter data"]
    #[doc = " @param  source  Source that the filter being removed from"]
    pub filter_remove: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, source: *mut obs_source_t),
    >,
    #[doc = " Private data associated with this entry"]
    pub type_data: *mut ::std::os::raw::c_void,
    #[doc = " If defined, called to free private data on shutdown"]
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub audio_render: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            ts_out: *mut u64,
            audio_output: *mut obs_source_audio_mix,
            mixers: u32,
            channels: size_t,
            sample_rate: size_t,
        ) -> bool,
    >,
    #[doc = " Called to enumerate all active and inactive sources being used"]
    #[doc = " within this source.  If this callback isn't implemented,"]
    #[doc = " enum_active_sources will be called instead."]
    #[doc = ""]
    #[doc = " This is typically used if a source can have inactive child sources."]
    #[doc = ""]
    #[doc = " @param  data           Filter data"]
    #[doc = " @param  enum_callback  Enumeration callback"]
    #[doc = " @param  param          User data to pass to callback"]
    pub enum_all_sources: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            enum_callback: obs_source_enum_proc_t,
            param: *mut ::std::os::raw::c_void,
        ),
    >,
    pub transition_start:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub transition_stop:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Gets the default settings for this source"]
    #[doc = ""]
    #[doc = " If get_defaults is also defined both will be called, and the first"]
    #[doc = " call will be to get_defaults, then to get_defaults2."]
    #[doc = ""]
    #[doc = " @param       type_data The type_data variable of this structure"]
    #[doc = " @param[out]  settings  Data to assign default settings to"]
    pub get_defaults2: ::std::option::Option<
        unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    #[doc = " Gets the property information of this source"]
    #[doc = ""]
    #[doc = " @param data      Source data"]
    #[doc = " @param type_data The type_data variable of this structure"]
    #[doc = " @return          The properties data"]
    pub get_properties2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            type_data: *mut ::std::os::raw::c_void,
        ) -> *mut obs_properties_t,
    >,
    pub audio_mix: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            ts_out: *mut u64,
            audio_output: *mut audio_output_data,
            channels: size_t,
            sample_rate: size_t,
        ) -> bool,
    >,
    #[doc = " Icon type for the source"]
    pub icon_type: obs_icon_type,
    #[doc = " Media controls"]
    pub media_play_pause:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, pause: bool)>,
    pub media_restart:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_stop: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_next: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_previous:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub media_get_duration:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> i64>,
    pub media_get_time:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> i64>,
    pub media_set_time: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, miliseconds: i64),
    >,
    pub media_get_state: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> obs_media_state,
    >,
    pub version: u32,
    pub unversioned_id: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_source_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_source_info>(),
        384usize,
        concat!("Size of: ", stringify!(obs_source_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).output_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(output_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).get_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).create as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).destroy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).get_width as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).get_height as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).get_defaults as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_defaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).get_properties as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).update as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).activate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).deactivate as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(deactivate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).show as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).hide as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(hide)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).video_tick as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(video_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).video_render as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(video_render)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).filter_video as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(filter_video)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).filter_audio as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(filter_audio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_info>())).enum_active_sources as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(enum_active_sources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).save as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(save)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).load as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).mouse_click as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(mouse_click)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).mouse_move as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(mouse_move)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).mouse_wheel as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(mouse_wheel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).focus as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).key_click as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(key_click)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).filter_remove as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(filter_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).type_data as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).free_type_data as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(free_type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).audio_render as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(audio_render)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_info>())).enum_all_sources as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(enum_all_sources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_info>())).transition_start as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(transition_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).transition_stop as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(transition_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).get_defaults2 as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_defaults2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).get_properties2 as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(get_properties2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).audio_mix as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(audio_mix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).icon_type as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(icon_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_info>())).media_play_pause as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_play_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).media_restart as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_restart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).media_stop as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).media_next as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).media_previous as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_previous)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_info>())).media_get_duration as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_get_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).media_get_time as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_get_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).media_set_time as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_set_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).media_get_state as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(media_get_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).version as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_info>())).unversioned_id as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_info),
            "::",
            stringify!(unversioned_id)
        )
    );
}
impl Default for obs_source_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn obs_register_source_s(info: *const obs_source_info, size: size_t);
}
#[doc = "< The encoder provides an audio codec"]
pub const obs_encoder_type_OBS_ENCODER_AUDIO: obs_encoder_type = 0;
#[doc = "< The encoder provides a video codec"]
pub const obs_encoder_type_OBS_ENCODER_VIDEO: obs_encoder_type = 1;
#[doc = " Specifies the encoder type"]
pub type obs_encoder_type = u32;
#[doc = " Encoder output packet"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct encoder_packet {
    #[doc = "< Packet data"]
    pub data: *mut u8,
    #[doc = "< Packet size"]
    pub size: size_t,
    #[doc = "< Presentation timestamp"]
    pub pts: i64,
    #[doc = "< Decode timestamp"]
    pub dts: i64,
    #[doc = "< Timebase numerator"]
    pub timebase_num: i32,
    #[doc = "< Timebase denominator"]
    pub timebase_den: i32,
    #[doc = "< Encoder type"]
    pub type_: obs_encoder_type,
    #[doc = "< Is a keyframe"]
    pub keyframe: bool,
    pub dts_usec: i64,
    pub sys_dts_usec: i64,
    #[doc = " Packet priority"]
    #[doc = ""]
    #[doc = " This is generally use by video encoders to specify the priority"]
    #[doc = " of the packet."]
    pub priority: ::std::os::raw::c_int,
    #[doc = " Dropped packet priority"]
    #[doc = ""]
    #[doc = " If this packet needs to be dropped, the next packet must be of this"]
    #[doc = " priority or higher to continue transmission."]
    pub drop_priority: ::std::os::raw::c_int,
    #[doc = " Audio track index (used with outputs)"]
    pub track_idx: size_t,
    #[doc = " Encoder from which the track originated from"]
    pub encoder: *mut obs_encoder_t,
}
#[test]
fn bindgen_test_layout_encoder_packet() {
    assert_eq!(
        ::std::mem::size_of::<encoder_packet>(),
        88usize,
        concat!("Size of: ", stringify!(encoder_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<encoder_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(encoder_packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).pts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).dts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).timebase_num as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(timebase_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).timebase_den as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(timebase_den)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).keyframe as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(keyframe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).dts_usec as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(dts_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).sys_dts_usec as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(sys_dts_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).priority as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).drop_priority as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(drop_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).track_idx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(track_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_packet>())).encoder as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_packet),
            "::",
            stringify!(encoder)
        )
    );
}
impl Default for encoder_packet {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Encoder input frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct encoder_frame {
    #[doc = " Data for the frame/audio"]
    pub data: [*mut u8; 8usize],
    #[doc = " size of each plane"]
    pub linesize: [u32; 8usize],
    #[doc = " Number of frames (audio only)"]
    pub frames: u32,
    #[doc = " Presentation timestamp"]
    pub pts: i64,
}
#[test]
fn bindgen_test_layout_encoder_frame() {
    assert_eq!(
        ::std::mem::size_of::<encoder_frame>(),
        112usize,
        concat!("Size of: ", stringify!(encoder_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<encoder_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(encoder_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_frame>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_frame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_frame>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_frame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_frame>())).frames as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_frame),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encoder_frame>())).pts as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(encoder_frame),
            "::",
            stringify!(pts)
        )
    );
}
impl Default for encoder_frame {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Encoder interface"]
#[doc = ""]
#[doc = " Encoders have a limited usage with OBS.  You are not generally supposed to"]
#[doc = " implement every encoder out there.  Generally, these are limited or specific"]
#[doc = " encoders for h264/aac for streaming and recording.  It doesn't have to be"]
#[doc = " *just* h264 or aac of course, but generally those are the expected encoders."]
#[doc = ""]
#[doc = " That being said, other encoders will be kept in mind for future use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_encoder_info {
    #[doc = " Specifies the named identifier of this encoder"]
    pub id: *const ::std::os::raw::c_char,
    #[doc = " Specifies the encoder type (video or audio)"]
    pub type_: obs_encoder_type,
    #[doc = " Specifies the codec"]
    pub codec: *const ::std::os::raw::c_char,
    #[doc = " Gets the full translated name of this encoder"]
    #[doc = ""]
    #[doc = " @param  type_data  The type_data variable of this structure"]
    #[doc = " @return            Translated name of the encoder"]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            type_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Creates the encoder with the specified settings"]
    #[doc = ""]
    #[doc = " @param  settings  Settings for the encoder"]
    #[doc = " @param  encoder   OBS encoder context"]
    #[doc = " @return           Data associated with this encoder context, or"]
    #[doc = "                   NULL if initialization failed."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut obs_data_t,
            encoder: *mut obs_encoder_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroys the encoder data"]
    #[doc = ""]
    #[doc = " @param  data  Data associated with this encoder context"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Encodes frame(s), and outputs encoded packets as they become"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " @param       data             Data associated with this encoder"]
    #[doc = "                               context"]
    #[doc = " @param[in]   frame            Raw audio/video data to encode"]
    #[doc = " @param[out]  packet           Encoder packet output, if any"]
    #[doc = " @param[out]  received_packet  Set to true if a packet was received,"]
    #[doc = "                               false otherwise"]
    #[doc = " @return                       true if successful, false otherwise."]
    pub encode: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            frame: *mut encoder_frame,
            packet: *mut encoder_packet,
            received_packet: *mut bool,
        ) -> bool,
    >,
    #[doc = " Audio encoder only:  Returns the frame size for this encoder"]
    pub get_frame_size:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> size_t>,
    #[doc = " Gets the default settings for this encoder"]
    #[doc = ""]
    #[doc = " @param[out]  settings  Data to assign default settings to"]
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    #[doc = " Gets the property information of this encoder"]
    #[doc = ""]
    #[doc = " @return         The properties data"]
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t,
    >,
    #[doc = " Updates the settings for this encoder (usually used for things like"]
    #[doc = " changing bitrate while active)"]
    #[doc = ""]
    #[doc = " @param  data      Data associated with this encoder context"]
    #[doc = " @param  settings  New settings for this encoder"]
    #[doc = " @return           true if successful, false otherwise"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t) -> bool,
    >,
    #[doc = " Returns extra data associated with this encoder (usually header)"]
    #[doc = ""]
    #[doc = " @param  data             Data associated with this encoder context"]
    #[doc = " @param[out]  extra_data  Pointer to receive the extra data"]
    #[doc = " @param[out]  size        Pointer to receive the size of the extra"]
    #[doc = "                          data"]
    #[doc = " @return                  true if extra data available, false"]
    #[doc = "                          otherwise"]
    pub get_extra_data: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            extra_data: *mut *mut u8,
            size: *mut size_t,
        ) -> bool,
    >,
    #[doc = " Gets the SEI data, if any"]
    #[doc = ""]
    #[doc = " @param       data      Data associated with this encoder context"]
    #[doc = " @param[out]  sei_data  Pointer to receive the SEI data"]
    #[doc = " @param[out]  size      Pointer to receive the SEI data size"]
    #[doc = " @return                true if SEI data available, false otherwise"]
    pub get_sei_data: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            sei_data: *mut *mut u8,
            size: *mut size_t,
        ) -> bool,
    >,
    #[doc = " Returns desired audio format and sample information"]
    #[doc = ""]
    #[doc = " @param          data  Data associated with this encoder context"]
    #[doc = " @param[in/out]  info  Audio format information"]
    pub get_audio_info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *mut audio_convert_info),
    >,
    #[doc = " Returns desired video format information"]
    #[doc = ""]
    #[doc = " @param          data  Data associated with this encoder context"]
    #[doc = " @param[in/out]  info  Video format information"]
    pub get_video_info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *mut video_scale_info),
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub caps: u32,
    #[doc = " Gets the default settings for this encoder"]
    #[doc = ""]
    #[doc = " If get_defaults is also defined both will be called, and the first"]
    #[doc = " call will be to get_defaults, then to get_defaults2."]
    #[doc = ""]
    #[doc = " @param[out]  settings  Data to assign default settings to"]
    #[doc = " @param[in]   typedata  Type Data"]
    pub get_defaults2: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut obs_data_t, type_data: *mut ::std::os::raw::c_void),
    >,
    #[doc = " Gets the property information of this encoder"]
    #[doc = ""]
    #[doc = " @param[in]   data      Pointer from create (or null)"]
    #[doc = " @param[in]   typedata  Type Data"]
    #[doc = " @return                The properties data"]
    pub get_properties2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            type_data: *mut ::std::os::raw::c_void,
        ) -> *mut obs_properties_t,
    >,
    pub encode_texture: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            handle: u32,
            pts: i64,
            lock_key: u64,
            next_key: *mut u64,
            packet: *mut encoder_packet,
            received_packet: *mut bool,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_obs_encoder_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_encoder_info>(),
        168usize,
        concat!("Size of: ", stringify!(obs_encoder_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_encoder_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_encoder_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).codec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).create as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).destroy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).encode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_frame_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_defaults as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_defaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_properties as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).update as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_extra_data as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_extra_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_sei_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_sei_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_audio_info as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_audio_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_video_info as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_video_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).type_data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).free_type_data as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(free_type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).caps as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).get_defaults2 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_defaults2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_encoder_info>())).get_properties2 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(get_properties2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_encoder_info>())).encode_texture as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_encoder_info),
            "::",
            stringify!(encode_texture)
        )
    );
}
impl Default for obs_encoder_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn obs_register_encoder_s(info: *const obs_encoder_info, size: size_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_output_info {
    pub id: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            type_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut obs_data_t,
            output: *mut obs_output_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub start:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    pub stop:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, ts: u64)>,
    pub raw_video: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, frame: *mut video_data),
    >,
    pub raw_audio: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, frames: *mut audio_data),
    >,
    pub encoded_packet: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, packet: *mut encoder_packet),
    >,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t,
    >,
    pub unused1: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub get_total_bytes:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> u64>,
    pub get_dropped_frames: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub get_congestion:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> f32>,
    pub get_connect_time_ms: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub encoded_video_codecs: *const ::std::os::raw::c_char,
    pub encoded_audio_codecs: *const ::std::os::raw::c_char,
    pub raw_audio2: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            idx: size_t,
            frames: *mut audio_data,
        ),
    >,
}
#[test]
fn bindgen_test_layout_obs_output_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_output_info>(),
        184usize,
        concat!("Size of: ", stringify!(obs_output_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_output_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_output_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).get_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).create as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).destroy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).start as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).stop as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).raw_video as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(raw_video)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).raw_audio as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(raw_audio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).encoded_packet as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(encoded_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).update as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).get_defaults as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_defaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).get_properties as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).unused1 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).get_total_bytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_total_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_output_info>())).get_dropped_frames as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_dropped_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).type_data as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).free_type_data as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(free_type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).get_congestion as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_congestion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_output_info>())).get_connect_time_ms as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(get_connect_time_ms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_output_info>())).encoded_video_codecs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(encoded_video_codecs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_output_info>())).encoded_audio_codecs as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(encoded_audio_codecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_output_info>())).raw_audio2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_output_info),
            "::",
            stringify!(raw_audio2)
        )
    );
}
impl Default for obs_output_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn obs_register_output_s(info: *const obs_output_info, size: size_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_service_info {
    pub id: *const ::std::os::raw::c_char,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(
            type_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut obs_data_t,
            service: *mut obs_service_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, settings: *mut obs_data_t),
    >,
    pub get_defaults: ::std::option::Option<unsafe extern "C" fn(settings: *mut obs_data_t)>,
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *mut obs_properties_t,
    >,
    #[doc = " Called when getting ready to start up an output, before the encoders"]
    #[doc = " and output are initialized"]
    #[doc = ""]
    #[doc = " @param  data    Internal service data"]
    #[doc = " @param  output  Output context"]
    #[doc = " @return         true to allow the output to start up,"]
    #[doc = "                 false to prevent output from starting up"]
    pub initialize: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, output: *mut obs_output_t) -> bool,
    >,
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub get_key: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub get_username: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub get_password: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub supports_multitrack:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    pub apply_encoder_settings: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            video_encoder_settings: *mut obs_data_t,
            audio_encoder_settings: *mut obs_data_t,
        ),
    >,
    pub type_data: *mut ::std::os::raw::c_void,
    pub free_type_data:
        ::std::option::Option<unsafe extern "C" fn(type_data: *mut ::std::os::raw::c_void)>,
    pub get_output_type: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_obs_service_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_service_info>(),
        152usize,
        concat!("Size of: ", stringify!(obs_service_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_service_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_service_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).get_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).create as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).destroy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).activate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).deactivate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(deactivate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).update as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).get_defaults as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_defaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).get_properties as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).initialize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).get_url as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_url)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).get_key as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).get_username as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).get_password as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_password)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_service_info>())).supports_multitrack as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(supports_multitrack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_service_info>())).apply_encoder_settings as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(apply_encoder_settings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).type_data as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(type_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_service_info>())).free_type_data as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(free_type_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_service_info>())).get_output_type as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_service_info),
            "::",
            stringify!(get_output_type)
        )
    );
}
impl Default for obs_service_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn obs_register_service_s(info: *const obs_service_info, size: size_t);
}
#[doc = " @brief A simple cubic fader for controlling audio levels"]
#[doc = ""]
#[doc = " This is a very common type of software fader since it yields good"]
#[doc = " results while being quite performant."]
#[doc = " The input value is mapped to mul values with the simple formula x^3."]
pub const obs_fader_type_OBS_FADER_CUBIC: obs_fader_type = 0;
#[doc = " @brief A fader compliant to IEC 60-268-18"]
#[doc = ""]
#[doc = " This type of fader has several segments with different slopes that"]
#[doc = " map deflection linearly to dB values. The segments are defined as"]
#[doc = " in the following table:"]
#[doc = ""]
#[doc = "@code"]
#[doc = "Deflection           | Volume"]
#[doc = "------------------------------------------"]
#[doc = "[ 100   %, 75   % ]  | [   0 dB,   -9 dB ]"]
#[doc = "[  75   %, 50   % ]  | [  -9 dB,  -20 dB ]"]
#[doc = "[  50   %, 30   % ]  | [ -20 dB,  -30 dB ]"]
#[doc = "[  30   %, 15   % ]  | [ -30 dB,  -40 dB ]"]
#[doc = "[  15   %,  7.5 % ]  | [ -40 dB,  -50 dB ]"]
#[doc = "[   7.5 %,  2.5 % ]  | [ -50 dB,  -60 dB ]"]
#[doc = "[   2.5 %,  0   % ]  | [ -60 dB, -inf dB ]"]
#[doc = "@endcode"]
pub const obs_fader_type_OBS_FADER_IEC: obs_fader_type = 1;
#[doc = " @brief Logarithmic fader"]
pub const obs_fader_type_OBS_FADER_LOG: obs_fader_type = 2;
#[doc = " @brief Fader types"]
pub type obs_fader_type = u32;
#[doc = " @brief A simple peak meter measuring the maximum of all samples."]
#[doc = ""]
#[doc = " This was a very common type of peak meter used for audio, but"]
#[doc = " is not very accurate with regards to further audio processing."]
pub const obs_peak_meter_type_SAMPLE_PEAK_METER: obs_peak_meter_type = 0;
#[doc = " @brief An accurate peak meter measure the maximum of inter-samples."]
#[doc = ""]
#[doc = " This meter is more computational intensive due to 4x oversampling"]
#[doc = " to determine the true peak to an accuracy of +/- 0.5 dB."]
pub const obs_peak_meter_type_TRUE_PEAK_METER: obs_peak_meter_type = 1;
#[doc = " @brief Peak meter types"]
pub type obs_peak_meter_type = u32;
extern "C" {
    #[doc = " @brief Create a fader"]
    #[doc = " @param type the type of the fader"]
    #[doc = " @return pointer to the fader object"]
    #[doc = ""]
    #[doc = " A fader object is used to map input values from a gui element to dB and"]
    #[doc = " subsequently multiplier values used by libobs to mix audio."]
    #[doc = " The current \"position\" of the fader is internally stored as dB value."]
    pub fn obs_fader_create(type_: obs_fader_type) -> *mut obs_fader_t;
}
extern "C" {
    #[doc = " @brief Destroy a fader"]
    #[doc = " @param fader pointer to the fader object"]
    #[doc = ""]
    #[doc = " Destroy the fader and free all related data"]
    pub fn obs_fader_destroy(fader: *mut obs_fader_t);
}
extern "C" {
    #[doc = " @brief Set the fader dB value"]
    #[doc = " @param fader pointer to the fader object"]
    #[doc = " @param db new dB value"]
    #[doc = " @return true if value was set without clamping"]
    pub fn obs_fader_set_db(fader: *mut obs_fader_t, db: f32) -> bool;
}
extern "C" {
    #[doc = " @brief Get the current fader dB value"]
    #[doc = " @param fader pointer to the fader object"]
    #[doc = " @return current fader dB value"]
    pub fn obs_fader_get_db(fader: *mut obs_fader_t) -> f32;
}
extern "C" {
    #[doc = " @brief Set the fader value from deflection"]
    #[doc = " @param fader pointer to the fader object"]
    #[doc = " @param def new deflection"]
    #[doc = " @return true if value was set without clamping"]
    #[doc = ""]
    #[doc = " This sets the new fader value from the supplied deflection, in case the"]
    #[doc = " resulting value was clamped due to limits this function will return false."]
    #[doc = " The deflection is typically in the range [0.0, 1.0] but may be higher in"]
    #[doc = " order to provide some amplification. In order for this to work the high dB"]
    #[doc = " limit has to be set."]
    pub fn obs_fader_set_deflection(fader: *mut obs_fader_t, def: f32) -> bool;
}
extern "C" {
    #[doc = " @brief Get the current fader deflection"]
    #[doc = " @param fader pointer to the fader object"]
    #[doc = " @return current fader deflection"]
    pub fn obs_fader_get_deflection(fader: *mut obs_fader_t) -> f32;
}
extern "C" {
    #[doc = " @brief Set the fader value from multiplier"]
    #[doc = " @param fader pointer to the fader object"]
    #[doc = " @return true if the value was set without clamping"]
    pub fn obs_fader_set_mul(fader: *mut obs_fader_t, mul: f32) -> bool;
}
extern "C" {
    #[doc = " @brief Get the current fader multiplier value"]
    #[doc = " @param fader pointer to the fader object"]
    #[doc = " @return current fader multiplier"]
    pub fn obs_fader_get_mul(fader: *mut obs_fader_t) -> f32;
}
extern "C" {
    #[doc = " @brief Attach the fader to a source"]
    #[doc = " @param fader pointer to the fader object"]
    #[doc = " @param source pointer to the source object"]
    #[doc = " @return true on success"]
    #[doc = ""]
    #[doc = " When the fader is attached to a source it will automatically sync it's state"]
    #[doc = " to the volume of the source."]
    pub fn obs_fader_attach_source(fader: *mut obs_fader_t, source: *mut obs_source_t) -> bool;
}
extern "C" {
    #[doc = " @brief Detach the fader from the currently attached source"]
    #[doc = " @param fader pointer to the fader object"]
    pub fn obs_fader_detach_source(fader: *mut obs_fader_t);
}
pub type obs_fader_changed_t =
    ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, db: f32)>;
extern "C" {
    pub fn obs_fader_add_callback(
        fader: *mut obs_fader_t,
        callback: obs_fader_changed_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_fader_remove_callback(
        fader: *mut obs_fader_t,
        callback: obs_fader_changed_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Create a volume meter"]
    #[doc = " @param type the mapping type to use for the volume meter"]
    #[doc = " @return pointer to the volume meter object"]
    #[doc = ""]
    #[doc = " A volume meter object is used to prepare the sound levels reported by audio"]
    #[doc = " sources for display in a GUI."]
    #[doc = " It will automatically take source volume into account and map the levels"]
    #[doc = " to a range [0.0f, 1.0f]."]
    pub fn obs_volmeter_create(type_: obs_fader_type) -> *mut obs_volmeter_t;
}
extern "C" {
    #[doc = " @brief Destroy a volume meter"]
    #[doc = " @param volmeter pointer to the volmeter object"]
    #[doc = ""]
    #[doc = " Destroy the volume meter and free all related data"]
    pub fn obs_volmeter_destroy(volmeter: *mut obs_volmeter_t);
}
extern "C" {
    #[doc = " @brief Attach the volume meter to a source"]
    #[doc = " @param volmeter pointer to the volume meter object"]
    #[doc = " @param source pointer to the source object"]
    #[doc = " @return true on success"]
    #[doc = ""]
    #[doc = " When the volume meter is attached to a source it will start to listen to"]
    #[doc = " volume updates on the source and after preparing the data emit its own"]
    #[doc = " signal."]
    pub fn obs_volmeter_attach_source(
        volmeter: *mut obs_volmeter_t,
        source: *mut obs_source_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Detach the volume meter from the currently attached source"]
    #[doc = " @param volmeter pointer to the volume meter object"]
    pub fn obs_volmeter_detach_source(volmeter: *mut obs_volmeter_t);
}
extern "C" {
    #[doc = " @brief Set the peak meter type for the volume meter"]
    #[doc = " @param volmeter pointer to the volume meter object"]
    #[doc = " @param peak_meter_type set if true-peak needs to be measured."]
    pub fn obs_volmeter_set_peak_meter_type(
        volmeter: *mut obs_volmeter_t,
        peak_meter_type: obs_peak_meter_type,
    );
}
extern "C" {
    #[doc = " @brief Set the update interval for the volume meter"]
    #[doc = " @param volmeter pointer to the volume meter object"]
    #[doc = " @param ms update interval in ms"]
    #[doc = ""]
    #[doc = " This sets the update interval in milliseconds that should be processed before"]
    #[doc = " the resulting values are emitted by the levels_updated signal. The resulting"]
    #[doc = " number of audio samples is rounded to an integer."]
    #[doc = ""]
    #[doc = " Please note that due to way obs does receive audio data from the sources"]
    #[doc = " this is no hard guarantee for the timing of the signal itself. When the"]
    #[doc = " volume meter receives a chunk of data that is multiple the size of the sample"]
    #[doc = " interval, all data will be sampled and the values updated accordingly, but"]
    #[doc = " only the signal for the last segment is actually emitted."]
    #[doc = " On the other hand data might be received in a way that will cause the signal"]
    #[doc = " to be emitted in shorter intervals than specified here under some"]
    #[doc = " circumstances."]
    pub fn obs_volmeter_set_update_interval(
        volmeter: *mut obs_volmeter_t,
        ms: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Get the update interval currently used for the volume meter"]
    #[doc = " @param volmeter pointer to the volume meter object"]
    #[doc = " @return update interval in ms"]
    pub fn obs_volmeter_get_update_interval(
        volmeter: *mut obs_volmeter_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Get the number of channels which are configured for this source."]
    #[doc = " @param volmeter pointer to the volume meter object"]
    pub fn obs_volmeter_get_nr_channels(volmeter: *mut obs_volmeter_t) -> ::std::os::raw::c_int;
}
pub type obs_volmeter_updated_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        magnitude: *const f32,
        peak: *const f32,
        input_peak: *const f32,
    ),
>;
extern "C" {
    pub fn obs_volmeter_add_callback(
        volmeter: *mut obs_volmeter_t,
        callback: obs_volmeter_updated_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_volmeter_remove_callback(
        volmeter: *mut obs_volmeter_t,
        callback: obs_volmeter_updated_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_mul_to_db(mul: f32) -> f32;
}
extern "C" {
    pub fn obs_db_to_mul(db: f32) -> f32;
}
pub type obs_hotkey_id = size_t;
pub type obs_hotkey_pair_id = size_t;
pub const obs_key_OBS_KEY_NONE: obs_key = 0;
pub const obs_key_OBS_KEY_RETURN: obs_key = 1;
pub const obs_key_OBS_KEY_ENTER: obs_key = 2;
pub const obs_key_OBS_KEY_ESCAPE: obs_key = 3;
pub const obs_key_OBS_KEY_TAB: obs_key = 4;
pub const obs_key_OBS_KEY_BACKTAB: obs_key = 5;
pub const obs_key_OBS_KEY_BACKSPACE: obs_key = 6;
pub const obs_key_OBS_KEY_INSERT: obs_key = 7;
pub const obs_key_OBS_KEY_DELETE: obs_key = 8;
pub const obs_key_OBS_KEY_PAUSE: obs_key = 9;
pub const obs_key_OBS_KEY_PRINT: obs_key = 10;
pub const obs_key_OBS_KEY_SYSREQ: obs_key = 11;
pub const obs_key_OBS_KEY_CLEAR: obs_key = 12;
pub const obs_key_OBS_KEY_HOME: obs_key = 13;
pub const obs_key_OBS_KEY_END: obs_key = 14;
pub const obs_key_OBS_KEY_LEFT: obs_key = 15;
pub const obs_key_OBS_KEY_UP: obs_key = 16;
pub const obs_key_OBS_KEY_RIGHT: obs_key = 17;
pub const obs_key_OBS_KEY_DOWN: obs_key = 18;
pub const obs_key_OBS_KEY_PAGEUP: obs_key = 19;
pub const obs_key_OBS_KEY_PAGEDOWN: obs_key = 20;
pub const obs_key_OBS_KEY_SHIFT: obs_key = 21;
pub const obs_key_OBS_KEY_CONTROL: obs_key = 22;
pub const obs_key_OBS_KEY_META: obs_key = 23;
pub const obs_key_OBS_KEY_ALT: obs_key = 24;
pub const obs_key_OBS_KEY_ALTGR: obs_key = 25;
pub const obs_key_OBS_KEY_CAPSLOCK: obs_key = 26;
pub const obs_key_OBS_KEY_NUMLOCK: obs_key = 27;
pub const obs_key_OBS_KEY_SCROLLLOCK: obs_key = 28;
pub const obs_key_OBS_KEY_F1: obs_key = 29;
pub const obs_key_OBS_KEY_F2: obs_key = 30;
pub const obs_key_OBS_KEY_F3: obs_key = 31;
pub const obs_key_OBS_KEY_F4: obs_key = 32;
pub const obs_key_OBS_KEY_F5: obs_key = 33;
pub const obs_key_OBS_KEY_F6: obs_key = 34;
pub const obs_key_OBS_KEY_F7: obs_key = 35;
pub const obs_key_OBS_KEY_F8: obs_key = 36;
pub const obs_key_OBS_KEY_F9: obs_key = 37;
pub const obs_key_OBS_KEY_F10: obs_key = 38;
pub const obs_key_OBS_KEY_F11: obs_key = 39;
pub const obs_key_OBS_KEY_F12: obs_key = 40;
pub const obs_key_OBS_KEY_F13: obs_key = 41;
pub const obs_key_OBS_KEY_F14: obs_key = 42;
pub const obs_key_OBS_KEY_F15: obs_key = 43;
pub const obs_key_OBS_KEY_F16: obs_key = 44;
pub const obs_key_OBS_KEY_F17: obs_key = 45;
pub const obs_key_OBS_KEY_F18: obs_key = 46;
pub const obs_key_OBS_KEY_F19: obs_key = 47;
pub const obs_key_OBS_KEY_F20: obs_key = 48;
pub const obs_key_OBS_KEY_F21: obs_key = 49;
pub const obs_key_OBS_KEY_F22: obs_key = 50;
pub const obs_key_OBS_KEY_F23: obs_key = 51;
pub const obs_key_OBS_KEY_F24: obs_key = 52;
pub const obs_key_OBS_KEY_F25: obs_key = 53;
pub const obs_key_OBS_KEY_F26: obs_key = 54;
pub const obs_key_OBS_KEY_F27: obs_key = 55;
pub const obs_key_OBS_KEY_F28: obs_key = 56;
pub const obs_key_OBS_KEY_F29: obs_key = 57;
pub const obs_key_OBS_KEY_F30: obs_key = 58;
pub const obs_key_OBS_KEY_F31: obs_key = 59;
pub const obs_key_OBS_KEY_F32: obs_key = 60;
pub const obs_key_OBS_KEY_F33: obs_key = 61;
pub const obs_key_OBS_KEY_F34: obs_key = 62;
pub const obs_key_OBS_KEY_F35: obs_key = 63;
pub const obs_key_OBS_KEY_MENU: obs_key = 64;
pub const obs_key_OBS_KEY_HYPER_L: obs_key = 65;
pub const obs_key_OBS_KEY_HYPER_R: obs_key = 66;
pub const obs_key_OBS_KEY_HELP: obs_key = 67;
pub const obs_key_OBS_KEY_DIRECTION_L: obs_key = 68;
pub const obs_key_OBS_KEY_DIRECTION_R: obs_key = 69;
pub const obs_key_OBS_KEY_SPACE: obs_key = 70;
pub const obs_key_OBS_KEY_EXCLAM: obs_key = 71;
pub const obs_key_OBS_KEY_QUOTEDBL: obs_key = 72;
pub const obs_key_OBS_KEY_NUMBERSIGN: obs_key = 73;
pub const obs_key_OBS_KEY_DOLLAR: obs_key = 74;
pub const obs_key_OBS_KEY_PERCENT: obs_key = 75;
pub const obs_key_OBS_KEY_AMPERSAND: obs_key = 76;
pub const obs_key_OBS_KEY_APOSTROPHE: obs_key = 77;
pub const obs_key_OBS_KEY_PARENLEFT: obs_key = 78;
pub const obs_key_OBS_KEY_PARENRIGHT: obs_key = 79;
pub const obs_key_OBS_KEY_ASTERISK: obs_key = 80;
pub const obs_key_OBS_KEY_PLUS: obs_key = 81;
pub const obs_key_OBS_KEY_COMMA: obs_key = 82;
pub const obs_key_OBS_KEY_MINUS: obs_key = 83;
pub const obs_key_OBS_KEY_PERIOD: obs_key = 84;
pub const obs_key_OBS_KEY_SLASH: obs_key = 85;
pub const obs_key_OBS_KEY_0: obs_key = 86;
pub const obs_key_OBS_KEY_1: obs_key = 87;
pub const obs_key_OBS_KEY_2: obs_key = 88;
pub const obs_key_OBS_KEY_3: obs_key = 89;
pub const obs_key_OBS_KEY_4: obs_key = 90;
pub const obs_key_OBS_KEY_5: obs_key = 91;
pub const obs_key_OBS_KEY_6: obs_key = 92;
pub const obs_key_OBS_KEY_7: obs_key = 93;
pub const obs_key_OBS_KEY_8: obs_key = 94;
pub const obs_key_OBS_KEY_9: obs_key = 95;
pub const obs_key_OBS_KEY_NUMEQUAL: obs_key = 96;
pub const obs_key_OBS_KEY_NUMASTERISK: obs_key = 97;
pub const obs_key_OBS_KEY_NUMPLUS: obs_key = 98;
pub const obs_key_OBS_KEY_NUMCOMMA: obs_key = 99;
pub const obs_key_OBS_KEY_NUMMINUS: obs_key = 100;
pub const obs_key_OBS_KEY_NUMPERIOD: obs_key = 101;
pub const obs_key_OBS_KEY_NUMSLASH: obs_key = 102;
pub const obs_key_OBS_KEY_NUM0: obs_key = 103;
pub const obs_key_OBS_KEY_NUM1: obs_key = 104;
pub const obs_key_OBS_KEY_NUM2: obs_key = 105;
pub const obs_key_OBS_KEY_NUM3: obs_key = 106;
pub const obs_key_OBS_KEY_NUM4: obs_key = 107;
pub const obs_key_OBS_KEY_NUM5: obs_key = 108;
pub const obs_key_OBS_KEY_NUM6: obs_key = 109;
pub const obs_key_OBS_KEY_NUM7: obs_key = 110;
pub const obs_key_OBS_KEY_NUM8: obs_key = 111;
pub const obs_key_OBS_KEY_NUM9: obs_key = 112;
pub const obs_key_OBS_KEY_COLON: obs_key = 113;
pub const obs_key_OBS_KEY_SEMICOLON: obs_key = 114;
pub const obs_key_OBS_KEY_QUOTE: obs_key = 115;
pub const obs_key_OBS_KEY_LESS: obs_key = 116;
pub const obs_key_OBS_KEY_EQUAL: obs_key = 117;
pub const obs_key_OBS_KEY_GREATER: obs_key = 118;
pub const obs_key_OBS_KEY_QUESTION: obs_key = 119;
pub const obs_key_OBS_KEY_AT: obs_key = 120;
pub const obs_key_OBS_KEY_A: obs_key = 121;
pub const obs_key_OBS_KEY_B: obs_key = 122;
pub const obs_key_OBS_KEY_C: obs_key = 123;
pub const obs_key_OBS_KEY_D: obs_key = 124;
pub const obs_key_OBS_KEY_E: obs_key = 125;
pub const obs_key_OBS_KEY_F: obs_key = 126;
pub const obs_key_OBS_KEY_G: obs_key = 127;
pub const obs_key_OBS_KEY_H: obs_key = 128;
pub const obs_key_OBS_KEY_I: obs_key = 129;
pub const obs_key_OBS_KEY_J: obs_key = 130;
pub const obs_key_OBS_KEY_K: obs_key = 131;
pub const obs_key_OBS_KEY_L: obs_key = 132;
pub const obs_key_OBS_KEY_M: obs_key = 133;
pub const obs_key_OBS_KEY_N: obs_key = 134;
pub const obs_key_OBS_KEY_O: obs_key = 135;
pub const obs_key_OBS_KEY_P: obs_key = 136;
pub const obs_key_OBS_KEY_Q: obs_key = 137;
pub const obs_key_OBS_KEY_R: obs_key = 138;
pub const obs_key_OBS_KEY_S: obs_key = 139;
pub const obs_key_OBS_KEY_T: obs_key = 140;
pub const obs_key_OBS_KEY_U: obs_key = 141;
pub const obs_key_OBS_KEY_V: obs_key = 142;
pub const obs_key_OBS_KEY_W: obs_key = 143;
pub const obs_key_OBS_KEY_X: obs_key = 144;
pub const obs_key_OBS_KEY_Y: obs_key = 145;
pub const obs_key_OBS_KEY_Z: obs_key = 146;
pub const obs_key_OBS_KEY_BRACKETLEFT: obs_key = 147;
pub const obs_key_OBS_KEY_BACKSLASH: obs_key = 148;
pub const obs_key_OBS_KEY_BRACKETRIGHT: obs_key = 149;
pub const obs_key_OBS_KEY_ASCIICIRCUM: obs_key = 150;
pub const obs_key_OBS_KEY_UNDERSCORE: obs_key = 151;
pub const obs_key_OBS_KEY_QUOTELEFT: obs_key = 152;
pub const obs_key_OBS_KEY_BRACELEFT: obs_key = 153;
pub const obs_key_OBS_KEY_BAR: obs_key = 154;
pub const obs_key_OBS_KEY_BRACERIGHT: obs_key = 155;
pub const obs_key_OBS_KEY_ASCIITILDE: obs_key = 156;
pub const obs_key_OBS_KEY_NOBREAKSPACE: obs_key = 157;
pub const obs_key_OBS_KEY_EXCLAMDOWN: obs_key = 158;
pub const obs_key_OBS_KEY_CENT: obs_key = 159;
pub const obs_key_OBS_KEY_STERLING: obs_key = 160;
pub const obs_key_OBS_KEY_CURRENCY: obs_key = 161;
pub const obs_key_OBS_KEY_YEN: obs_key = 162;
pub const obs_key_OBS_KEY_BROKENBAR: obs_key = 163;
pub const obs_key_OBS_KEY_SECTION: obs_key = 164;
pub const obs_key_OBS_KEY_DIAERESIS: obs_key = 165;
pub const obs_key_OBS_KEY_COPYRIGHT: obs_key = 166;
pub const obs_key_OBS_KEY_ORDFEMININE: obs_key = 167;
pub const obs_key_OBS_KEY_GUILLEMOTLEFT: obs_key = 168;
pub const obs_key_OBS_KEY_NOTSIGN: obs_key = 169;
pub const obs_key_OBS_KEY_HYPHEN: obs_key = 170;
pub const obs_key_OBS_KEY_REGISTERED: obs_key = 171;
pub const obs_key_OBS_KEY_MACRON: obs_key = 172;
pub const obs_key_OBS_KEY_DEGREE: obs_key = 173;
pub const obs_key_OBS_KEY_PLUSMINUS: obs_key = 174;
pub const obs_key_OBS_KEY_TWOSUPERIOR: obs_key = 175;
pub const obs_key_OBS_KEY_THREESUPERIOR: obs_key = 176;
pub const obs_key_OBS_KEY_ACUTE: obs_key = 177;
pub const obs_key_OBS_KEY_MU: obs_key = 178;
pub const obs_key_OBS_KEY_PARAGRAPH: obs_key = 179;
pub const obs_key_OBS_KEY_PERIODCENTERED: obs_key = 180;
pub const obs_key_OBS_KEY_CEDILLA: obs_key = 181;
pub const obs_key_OBS_KEY_ONESUPERIOR: obs_key = 182;
pub const obs_key_OBS_KEY_MASCULINE: obs_key = 183;
pub const obs_key_OBS_KEY_GUILLEMOTRIGHT: obs_key = 184;
pub const obs_key_OBS_KEY_ONEQUARTER: obs_key = 185;
pub const obs_key_OBS_KEY_ONEHALF: obs_key = 186;
pub const obs_key_OBS_KEY_THREEQUARTERS: obs_key = 187;
pub const obs_key_OBS_KEY_QUESTIONDOWN: obs_key = 188;
pub const obs_key_OBS_KEY_AGRAVE: obs_key = 189;
pub const obs_key_OBS_KEY_AACUTE: obs_key = 190;
pub const obs_key_OBS_KEY_ACIRCUMFLEX: obs_key = 191;
pub const obs_key_OBS_KEY_ATILDE: obs_key = 192;
pub const obs_key_OBS_KEY_ADIAERESIS: obs_key = 193;
pub const obs_key_OBS_KEY_ARING: obs_key = 194;
pub const obs_key_OBS_KEY_AE: obs_key = 195;
pub const obs_key_OBS_KEY_CCEDILLA: obs_key = 196;
pub const obs_key_OBS_KEY_EGRAVE: obs_key = 197;
pub const obs_key_OBS_KEY_EACUTE: obs_key = 198;
pub const obs_key_OBS_KEY_ECIRCUMFLEX: obs_key = 199;
pub const obs_key_OBS_KEY_EDIAERESIS: obs_key = 200;
pub const obs_key_OBS_KEY_IGRAVE: obs_key = 201;
pub const obs_key_OBS_KEY_IACUTE: obs_key = 202;
pub const obs_key_OBS_KEY_ICIRCUMFLEX: obs_key = 203;
pub const obs_key_OBS_KEY_IDIAERESIS: obs_key = 204;
pub const obs_key_OBS_KEY_ETH: obs_key = 205;
pub const obs_key_OBS_KEY_NTILDE: obs_key = 206;
pub const obs_key_OBS_KEY_OGRAVE: obs_key = 207;
pub const obs_key_OBS_KEY_OACUTE: obs_key = 208;
pub const obs_key_OBS_KEY_OCIRCUMFLEX: obs_key = 209;
pub const obs_key_OBS_KEY_OTILDE: obs_key = 210;
pub const obs_key_OBS_KEY_ODIAERESIS: obs_key = 211;
pub const obs_key_OBS_KEY_MULTIPLY: obs_key = 212;
pub const obs_key_OBS_KEY_OOBLIQUE: obs_key = 213;
pub const obs_key_OBS_KEY_UGRAVE: obs_key = 214;
pub const obs_key_OBS_KEY_UACUTE: obs_key = 215;
pub const obs_key_OBS_KEY_UCIRCUMFLEX: obs_key = 216;
pub const obs_key_OBS_KEY_UDIAERESIS: obs_key = 217;
pub const obs_key_OBS_KEY_YACUTE: obs_key = 218;
pub const obs_key_OBS_KEY_THORN: obs_key = 219;
pub const obs_key_OBS_KEY_SSHARP: obs_key = 220;
pub const obs_key_OBS_KEY_DIVISION: obs_key = 221;
pub const obs_key_OBS_KEY_YDIAERESIS: obs_key = 222;
pub const obs_key_OBS_KEY_MULTI_KEY: obs_key = 223;
pub const obs_key_OBS_KEY_CODEINPUT: obs_key = 224;
pub const obs_key_OBS_KEY_SINGLECANDIDATE: obs_key = 225;
pub const obs_key_OBS_KEY_MULTIPLECANDIDATE: obs_key = 226;
pub const obs_key_OBS_KEY_PREVIOUSCANDIDATE: obs_key = 227;
pub const obs_key_OBS_KEY_MODE_SWITCH: obs_key = 228;
pub const obs_key_OBS_KEY_KANJI: obs_key = 229;
pub const obs_key_OBS_KEY_MUHENKAN: obs_key = 230;
pub const obs_key_OBS_KEY_HENKAN: obs_key = 231;
pub const obs_key_OBS_KEY_ROMAJI: obs_key = 232;
pub const obs_key_OBS_KEY_HIRAGANA: obs_key = 233;
pub const obs_key_OBS_KEY_KATAKANA: obs_key = 234;
pub const obs_key_OBS_KEY_HIRAGANA_KATAKANA: obs_key = 235;
pub const obs_key_OBS_KEY_ZENKAKU: obs_key = 236;
pub const obs_key_OBS_KEY_HANKAKU: obs_key = 237;
pub const obs_key_OBS_KEY_ZENKAKU_HANKAKU: obs_key = 238;
pub const obs_key_OBS_KEY_TOUROKU: obs_key = 239;
pub const obs_key_OBS_KEY_MASSYO: obs_key = 240;
pub const obs_key_OBS_KEY_KANA_LOCK: obs_key = 241;
pub const obs_key_OBS_KEY_KANA_SHIFT: obs_key = 242;
pub const obs_key_OBS_KEY_EISU_SHIFT: obs_key = 243;
pub const obs_key_OBS_KEY_EISU_TOGGLE: obs_key = 244;
pub const obs_key_OBS_KEY_HANGUL: obs_key = 245;
pub const obs_key_OBS_KEY_HANGUL_START: obs_key = 246;
pub const obs_key_OBS_KEY_HANGUL_END: obs_key = 247;
pub const obs_key_OBS_KEY_HANGUL_HANJA: obs_key = 248;
pub const obs_key_OBS_KEY_HANGUL_JAMO: obs_key = 249;
pub const obs_key_OBS_KEY_HANGUL_ROMAJA: obs_key = 250;
pub const obs_key_OBS_KEY_HANGUL_JEONJA: obs_key = 251;
pub const obs_key_OBS_KEY_HANGUL_BANJA: obs_key = 252;
pub const obs_key_OBS_KEY_HANGUL_PREHANJA: obs_key = 253;
pub const obs_key_OBS_KEY_HANGUL_POSTHANJA: obs_key = 254;
pub const obs_key_OBS_KEY_HANGUL_SPECIAL: obs_key = 255;
pub const obs_key_OBS_KEY_DEAD_GRAVE: obs_key = 256;
pub const obs_key_OBS_KEY_DEAD_ACUTE: obs_key = 257;
pub const obs_key_OBS_KEY_DEAD_CIRCUMFLEX: obs_key = 258;
pub const obs_key_OBS_KEY_DEAD_TILDE: obs_key = 259;
pub const obs_key_OBS_KEY_DEAD_MACRON: obs_key = 260;
pub const obs_key_OBS_KEY_DEAD_BREVE: obs_key = 261;
pub const obs_key_OBS_KEY_DEAD_ABOVEDOT: obs_key = 262;
pub const obs_key_OBS_KEY_DEAD_DIAERESIS: obs_key = 263;
pub const obs_key_OBS_KEY_DEAD_ABOVERING: obs_key = 264;
pub const obs_key_OBS_KEY_DEAD_DOUBLEACUTE: obs_key = 265;
pub const obs_key_OBS_KEY_DEAD_CARON: obs_key = 266;
pub const obs_key_OBS_KEY_DEAD_CEDILLA: obs_key = 267;
pub const obs_key_OBS_KEY_DEAD_OGONEK: obs_key = 268;
pub const obs_key_OBS_KEY_DEAD_IOTA: obs_key = 269;
pub const obs_key_OBS_KEY_DEAD_VOICED_SOUND: obs_key = 270;
pub const obs_key_OBS_KEY_DEAD_SEMIVOICED_SOUND: obs_key = 271;
pub const obs_key_OBS_KEY_DEAD_BELOWDOT: obs_key = 272;
pub const obs_key_OBS_KEY_DEAD_HOOK: obs_key = 273;
pub const obs_key_OBS_KEY_DEAD_HORN: obs_key = 274;
pub const obs_key_OBS_KEY_BACK: obs_key = 275;
pub const obs_key_OBS_KEY_FORWARD: obs_key = 276;
pub const obs_key_OBS_KEY_STOP: obs_key = 277;
pub const obs_key_OBS_KEY_REFRESH: obs_key = 278;
pub const obs_key_OBS_KEY_VOLUMEDOWN: obs_key = 279;
pub const obs_key_OBS_KEY_VOLUMEMUTE: obs_key = 280;
pub const obs_key_OBS_KEY_VOLUMEUP: obs_key = 281;
pub const obs_key_OBS_KEY_BASSBOOST: obs_key = 282;
pub const obs_key_OBS_KEY_BASSUP: obs_key = 283;
pub const obs_key_OBS_KEY_BASSDOWN: obs_key = 284;
pub const obs_key_OBS_KEY_TREBLEUP: obs_key = 285;
pub const obs_key_OBS_KEY_TREBLEDOWN: obs_key = 286;
pub const obs_key_OBS_KEY_MEDIAPLAY: obs_key = 287;
pub const obs_key_OBS_KEY_MEDIASTOP: obs_key = 288;
pub const obs_key_OBS_KEY_MEDIAPREVIOUS: obs_key = 289;
pub const obs_key_OBS_KEY_MEDIANEXT: obs_key = 290;
pub const obs_key_OBS_KEY_MEDIARECORD: obs_key = 291;
pub const obs_key_OBS_KEY_MEDIAPAUSE: obs_key = 292;
pub const obs_key_OBS_KEY_MEDIATOGGLEPLAYPAUSE: obs_key = 293;
pub const obs_key_OBS_KEY_HOMEPAGE: obs_key = 294;
pub const obs_key_OBS_KEY_FAVORITES: obs_key = 295;
pub const obs_key_OBS_KEY_SEARCH: obs_key = 296;
pub const obs_key_OBS_KEY_STANDBY: obs_key = 297;
pub const obs_key_OBS_KEY_OPENURL: obs_key = 298;
pub const obs_key_OBS_KEY_LAUNCHMAIL: obs_key = 299;
pub const obs_key_OBS_KEY_LAUNCHMEDIA: obs_key = 300;
pub const obs_key_OBS_KEY_LAUNCH0: obs_key = 301;
pub const obs_key_OBS_KEY_LAUNCH1: obs_key = 302;
pub const obs_key_OBS_KEY_LAUNCH2: obs_key = 303;
pub const obs_key_OBS_KEY_LAUNCH3: obs_key = 304;
pub const obs_key_OBS_KEY_LAUNCH4: obs_key = 305;
pub const obs_key_OBS_KEY_LAUNCH5: obs_key = 306;
pub const obs_key_OBS_KEY_LAUNCH6: obs_key = 307;
pub const obs_key_OBS_KEY_LAUNCH7: obs_key = 308;
pub const obs_key_OBS_KEY_LAUNCH8: obs_key = 309;
pub const obs_key_OBS_KEY_LAUNCH9: obs_key = 310;
pub const obs_key_OBS_KEY_LAUNCHA: obs_key = 311;
pub const obs_key_OBS_KEY_LAUNCHB: obs_key = 312;
pub const obs_key_OBS_KEY_LAUNCHC: obs_key = 313;
pub const obs_key_OBS_KEY_LAUNCHD: obs_key = 314;
pub const obs_key_OBS_KEY_LAUNCHE: obs_key = 315;
pub const obs_key_OBS_KEY_LAUNCHF: obs_key = 316;
pub const obs_key_OBS_KEY_LAUNCHG: obs_key = 317;
pub const obs_key_OBS_KEY_LAUNCHH: obs_key = 318;
pub const obs_key_OBS_KEY_MONBRIGHTNESSUP: obs_key = 319;
pub const obs_key_OBS_KEY_MONBRIGHTNESSDOWN: obs_key = 320;
pub const obs_key_OBS_KEY_KEYBOARDLIGHTONOFF: obs_key = 321;
pub const obs_key_OBS_KEY_KEYBOARDBRIGHTNESSUP: obs_key = 322;
pub const obs_key_OBS_KEY_KEYBOARDBRIGHTNESSDOWN: obs_key = 323;
pub const obs_key_OBS_KEY_POWEROFF: obs_key = 324;
pub const obs_key_OBS_KEY_WAKEUP: obs_key = 325;
pub const obs_key_OBS_KEY_EJECT: obs_key = 326;
pub const obs_key_OBS_KEY_SCREENSAVER: obs_key = 327;
pub const obs_key_OBS_KEY_WWW: obs_key = 328;
pub const obs_key_OBS_KEY_MEMO: obs_key = 329;
pub const obs_key_OBS_KEY_LIGHTBULB: obs_key = 330;
pub const obs_key_OBS_KEY_SHOP: obs_key = 331;
pub const obs_key_OBS_KEY_HISTORY: obs_key = 332;
pub const obs_key_OBS_KEY_ADDFAVORITE: obs_key = 333;
pub const obs_key_OBS_KEY_HOTLINKS: obs_key = 334;
pub const obs_key_OBS_KEY_BRIGHTNESSADJUST: obs_key = 335;
pub const obs_key_OBS_KEY_FINANCE: obs_key = 336;
pub const obs_key_OBS_KEY_COMMUNITY: obs_key = 337;
pub const obs_key_OBS_KEY_AUDIOREWIND: obs_key = 338;
pub const obs_key_OBS_KEY_BACKFORWARD: obs_key = 339;
pub const obs_key_OBS_KEY_APPLICATIONLEFT: obs_key = 340;
pub const obs_key_OBS_KEY_APPLICATIONRIGHT: obs_key = 341;
pub const obs_key_OBS_KEY_BOOK: obs_key = 342;
pub const obs_key_OBS_KEY_CD: obs_key = 343;
pub const obs_key_OBS_KEY_CALCULATOR: obs_key = 344;
pub const obs_key_OBS_KEY_TODOLIST: obs_key = 345;
pub const obs_key_OBS_KEY_CLEARGRAB: obs_key = 346;
pub const obs_key_OBS_KEY_CLOSE: obs_key = 347;
pub const obs_key_OBS_KEY_COPY: obs_key = 348;
pub const obs_key_OBS_KEY_CUT: obs_key = 349;
pub const obs_key_OBS_KEY_DISPLAY: obs_key = 350;
pub const obs_key_OBS_KEY_DOS: obs_key = 351;
pub const obs_key_OBS_KEY_DOCUMENTS: obs_key = 352;
pub const obs_key_OBS_KEY_EXCEL: obs_key = 353;
pub const obs_key_OBS_KEY_EXPLORER: obs_key = 354;
pub const obs_key_OBS_KEY_GAME: obs_key = 355;
pub const obs_key_OBS_KEY_GO: obs_key = 356;
pub const obs_key_OBS_KEY_ITOUCH: obs_key = 357;
pub const obs_key_OBS_KEY_LOGOFF: obs_key = 358;
pub const obs_key_OBS_KEY_MARKET: obs_key = 359;
pub const obs_key_OBS_KEY_MEETING: obs_key = 360;
pub const obs_key_OBS_KEY_MENUKB: obs_key = 361;
pub const obs_key_OBS_KEY_MENUPB: obs_key = 362;
pub const obs_key_OBS_KEY_MYSITES: obs_key = 363;
pub const obs_key_OBS_KEY_NEWS: obs_key = 364;
pub const obs_key_OBS_KEY_OFFICEHOME: obs_key = 365;
pub const obs_key_OBS_KEY_OPTION: obs_key = 366;
pub const obs_key_OBS_KEY_PASTE: obs_key = 367;
pub const obs_key_OBS_KEY_PHONE: obs_key = 368;
pub const obs_key_OBS_KEY_CALENDAR: obs_key = 369;
pub const obs_key_OBS_KEY_REPLY: obs_key = 370;
pub const obs_key_OBS_KEY_RELOAD: obs_key = 371;
pub const obs_key_OBS_KEY_ROTATEWINDOWS: obs_key = 372;
pub const obs_key_OBS_KEY_ROTATIONPB: obs_key = 373;
pub const obs_key_OBS_KEY_ROTATIONKB: obs_key = 374;
pub const obs_key_OBS_KEY_SAVE: obs_key = 375;
pub const obs_key_OBS_KEY_SEND: obs_key = 376;
pub const obs_key_OBS_KEY_SPELL: obs_key = 377;
pub const obs_key_OBS_KEY_SPLITSCREEN: obs_key = 378;
pub const obs_key_OBS_KEY_SUPPORT: obs_key = 379;
pub const obs_key_OBS_KEY_TASKPANE: obs_key = 380;
pub const obs_key_OBS_KEY_TERMINAL: obs_key = 381;
pub const obs_key_OBS_KEY_TOOLS: obs_key = 382;
pub const obs_key_OBS_KEY_TRAVEL: obs_key = 383;
pub const obs_key_OBS_KEY_VIDEO: obs_key = 384;
pub const obs_key_OBS_KEY_WORD: obs_key = 385;
pub const obs_key_OBS_KEY_XFER: obs_key = 386;
pub const obs_key_OBS_KEY_ZOOMIN: obs_key = 387;
pub const obs_key_OBS_KEY_ZOOMOUT: obs_key = 388;
pub const obs_key_OBS_KEY_AWAY: obs_key = 389;
pub const obs_key_OBS_KEY_MESSENGER: obs_key = 390;
pub const obs_key_OBS_KEY_WEBCAM: obs_key = 391;
pub const obs_key_OBS_KEY_MAILFORWARD: obs_key = 392;
pub const obs_key_OBS_KEY_PICTURES: obs_key = 393;
pub const obs_key_OBS_KEY_MUSIC: obs_key = 394;
pub const obs_key_OBS_KEY_BATTERY: obs_key = 395;
pub const obs_key_OBS_KEY_BLUETOOTH: obs_key = 396;
pub const obs_key_OBS_KEY_WLAN: obs_key = 397;
pub const obs_key_OBS_KEY_UWB: obs_key = 398;
pub const obs_key_OBS_KEY_AUDIOFORWARD: obs_key = 399;
pub const obs_key_OBS_KEY_AUDIOREPEAT: obs_key = 400;
pub const obs_key_OBS_KEY_AUDIORANDOMPLAY: obs_key = 401;
pub const obs_key_OBS_KEY_SUBTITLE: obs_key = 402;
pub const obs_key_OBS_KEY_AUDIOCYCLETRACK: obs_key = 403;
pub const obs_key_OBS_KEY_TIME: obs_key = 404;
pub const obs_key_OBS_KEY_HIBERNATE: obs_key = 405;
pub const obs_key_OBS_KEY_VIEW: obs_key = 406;
pub const obs_key_OBS_KEY_TOPMENU: obs_key = 407;
pub const obs_key_OBS_KEY_POWERDOWN: obs_key = 408;
pub const obs_key_OBS_KEY_SUSPEND: obs_key = 409;
pub const obs_key_OBS_KEY_CONTRASTADJUST: obs_key = 410;
pub const obs_key_OBS_KEY_MEDIALAST: obs_key = 411;
pub const obs_key_OBS_KEY_CALL: obs_key = 412;
pub const obs_key_OBS_KEY_CAMERA: obs_key = 413;
pub const obs_key_OBS_KEY_CAMERAFOCUS: obs_key = 414;
pub const obs_key_OBS_KEY_CONTEXT1: obs_key = 415;
pub const obs_key_OBS_KEY_CONTEXT2: obs_key = 416;
pub const obs_key_OBS_KEY_CONTEXT3: obs_key = 417;
pub const obs_key_OBS_KEY_CONTEXT4: obs_key = 418;
pub const obs_key_OBS_KEY_FLIP: obs_key = 419;
pub const obs_key_OBS_KEY_HANGUP: obs_key = 420;
pub const obs_key_OBS_KEY_NO: obs_key = 421;
pub const obs_key_OBS_KEY_SELECT: obs_key = 422;
pub const obs_key_OBS_KEY_YES: obs_key = 423;
pub const obs_key_OBS_KEY_TOGGLECALLHANGUP: obs_key = 424;
pub const obs_key_OBS_KEY_VOICEDIAL: obs_key = 425;
pub const obs_key_OBS_KEY_LASTNUMBERREDIAL: obs_key = 426;
pub const obs_key_OBS_KEY_EXECUTE: obs_key = 427;
pub const obs_key_OBS_KEY_PRINTER: obs_key = 428;
pub const obs_key_OBS_KEY_PLAY: obs_key = 429;
pub const obs_key_OBS_KEY_SLEEP: obs_key = 430;
pub const obs_key_OBS_KEY_ZOOM: obs_key = 431;
pub const obs_key_OBS_KEY_CANCEL: obs_key = 432;
pub const obs_key_OBS_KEY_MOUSE1: obs_key = 433;
pub const obs_key_OBS_KEY_MOUSE2: obs_key = 434;
pub const obs_key_OBS_KEY_MOUSE3: obs_key = 435;
pub const obs_key_OBS_KEY_MOUSE4: obs_key = 436;
pub const obs_key_OBS_KEY_MOUSE5: obs_key = 437;
pub const obs_key_OBS_KEY_MOUSE6: obs_key = 438;
pub const obs_key_OBS_KEY_MOUSE7: obs_key = 439;
pub const obs_key_OBS_KEY_MOUSE8: obs_key = 440;
pub const obs_key_OBS_KEY_MOUSE9: obs_key = 441;
pub const obs_key_OBS_KEY_MOUSE10: obs_key = 442;
pub const obs_key_OBS_KEY_MOUSE11: obs_key = 443;
pub const obs_key_OBS_KEY_MOUSE12: obs_key = 444;
pub const obs_key_OBS_KEY_MOUSE13: obs_key = 445;
pub const obs_key_OBS_KEY_MOUSE14: obs_key = 446;
pub const obs_key_OBS_KEY_MOUSE15: obs_key = 447;
pub const obs_key_OBS_KEY_MOUSE16: obs_key = 448;
pub const obs_key_OBS_KEY_MOUSE17: obs_key = 449;
pub const obs_key_OBS_KEY_MOUSE18: obs_key = 450;
pub const obs_key_OBS_KEY_MOUSE19: obs_key = 451;
pub const obs_key_OBS_KEY_MOUSE20: obs_key = 452;
pub const obs_key_OBS_KEY_MOUSE21: obs_key = 453;
pub const obs_key_OBS_KEY_MOUSE22: obs_key = 454;
pub const obs_key_OBS_KEY_MOUSE23: obs_key = 455;
pub const obs_key_OBS_KEY_MOUSE24: obs_key = 456;
pub const obs_key_OBS_KEY_MOUSE25: obs_key = 457;
pub const obs_key_OBS_KEY_MOUSE26: obs_key = 458;
pub const obs_key_OBS_KEY_MOUSE27: obs_key = 459;
pub const obs_key_OBS_KEY_MOUSE28: obs_key = 460;
pub const obs_key_OBS_KEY_MOUSE29: obs_key = 461;
pub const obs_key_OBS_KEY_BACKSLASH_RT102: obs_key = 462;
pub const obs_key_OBS_KEY_OPEN: obs_key = 463;
pub const obs_key_OBS_KEY_FIND: obs_key = 464;
pub const obs_key_OBS_KEY_REDO: obs_key = 465;
pub const obs_key_OBS_KEY_UNDO: obs_key = 466;
pub const obs_key_OBS_KEY_FRONT: obs_key = 467;
pub const obs_key_OBS_KEY_PROPS: obs_key = 468;
pub const obs_key_OBS_KEY_VK_CANCEL: obs_key = 469;
pub const obs_key_OBS_KEY_0x07: obs_key = 470;
pub const obs_key_OBS_KEY_0x0A: obs_key = 471;
pub const obs_key_OBS_KEY_0x0B: obs_key = 472;
pub const obs_key_OBS_KEY_0x0E: obs_key = 473;
pub const obs_key_OBS_KEY_0x0F: obs_key = 474;
pub const obs_key_OBS_KEY_0x16: obs_key = 475;
pub const obs_key_OBS_KEY_VK_JUNJA: obs_key = 476;
pub const obs_key_OBS_KEY_VK_FINAL: obs_key = 477;
pub const obs_key_OBS_KEY_0x1A: obs_key = 478;
pub const obs_key_OBS_KEY_VK_ACCEPT: obs_key = 479;
pub const obs_key_OBS_KEY_VK_MODECHANGE: obs_key = 480;
pub const obs_key_OBS_KEY_VK_SELECT: obs_key = 481;
pub const obs_key_OBS_KEY_VK_PRINT: obs_key = 482;
pub const obs_key_OBS_KEY_VK_EXECUTE: obs_key = 483;
pub const obs_key_OBS_KEY_VK_HELP: obs_key = 484;
pub const obs_key_OBS_KEY_0x30: obs_key = 485;
pub const obs_key_OBS_KEY_0x31: obs_key = 486;
pub const obs_key_OBS_KEY_0x32: obs_key = 487;
pub const obs_key_OBS_KEY_0x33: obs_key = 488;
pub const obs_key_OBS_KEY_0x34: obs_key = 489;
pub const obs_key_OBS_KEY_0x35: obs_key = 490;
pub const obs_key_OBS_KEY_0x36: obs_key = 491;
pub const obs_key_OBS_KEY_0x37: obs_key = 492;
pub const obs_key_OBS_KEY_0x38: obs_key = 493;
pub const obs_key_OBS_KEY_0x39: obs_key = 494;
pub const obs_key_OBS_KEY_0x3A: obs_key = 495;
pub const obs_key_OBS_KEY_0x3B: obs_key = 496;
pub const obs_key_OBS_KEY_0x3C: obs_key = 497;
pub const obs_key_OBS_KEY_0x3D: obs_key = 498;
pub const obs_key_OBS_KEY_0x3E: obs_key = 499;
pub const obs_key_OBS_KEY_0x3F: obs_key = 500;
pub const obs_key_OBS_KEY_0x40: obs_key = 501;
pub const obs_key_OBS_KEY_0x41: obs_key = 502;
pub const obs_key_OBS_KEY_0x42: obs_key = 503;
pub const obs_key_OBS_KEY_0x43: obs_key = 504;
pub const obs_key_OBS_KEY_0x44: obs_key = 505;
pub const obs_key_OBS_KEY_0x45: obs_key = 506;
pub const obs_key_OBS_KEY_0x46: obs_key = 507;
pub const obs_key_OBS_KEY_0x47: obs_key = 508;
pub const obs_key_OBS_KEY_0x48: obs_key = 509;
pub const obs_key_OBS_KEY_0x49: obs_key = 510;
pub const obs_key_OBS_KEY_0x4A: obs_key = 511;
pub const obs_key_OBS_KEY_0x4B: obs_key = 512;
pub const obs_key_OBS_KEY_0x4C: obs_key = 513;
pub const obs_key_OBS_KEY_0x4D: obs_key = 514;
pub const obs_key_OBS_KEY_0x4E: obs_key = 515;
pub const obs_key_OBS_KEY_0x4F: obs_key = 516;
pub const obs_key_OBS_KEY_0x50: obs_key = 517;
pub const obs_key_OBS_KEY_0x51: obs_key = 518;
pub const obs_key_OBS_KEY_0x52: obs_key = 519;
pub const obs_key_OBS_KEY_0x53: obs_key = 520;
pub const obs_key_OBS_KEY_0x54: obs_key = 521;
pub const obs_key_OBS_KEY_0x55: obs_key = 522;
pub const obs_key_OBS_KEY_0x56: obs_key = 523;
pub const obs_key_OBS_KEY_0x57: obs_key = 524;
pub const obs_key_OBS_KEY_0x58: obs_key = 525;
pub const obs_key_OBS_KEY_0x59: obs_key = 526;
pub const obs_key_OBS_KEY_0x5A: obs_key = 527;
pub const obs_key_OBS_KEY_VK_LWIN: obs_key = 528;
pub const obs_key_OBS_KEY_VK_RWIN: obs_key = 529;
pub const obs_key_OBS_KEY_VK_APPS: obs_key = 530;
pub const obs_key_OBS_KEY_0x5E: obs_key = 531;
pub const obs_key_OBS_KEY_VK_SLEEP: obs_key = 532;
pub const obs_key_OBS_KEY_VK_SEPARATOR: obs_key = 533;
pub const obs_key_OBS_KEY_0x88: obs_key = 534;
pub const obs_key_OBS_KEY_0x89: obs_key = 535;
pub const obs_key_OBS_KEY_0x8A: obs_key = 536;
pub const obs_key_OBS_KEY_0x8B: obs_key = 537;
pub const obs_key_OBS_KEY_0x8C: obs_key = 538;
pub const obs_key_OBS_KEY_0x8D: obs_key = 539;
pub const obs_key_OBS_KEY_0x8E: obs_key = 540;
pub const obs_key_OBS_KEY_0x8F: obs_key = 541;
pub const obs_key_OBS_KEY_VK_OEM_FJ_JISHO: obs_key = 542;
pub const obs_key_OBS_KEY_VK_OEM_FJ_LOYA: obs_key = 543;
pub const obs_key_OBS_KEY_VK_OEM_FJ_ROYA: obs_key = 544;
pub const obs_key_OBS_KEY_0x97: obs_key = 545;
pub const obs_key_OBS_KEY_0x98: obs_key = 546;
pub const obs_key_OBS_KEY_0x99: obs_key = 547;
pub const obs_key_OBS_KEY_0x9A: obs_key = 548;
pub const obs_key_OBS_KEY_0x9B: obs_key = 549;
pub const obs_key_OBS_KEY_0x9C: obs_key = 550;
pub const obs_key_OBS_KEY_0x9D: obs_key = 551;
pub const obs_key_OBS_KEY_0x9E: obs_key = 552;
pub const obs_key_OBS_KEY_0x9F: obs_key = 553;
pub const obs_key_OBS_KEY_VK_LSHIFT: obs_key = 554;
pub const obs_key_OBS_KEY_VK_RSHIFT: obs_key = 555;
pub const obs_key_OBS_KEY_VK_LCONTROL: obs_key = 556;
pub const obs_key_OBS_KEY_VK_RCONTROL: obs_key = 557;
pub const obs_key_OBS_KEY_VK_LMENU: obs_key = 558;
pub const obs_key_OBS_KEY_VK_RMENU: obs_key = 559;
pub const obs_key_OBS_KEY_VK_BROWSER_BACK: obs_key = 560;
pub const obs_key_OBS_KEY_VK_BROWSER_FORWARD: obs_key = 561;
pub const obs_key_OBS_KEY_VK_BROWSER_REFRESH: obs_key = 562;
pub const obs_key_OBS_KEY_VK_BROWSER_STOP: obs_key = 563;
pub const obs_key_OBS_KEY_VK_BROWSER_SEARCH: obs_key = 564;
pub const obs_key_OBS_KEY_VK_BROWSER_FAVORITES: obs_key = 565;
pub const obs_key_OBS_KEY_VK_BROWSER_HOME: obs_key = 566;
pub const obs_key_OBS_KEY_VK_VOLUME_MUTE: obs_key = 567;
pub const obs_key_OBS_KEY_VK_VOLUME_DOWN: obs_key = 568;
pub const obs_key_OBS_KEY_VK_VOLUME_UP: obs_key = 569;
pub const obs_key_OBS_KEY_VK_MEDIA_NEXT_TRACK: obs_key = 570;
pub const obs_key_OBS_KEY_VK_MEDIA_PREV_TRACK: obs_key = 571;
pub const obs_key_OBS_KEY_VK_MEDIA_STOP: obs_key = 572;
pub const obs_key_OBS_KEY_VK_MEDIA_PLAY_PAUSE: obs_key = 573;
pub const obs_key_OBS_KEY_VK_LAUNCH_MAIL: obs_key = 574;
pub const obs_key_OBS_KEY_VK_LAUNCH_MEDIA_SELECT: obs_key = 575;
pub const obs_key_OBS_KEY_VK_LAUNCH_APP1: obs_key = 576;
pub const obs_key_OBS_KEY_VK_LAUNCH_APP2: obs_key = 577;
pub const obs_key_OBS_KEY_0xB8: obs_key = 578;
pub const obs_key_OBS_KEY_0xB9: obs_key = 579;
pub const obs_key_OBS_KEY_0xC1: obs_key = 580;
pub const obs_key_OBS_KEY_0xC2: obs_key = 581;
pub const obs_key_OBS_KEY_0xC3: obs_key = 582;
pub const obs_key_OBS_KEY_0xC4: obs_key = 583;
pub const obs_key_OBS_KEY_0xC5: obs_key = 584;
pub const obs_key_OBS_KEY_0xC6: obs_key = 585;
pub const obs_key_OBS_KEY_0xC7: obs_key = 586;
pub const obs_key_OBS_KEY_0xC8: obs_key = 587;
pub const obs_key_OBS_KEY_0xC9: obs_key = 588;
pub const obs_key_OBS_KEY_0xCA: obs_key = 589;
pub const obs_key_OBS_KEY_0xCB: obs_key = 590;
pub const obs_key_OBS_KEY_0xCC: obs_key = 591;
pub const obs_key_OBS_KEY_0xCD: obs_key = 592;
pub const obs_key_OBS_KEY_0xCE: obs_key = 593;
pub const obs_key_OBS_KEY_0xCF: obs_key = 594;
pub const obs_key_OBS_KEY_0xD0: obs_key = 595;
pub const obs_key_OBS_KEY_0xD1: obs_key = 596;
pub const obs_key_OBS_KEY_0xD2: obs_key = 597;
pub const obs_key_OBS_KEY_0xD3: obs_key = 598;
pub const obs_key_OBS_KEY_0xD4: obs_key = 599;
pub const obs_key_OBS_KEY_0xD5: obs_key = 600;
pub const obs_key_OBS_KEY_0xD6: obs_key = 601;
pub const obs_key_OBS_KEY_0xD7: obs_key = 602;
pub const obs_key_OBS_KEY_0xD8: obs_key = 603;
pub const obs_key_OBS_KEY_0xD9: obs_key = 604;
pub const obs_key_OBS_KEY_0xDA: obs_key = 605;
pub const obs_key_OBS_KEY_VK_OEM_8: obs_key = 606;
pub const obs_key_OBS_KEY_0xE0: obs_key = 607;
pub const obs_key_OBS_KEY_VK_OEM_AX: obs_key = 608;
pub const obs_key_OBS_KEY_VK_ICO_HELP: obs_key = 609;
pub const obs_key_OBS_KEY_VK_ICO_00: obs_key = 610;
pub const obs_key_OBS_KEY_VK_PROCESSKEY: obs_key = 611;
pub const obs_key_OBS_KEY_VK_ICO_CLEAR: obs_key = 612;
pub const obs_key_OBS_KEY_VK_PACKET: obs_key = 613;
pub const obs_key_OBS_KEY_0xE8: obs_key = 614;
pub const obs_key_OBS_KEY_VK_OEM_RESET: obs_key = 615;
pub const obs_key_OBS_KEY_VK_OEM_JUMP: obs_key = 616;
pub const obs_key_OBS_KEY_VK_OEM_PA1: obs_key = 617;
pub const obs_key_OBS_KEY_VK_OEM_PA2: obs_key = 618;
pub const obs_key_OBS_KEY_VK_OEM_PA3: obs_key = 619;
pub const obs_key_OBS_KEY_VK_OEM_WSCTRL: obs_key = 620;
pub const obs_key_OBS_KEY_VK_OEM_CUSEL: obs_key = 621;
pub const obs_key_OBS_KEY_VK_OEM_ATTN: obs_key = 622;
pub const obs_key_OBS_KEY_VK_OEM_FINISH: obs_key = 623;
pub const obs_key_OBS_KEY_VK_OEM_COPY: obs_key = 624;
pub const obs_key_OBS_KEY_VK_OEM_AUTO: obs_key = 625;
pub const obs_key_OBS_KEY_VK_OEM_ENLW: obs_key = 626;
pub const obs_key_OBS_KEY_VK_ATTN: obs_key = 627;
pub const obs_key_OBS_KEY_VK_CRSEL: obs_key = 628;
pub const obs_key_OBS_KEY_VK_EXSEL: obs_key = 629;
pub const obs_key_OBS_KEY_VK_EREOF: obs_key = 630;
pub const obs_key_OBS_KEY_VK_PLAY: obs_key = 631;
pub const obs_key_OBS_KEY_VK_ZOOM: obs_key = 632;
pub const obs_key_OBS_KEY_VK_NONAME: obs_key = 633;
pub const obs_key_OBS_KEY_VK_PA1: obs_key = 634;
pub const obs_key_OBS_KEY_VK_OEM_CLEAR: obs_key = 635;
pub const obs_key_OBS_KEY_LAST_VALUE: obs_key = 636;
pub type obs_key = u32;
pub use self::obs_key as obs_key_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_key_combination {
    pub modifiers: u32,
    pub key: obs_key_t,
}
#[test]
fn bindgen_test_layout_obs_key_combination() {
    assert_eq!(
        ::std::mem::size_of::<obs_key_combination>(),
        8usize,
        concat!("Size of: ", stringify!(obs_key_combination))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_key_combination>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_key_combination))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_key_combination>())).modifiers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_combination),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_key_combination>())).key as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_key_combination),
            "::",
            stringify!(key)
        )
    );
}
impl Default for obs_key_combination {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type obs_key_combination_t = obs_key_combination;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_hotkey {
    _unused: [u8; 0],
}
pub type obs_hotkey_t = obs_hotkey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_hotkey_binding {
    _unused: [u8; 0],
}
pub type obs_hotkey_binding_t = obs_hotkey_binding;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_FRONTEND: obs_hotkey_registerer_type = 0;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_SOURCE: obs_hotkey_registerer_type = 1;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_OUTPUT: obs_hotkey_registerer_type = 2;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_ENCODER: obs_hotkey_registerer_type = 3;
pub const obs_hotkey_registerer_type_OBS_HOTKEY_REGISTERER_SERVICE: obs_hotkey_registerer_type = 4;
pub type obs_hotkey_registerer_type = u32;
pub use self::obs_hotkey_registerer_type as obs_hotkey_registerer_t;
extern "C" {
    pub fn obs_hotkey_get_id(key: *const obs_hotkey_t) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_get_name(key: *const obs_hotkey_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_hotkey_get_description(key: *const obs_hotkey_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_hotkey_get_registerer_type(key: *const obs_hotkey_t) -> obs_hotkey_registerer_t;
}
extern "C" {
    pub fn obs_hotkey_get_registerer(key: *const obs_hotkey_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_hotkey_get_pair_partner_id(key: *const obs_hotkey_t) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_binding_get_key_combination(
        binding: *mut obs_hotkey_binding_t,
    ) -> obs_key_combination_t;
}
extern "C" {
    pub fn obs_hotkey_binding_get_hotkey_id(binding: *mut obs_hotkey_binding_t) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_binding_get_hotkey(binding: *mut obs_hotkey_binding_t) -> *mut obs_hotkey_t;
}
extern "C" {
    pub fn obs_hotkey_set_name(id: obs_hotkey_id, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_hotkey_set_description(id: obs_hotkey_id, desc: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_hotkey_pair_set_names(
        id: obs_hotkey_pair_id,
        name0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_hotkey_pair_set_descriptions(
        id: obs_hotkey_pair_id,
        desc0: *const ::std::os::raw::c_char,
        desc1: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_hotkeys_translations {
    pub insert: *const ::std::os::raw::c_char,
    pub del: *const ::std::os::raw::c_char,
    pub home: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub page_up: *const ::std::os::raw::c_char,
    pub page_down: *const ::std::os::raw::c_char,
    pub num_lock: *const ::std::os::raw::c_char,
    pub scroll_lock: *const ::std::os::raw::c_char,
    pub caps_lock: *const ::std::os::raw::c_char,
    pub backspace: *const ::std::os::raw::c_char,
    pub tab: *const ::std::os::raw::c_char,
    pub print: *const ::std::os::raw::c_char,
    pub pause: *const ::std::os::raw::c_char,
    pub left: *const ::std::os::raw::c_char,
    pub right: *const ::std::os::raw::c_char,
    pub up: *const ::std::os::raw::c_char,
    pub down: *const ::std::os::raw::c_char,
    pub shift: *const ::std::os::raw::c_char,
    pub alt: *const ::std::os::raw::c_char,
    pub control: *const ::std::os::raw::c_char,
    pub meta: *const ::std::os::raw::c_char,
    pub menu: *const ::std::os::raw::c_char,
    pub space: *const ::std::os::raw::c_char,
    pub numpad_num: *const ::std::os::raw::c_char,
    pub numpad_divide: *const ::std::os::raw::c_char,
    pub numpad_multiply: *const ::std::os::raw::c_char,
    pub numpad_minus: *const ::std::os::raw::c_char,
    pub numpad_plus: *const ::std::os::raw::c_char,
    pub numpad_decimal: *const ::std::os::raw::c_char,
    pub apple_keypad_num: *const ::std::os::raw::c_char,
    pub apple_keypad_divide: *const ::std::os::raw::c_char,
    pub apple_keypad_multiply: *const ::std::os::raw::c_char,
    pub apple_keypad_minus: *const ::std::os::raw::c_char,
    pub apple_keypad_plus: *const ::std::os::raw::c_char,
    pub apple_keypad_decimal: *const ::std::os::raw::c_char,
    pub apple_keypad_equal: *const ::std::os::raw::c_char,
    pub mouse_num: *const ::std::os::raw::c_char,
    pub escape: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_hotkeys_translations() {
    assert_eq!(
        ::std::mem::size_of::<obs_hotkeys_translations>(),
        304usize,
        concat!("Size of: ", stringify!(obs_hotkeys_translations))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_hotkeys_translations>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_hotkeys_translations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).insert as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(insert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).del as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(del)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).home as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).page_up as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(page_up)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).page_down as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(page_down)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).num_lock as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(num_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).scroll_lock as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(scroll_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).caps_lock as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(caps_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).backspace as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(backspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).tab as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).print as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).pause as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).left as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).right as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).up as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).down as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).shift as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).alt as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).control as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).meta as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).menu as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(menu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).space as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(space)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).numpad_num as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).numpad_divide as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_divide)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).numpad_multiply as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_multiply)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).numpad_minus as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_minus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).numpad_plus as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_plus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).numpad_decimal as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(numpad_decimal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).apple_keypad_num as *const _
                as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).apple_keypad_divide as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_divide)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).apple_keypad_multiply as *const _
                as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_multiply)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).apple_keypad_minus as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_minus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).apple_keypad_plus as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_plus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).apple_keypad_decimal as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_decimal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).apple_keypad_equal as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(apple_keypad_equal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_hotkeys_translations>())).mouse_num as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(mouse_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_hotkeys_translations>())).escape as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_hotkeys_translations),
            "::",
            stringify!(escape)
        )
    );
}
impl Default for obs_hotkeys_translations {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn obs_hotkeys_set_translations_s(
        translations: *mut obs_hotkeys_translations,
        size: size_t,
    );
}
extern "C" {
    pub fn obs_hotkeys_set_audio_hotkeys_translations(
        mute: *const ::std::os::raw::c_char,
        unmute: *const ::std::os::raw::c_char,
        push_to_mute: *const ::std::os::raw::c_char,
        push_to_talk: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_hotkeys_set_sceneitem_hotkeys_translations(
        show: *const ::std::os::raw::c_char,
        hide: *const ::std::os::raw::c_char,
    );
}
pub type obs_hotkey_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id: obs_hotkey_id,
        hotkey: *mut obs_hotkey_t,
        pressed: bool,
    ),
>;
extern "C" {
    pub fn obs_hotkey_register_frontend(
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_register_encoder(
        encoder: *mut obs_encoder_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_register_output(
        output: *mut obs_output_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_register_service(
        service: *mut obs_service_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
extern "C" {
    pub fn obs_hotkey_register_source(
        source: *mut obs_source_t,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        func: obs_hotkey_func,
        data: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_id;
}
pub type obs_hotkey_active_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id: obs_hotkey_pair_id,
        hotkey: *mut obs_hotkey_t,
        pressed: bool,
    ) -> bool,
>;
extern "C" {
    pub fn obs_hotkey_pair_register_frontend(
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_pair_register_encoder(
        encoder: *mut obs_encoder_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_pair_register_output(
        output: *mut obs_output_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_pair_register_service(
        service: *mut obs_service_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_pair_register_source(
        source: *mut obs_source_t,
        name0: *const ::std::os::raw::c_char,
        description0: *const ::std::os::raw::c_char,
        name1: *const ::std::os::raw::c_char,
        description1: *const ::std::os::raw::c_char,
        func0: obs_hotkey_active_func,
        func1: obs_hotkey_active_func,
        data0: *mut ::std::os::raw::c_void,
        data1: *mut ::std::os::raw::c_void,
    ) -> obs_hotkey_pair_id;
}
extern "C" {
    pub fn obs_hotkey_unregister(id: obs_hotkey_id);
}
extern "C" {
    pub fn obs_hotkey_pair_unregister(id: obs_hotkey_pair_id);
}
extern "C" {
    pub fn obs_hotkey_load_bindings(
        id: obs_hotkey_id,
        combinations: *mut obs_key_combination_t,
        num: size_t,
    );
}
extern "C" {
    pub fn obs_hotkey_load(id: obs_hotkey_id, data: *mut obs_data_array_t);
}
extern "C" {
    pub fn obs_hotkeys_load_encoder(encoder: *mut obs_encoder_t, hotkeys: *mut obs_data_t);
}
extern "C" {
    pub fn obs_hotkeys_load_output(output: *mut obs_output_t, hotkeys: *mut obs_data_t);
}
extern "C" {
    pub fn obs_hotkeys_load_service(service: *mut obs_service_t, hotkeys: *mut obs_data_t);
}
extern "C" {
    pub fn obs_hotkeys_load_source(source: *mut obs_source_t, hotkeys: *mut obs_data_t);
}
extern "C" {
    pub fn obs_hotkey_pair_load(
        id: obs_hotkey_pair_id,
        data0: *mut obs_data_array_t,
        data1: *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_hotkey_save(id: obs_hotkey_id) -> *mut obs_data_array_t;
}
extern "C" {
    pub fn obs_hotkey_pair_save(
        id: obs_hotkey_pair_id,
        p_data0: *mut *mut obs_data_array_t,
        p_data1: *mut *mut obs_data_array_t,
    );
}
extern "C" {
    pub fn obs_hotkeys_save_encoder(encoder: *mut obs_encoder_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_hotkeys_save_output(output: *mut obs_output_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_hotkeys_save_service(service: *mut obs_service_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_hotkeys_save_source(source: *mut obs_source_t) -> *mut obs_data_t;
}
pub type obs_hotkey_enum_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        id: obs_hotkey_id,
        key: *mut obs_hotkey_t,
    ) -> bool,
>;
extern "C" {
    pub fn obs_enum_hotkeys(func: obs_hotkey_enum_func, data: *mut ::std::os::raw::c_void);
}
pub type obs_hotkey_binding_enum_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        idx: size_t,
        binding: *mut obs_hotkey_binding_t,
    ) -> bool,
>;
extern "C" {
    pub fn obs_enum_hotkey_bindings(
        func: obs_hotkey_binding_enum_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_hotkey_inject_event(hotkey: obs_key_combination_t, pressed: bool);
}
extern "C" {
    pub fn obs_hotkey_enable_background_press(enable: bool);
}
extern "C" {
    pub fn obs_hotkey_enable_strict_modifiers(enable: bool);
}
pub type obs_hotkey_callback_router_func = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: obs_hotkey_id, pressed: bool),
>;
extern "C" {
    pub fn obs_hotkey_set_callback_routing_func(
        func: obs_hotkey_callback_router_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_hotkey_trigger_routed_callback(id: obs_hotkey_id, pressed: bool);
}
extern "C" {
    pub fn obs_hotkey_enable_callback_rerouting(enable: bool);
}
pub type obs_hotkey_atomic_update_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn obs_hotkey_update_atomic(
        func: obs_hotkey_atomic_update_func,
        data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dstr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obs_key_to_str(key: obs_key_t, str: *mut dstr);
}
extern "C" {
    pub fn obs_key_combination_to_str(key: obs_key_combination_t, str: *mut dstr);
}
extern "C" {
    pub fn obs_key_from_virtual_key(code: ::std::os::raw::c_int) -> obs_key_t;
}
extern "C" {
    pub fn obs_key_to_virtual_key(key: obs_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_key_to_name(key: obs_key_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_key_from_name(name: *const ::std::os::raw::c_char) -> obs_key_t;
}
pub const obs_order_movement_OBS_ORDER_MOVE_UP: obs_order_movement = 0;
pub const obs_order_movement_OBS_ORDER_MOVE_DOWN: obs_order_movement = 1;
pub const obs_order_movement_OBS_ORDER_MOVE_TOP: obs_order_movement = 2;
pub const obs_order_movement_OBS_ORDER_MOVE_BOTTOM: obs_order_movement = 3;
#[doc = " Used for changing the order of items (for example, filters in a source,"]
#[doc = " or items in a scene)"]
pub type obs_order_movement = u32;
pub const obs_allow_direct_render_OBS_NO_DIRECT_RENDERING: obs_allow_direct_render = 0;
pub const obs_allow_direct_render_OBS_ALLOW_DIRECT_RENDERING: obs_allow_direct_render = 1;
#[doc = " Used with obs_source_process_filter to specify whether the filter should"]
#[doc = " render the source directly with the specified effect, or whether it should"]
#[doc = " render it to a texture"]
pub type obs_allow_direct_render = u32;
pub const obs_scale_type_OBS_SCALE_DISABLE: obs_scale_type = 0;
pub const obs_scale_type_OBS_SCALE_POINT: obs_scale_type = 1;
pub const obs_scale_type_OBS_SCALE_BICUBIC: obs_scale_type = 2;
pub const obs_scale_type_OBS_SCALE_BILINEAR: obs_scale_type = 3;
pub const obs_scale_type_OBS_SCALE_LANCZOS: obs_scale_type = 4;
pub const obs_scale_type_OBS_SCALE_AREA: obs_scale_type = 5;
pub type obs_scale_type = u32;
#[doc = "< no bounds"]
pub const obs_bounds_type_OBS_BOUNDS_NONE: obs_bounds_type = 0;
#[doc = "< stretch (ignores base scale)"]
pub const obs_bounds_type_OBS_BOUNDS_STRETCH: obs_bounds_type = 1;
#[doc = "< scales to inner rectangle"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_INNER: obs_bounds_type = 2;
#[doc = "< scales to outer rectangle"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_OUTER: obs_bounds_type = 3;
#[doc = "< scales to the width"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_TO_WIDTH: obs_bounds_type = 4;
#[doc = "< scales to the height"]
pub const obs_bounds_type_OBS_BOUNDS_SCALE_TO_HEIGHT: obs_bounds_type = 5;
#[doc = "< no scaling, maximum size only"]
pub const obs_bounds_type_OBS_BOUNDS_MAX_ONLY: obs_bounds_type = 6;
#[doc = " Used with scene items to indicate the type of bounds to use for scene items."]
#[doc = " Mostly determines how the image will be scaled within those bounds, or"]
#[doc = " whether to use bounds at all."]
pub type obs_bounds_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obs_transform_info {
    pub pos: vec2,
    pub rot: f32,
    pub scale: vec2,
    pub alignment: u32,
    pub bounds_type: obs_bounds_type,
    pub bounds_alignment: u32,
    pub bounds: vec2,
}
#[test]
fn bindgen_test_layout_obs_transform_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_transform_info>(),
        40usize,
        concat!("Size of: ", stringify!(obs_transform_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_transform_info>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_transform_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_transform_info>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_transform_info>())).rot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(rot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_transform_info>())).scale as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_transform_info>())).alignment as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_transform_info>())).bounds_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(bounds_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_transform_info>())).bounds_alignment as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(bounds_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_transform_info>())).bounds as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_transform_info),
            "::",
            stringify!(bounds)
        )
    );
}
impl Default for obs_transform_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Video initialization structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_video_info {
    #[doc = " Graphics module to use (usually \"libobs-opengl\" or \"libobs-d3d11\")"]
    pub graphics_module: *const ::std::os::raw::c_char,
    #[doc = "< Output FPS numerator"]
    pub fps_num: u32,
    #[doc = "< Output FPS denominator"]
    pub fps_den: u32,
    #[doc = "< Base compositing width"]
    pub base_width: u32,
    #[doc = "< Base compositing height"]
    pub base_height: u32,
    #[doc = "< Output width"]
    pub output_width: u32,
    #[doc = "< Output height"]
    pub output_height: u32,
    #[doc = "< Output format"]
    pub output_format: video_format,
    #[doc = " Video adapter index to use (NOTE: avoid for optimus laptops)"]
    pub adapter: u32,
    #[doc = " Use shaders to convert to different color formats"]
    pub gpu_conversion: bool,
    #[doc = "< YUV type (if YUV)"]
    pub colorspace: video_colorspace,
    #[doc = "< YUV range (if YUV)"]
    pub range: video_range_type,
    #[doc = "< How to scale if scaling"]
    pub scale_type: obs_scale_type,
}
#[test]
fn bindgen_test_layout_obs_video_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_video_info>(),
        56usize,
        concat!("Size of: ", stringify!(obs_video_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_video_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_video_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).graphics_module as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(graphics_module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).fps_num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(fps_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).fps_den as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(fps_den)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).base_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(base_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).base_height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(base_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).output_width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(output_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).output_height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(output_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).output_format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(output_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).adapter as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(adapter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).gpu_conversion as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(gpu_conversion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).colorspace as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).range as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_video_info>())).scale_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_video_info),
            "::",
            stringify!(scale_type)
        )
    );
}
impl Default for obs_video_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Audio initialization structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_audio_info {
    pub samples_per_sec: u32,
    pub speakers: speaker_layout,
}
#[test]
fn bindgen_test_layout_obs_audio_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_audio_info>(),
        8usize,
        concat!("Size of: ", stringify!(obs_audio_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_audio_info>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_audio_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_audio_info>())).samples_per_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_info),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_audio_info>())).speakers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_info),
            "::",
            stringify!(speakers)
        )
    );
}
impl Default for obs_audio_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Sent to source filters via the filter_audio callback to allow filtering of"]
#[doc = " audio data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_audio_data {
    pub data: [*mut u8; 8usize],
    pub frames: u32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_obs_audio_data() {
    assert_eq!(
        ::std::mem::size_of::<obs_audio_data>(),
        80usize,
        concat!("Size of: ", stringify!(obs_audio_data))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_audio_data>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_audio_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_audio_data>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_audio_data>())).frames as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_data),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_audio_data>())).timestamp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_audio_data),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for obs_audio_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Source audio output structure.  Used with obs_source_output_audio to output"]
#[doc = " source audio.  Audio is automatically resampled and remixed as necessary."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_audio {
    pub data: [*const u8; 8usize],
    pub frames: u32,
    pub speakers: speaker_layout,
    pub format: audio_format,
    pub samples_per_sec: u32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_obs_source_audio() {
    assert_eq!(
        ::std::mem::size_of::<obs_source_audio>(),
        88usize,
        concat!("Size of: ", stringify!(obs_source_audio))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_audio>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_audio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_audio>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_audio>())).frames as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_audio>())).speakers as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(speakers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_audio>())).format as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_audio>())).samples_per_sec as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(samples_per_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_audio>())).timestamp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_audio),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for obs_source_audio {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Source asynchronous video output structure.  Used with"]
#[doc = " obs_source_output_video to output asynchronous video.  Video is buffered as"]
#[doc = " necessary to play according to timestamps.  When used with audio output,"]
#[doc = " audio is synced to video as it is played."]
#[doc = ""]
#[doc = " If a YUV format is specified, it will be automatically upsampled and"]
#[doc = " converted to RGB via shader on the graphics processor."]
#[doc = ""]
#[doc = " NOTE: Non-YUV formats will always be treated as full range with this"]
#[doc = " structure!  Use obs_source_frame2 along with obs_source_output_video2"]
#[doc = " instead if partial range support is desired for non-YUV video formats."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_frame {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub width: u32,
    pub height: u32,
    pub timestamp: u64,
    pub format: video_format,
    pub color_matrix: [f32; 16usize],
    pub full_range: bool,
    pub color_range_min: [f32; 3usize],
    pub color_range_max: [f32; 3usize],
    pub flip: bool,
    pub refs: ::std::os::raw::c_long,
    pub prev_frame: bool,
}
#[test]
fn bindgen_test_layout_obs_source_frame() {
    assert_eq!(
        ::std::mem::size_of::<obs_source_frame>(),
        232usize,
        concat!("Size of: ", stringify!(obs_source_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).width as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).height as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).timestamp as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).format as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).color_matrix as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(color_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).full_range as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(full_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_frame>())).color_range_min as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(color_range_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_frame>())).color_range_max as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(color_range_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).flip as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(flip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).refs as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame>())).prev_frame as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame),
            "::",
            stringify!(prev_frame)
        )
    );
}
impl Default for obs_source_frame {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_source_frame2 {
    pub data: [*mut u8; 8usize],
    pub linesize: [u32; 8usize],
    pub width: u32,
    pub height: u32,
    pub timestamp: u64,
    pub format: video_format,
    pub range: video_range_type,
    pub color_matrix: [f32; 16usize],
    pub color_range_min: [f32; 3usize],
    pub color_range_max: [f32; 3usize],
    pub flip: bool,
}
#[test]
fn bindgen_test_layout_obs_source_frame2() {
    assert_eq!(
        ::std::mem::size_of::<obs_source_frame2>(),
        216usize,
        concat!("Size of: ", stringify!(obs_source_frame2))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_source_frame2>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_source_frame2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).width as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).height as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).timestamp as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).format as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).range as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).color_matrix as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(color_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_frame2>())).color_range_min as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(color_range_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<obs_source_frame2>())).color_range_max as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(color_range_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_source_frame2>())).flip as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_source_frame2),
            "::",
            stringify!(flip)
        )
    );
}
impl Default for obs_source_frame2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Access to the argc/argv used to start OBS. What you see is what you get."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_cmdline_args {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_cmdline_args() {
    assert_eq!(
        ::std::mem::size_of::<obs_cmdline_args>(),
        16usize,
        concat!("Size of: ", stringify!(obs_cmdline_args))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_cmdline_args>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_cmdline_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_cmdline_args>())).argc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_cmdline_args),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_cmdline_args>())).argv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_cmdline_args),
            "::",
            stringify!(argv)
        )
    );
}
impl Default for obs_cmdline_args {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Find a core libobs data file"]
    #[doc = " @param path name of the base file"]
    #[doc = " @return A string containing the full path to the file."]
    #[doc = "          Use bfree after use."]
    pub fn obs_find_data_file(file: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add a path to search libobs data files in."]
    #[doc = " @param path Full path to directory to look in."]
    #[doc = "             The string is copied."]
    pub fn obs_add_data_path(path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Remove a path from libobs core data paths."]
    #[doc = " @param path The path to compare to currently set paths."]
    #[doc = "             It does not need to be the same pointer, but"]
    #[doc = "             the path string must match an entry fully."]
    #[doc = " @return Whether or not the path was successfully removed."]
    #[doc = "         If false, the path could not be found."]
    pub fn obs_remove_data_path(path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Initializes OBS"]
    #[doc = ""]
    #[doc = " @param  locale              The locale to use for modules"]
    #[doc = " @param  module_config_path  Path to module config storage directory"]
    #[doc = "                             (or NULL if none)"]
    #[doc = " @param  store               The profiler name store for OBS to use or NULL"]
    pub fn obs_startup(
        locale: *const ::std::os::raw::c_char,
        module_config_path: *const ::std::os::raw::c_char,
        store: *mut profiler_name_store_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Releases all data associated with OBS and terminates the OBS context"]
    pub fn obs_shutdown();
}
extern "C" {
    #[doc = " @return true if the main OBS context has been initialized"]
    pub fn obs_initialized() -> bool;
}
extern "C" {
    #[doc = " @return The current core version"]
    pub fn obs_get_version() -> u32;
}
extern "C" {
    #[doc = " @return The current core version string"]
    pub fn obs_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets things up for calls to obs_get_cmdline_args. Called only once at startup"]
    #[doc = " and safely copies argv/argc from main(). Subsequent calls do nothing."]
    #[doc = ""]
    #[doc = " @param  argc  The count of command line arguments, from main()"]
    #[doc = " @param  argv  An array of command line arguments, copied from main() and ends"]
    #[doc = "               with NULL."]
    pub fn obs_set_cmdline_args(
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Get the argc/argv used to start OBS"]
    #[doc = ""]
    #[doc = " @return  The command line arguments used for main(). Don't modify this or"]
    #[doc = "          you'll mess things up for other callers."]
    pub fn obs_get_cmdline_args() -> obs_cmdline_args;
}
extern "C" {
    #[doc = " Sets a new locale to use for modules.  This will call obs_module_set_locale"]
    #[doc = " for each module with the new locale."]
    #[doc = ""]
    #[doc = " @param  locale  The locale to use for modules"]
    pub fn obs_set_locale(locale: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @return the current locale"]
    pub fn obs_get_locale() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the profiler name store (see util/profiler.h) used by OBS, which is"]
    #[doc = " either a name store passed to obs_startup, an internal name store, or NULL"]
    #[doc = " in case obs_initialized() returns false."]
    pub fn obs_get_profiler_name_store() -> *mut profiler_name_store_t;
}
extern "C" {
    #[doc = " Sets base video output base resolution/fps/format."]
    #[doc = ""]
    #[doc = " @note This data cannot be changed if an output is currently active."]
    #[doc = " @note The graphics module cannot be changed without fully destroying the"]
    #[doc = "       OBS context."]
    #[doc = ""]
    #[doc = " @param   ovi  Pointer to an obs_video_info structure containing the"]
    #[doc = "               specification of the graphics subsystem,"]
    #[doc = " @return       OBS_VIDEO_SUCCESS if successful"]
    #[doc = "               OBS_VIDEO_NOT_SUPPORTED if the adapter lacks capabilities"]
    #[doc = "               OBS_VIDEO_INVALID_PARAM if a parameter is invalid"]
    #[doc = "               OBS_VIDEO_CURRENTLY_ACTIVE if video is currently active"]
    #[doc = "               OBS_VIDEO_MODULE_NOT_FOUND if the graphics module is not found"]
    #[doc = "               OBS_VIDEO_FAIL for generic failure"]
    pub fn obs_reset_video(ovi: *mut obs_video_info) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets base audio output format/channels/samples/etc"]
    #[doc = ""]
    #[doc = " @note Cannot reset base audio if an output is currently active."]
    pub fn obs_reset_audio(oai: *const obs_audio_info) -> bool;
}
extern "C" {
    #[doc = " Gets the current video settings, returns false if no video"]
    pub fn obs_get_video_info(ovi: *mut obs_video_info) -> bool;
}
extern "C" {
    #[doc = " Gets the current audio settings, returns false if no audio"]
    pub fn obs_get_audio_info(oai: *mut obs_audio_info) -> bool;
}
extern "C" {
    #[doc = " Opens a plugin module directly from a specific path."]
    #[doc = ""]
    #[doc = " If the module already exists then the function will return successful, and"]
    #[doc = " the module parameter will be given the pointer to the existing module."]
    #[doc = ""]
    #[doc = " This does not initialize the module, it only loads the module image.  To"]
    #[doc = " initialize the module, call obs_init_module."]
    #[doc = ""]
    #[doc = " @param  module     The pointer to the created module."]
    #[doc = " @param  path       Specifies the path to the module library file.  If the"]
    #[doc = "                    extension is not specified, it will use the extension"]
    #[doc = "                    appropriate to the operating system."]
    #[doc = " @param  data_path  Specifies the path to the directory where the module's"]
    #[doc = "                    data files are stored."]
    #[doc = " @returns           MODULE_SUCCESS if successful"]
    #[doc = "                    MODULE_ERROR if a generic error occurred"]
    #[doc = "                    MODULE_FILE_NOT_FOUND if the module was not found"]
    #[doc = "                    MODULE_MISSING_EXPORTS if required exports are missing"]
    #[doc = "                    MODULE_INCOMPATIBLE_VER if incompatible version"]
    pub fn obs_open_module(
        module: *mut *mut obs_module_t,
        path: *const ::std::os::raw::c_char,
        data_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes the module, which calls its obs_module_load export.  If the"]
    #[doc = " module is already loaded, then this function does nothing and returns"]
    #[doc = " successful."]
    pub fn obs_init_module(module: *mut obs_module_t) -> bool;
}
extern "C" {
    #[doc = " Logs loaded modules"]
    pub fn obs_log_loaded_modules();
}
extern "C" {
    #[doc = " Returns the module file name"]
    pub fn obs_get_module_file_name(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module full name"]
    pub fn obs_get_module_name(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module author(s)"]
    pub fn obs_get_module_author(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module description"]
    pub fn obs_get_module_description(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module binary path"]
    pub fn obs_get_module_binary_path(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the module data path"]
    pub fn obs_get_module_data_path(module: *mut obs_module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Adds a module search path to be used with obs_find_modules.  If the search"]
    #[doc = " path strings contain %module%, that text will be replaced with the module"]
    #[doc = " name when used."]
    #[doc = ""]
    #[doc = " @param  bin   Specifies the module's binary directory search path."]
    #[doc = " @param  data  Specifies the module's data directory search path."]
    pub fn obs_add_module_path(
        bin: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Automatically loads all modules from module paths (convenience function)"]
    pub fn obs_load_all_modules();
}
extern "C" {
    #[doc = " Notifies modules that all modules have been loaded.  This function should"]
    #[doc = " be called after all modules have been loaded."]
    pub fn obs_post_load_modules();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_module_info {
    pub bin_path: *const ::std::os::raw::c_char,
    pub data_path: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obs_module_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_module_info>(),
        16usize,
        concat!("Size of: ", stringify!(obs_module_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_module_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_module_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_module_info>())).bin_path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_info),
            "::",
            stringify!(bin_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_module_info>())).data_path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_module_info),
            "::",
            stringify!(data_path)
        )
    );
}
impl Default for obs_module_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type obs_find_module_callback_t = ::std::option::Option<
    unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, info: *const obs_module_info),
>;
extern "C" {
    #[doc = " Finds all modules within the search paths added by obs_add_module_path."]
    pub fn obs_find_modules(
        callback: obs_find_module_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
}
pub type obs_enum_module_callback_t = ::std::option::Option<
    unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, module: *mut obs_module_t),
>;
extern "C" {
    #[doc = " Enumerates all loaded modules"]
    pub fn obs_enum_modules(
        callback: obs_enum_module_callback_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Helper function for using default module locale"]
    pub fn obs_module_load_locale(
        module: *mut obs_module_t,
        default_locale: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
    ) -> *mut lookup_t;
}
extern "C" {
    #[doc = " Returns the location of a plugin module data file."]
    #[doc = ""]
    #[doc = " @note   Modules should use obs_module_file function defined in obs-module.h"]
    #[doc = "         as a more elegant means of getting their files without having to"]
    #[doc = "         specify the module parameter."]
    #[doc = ""]
    #[doc = " @param  module  The module associated with the file to locate"]
    #[doc = " @param  file    The file to locate"]
    #[doc = " @return         Path string, or NULL if not found.  Use bfree to free string."]
    pub fn obs_find_module_file(
        module: *mut obs_module_t,
        file: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the path of a plugin module config file (whether it exists or not)"]
    #[doc = ""]
    #[doc = " @note   Modules should use obs_module_config_path function defined in"]
    #[doc = "         obs-module.h as a more elegant means of getting their files without"]
    #[doc = "         having to specify the module parameter."]
    #[doc = ""]
    #[doc = " @param  module  The module associated with the path"]
    #[doc = " @param  file    The file to get a path to"]
    #[doc = " @return         Path string, or NULL if not found.  Use bfree to free string."]
    pub fn obs_module_get_config_path(
        module: *mut obs_module_t,
        file: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enumerates all source types (inputs, filters, transitions, etc)."]
    pub fn obs_enum_source_types(idx: size_t, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available inputs source types."]
    #[doc = ""]
    #[doc = "   Inputs are general source inputs (such as capture sources, device sources,"]
    #[doc = " etc)."]
    pub fn obs_enum_input_types(idx: size_t, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_enum_input_types2(
        idx: size_t,
        id: *mut *const ::std::os::raw::c_char,
        unversioned_id: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_get_latest_input_type_id(
        unversioned_id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enumerates all available filter source types."]
    #[doc = ""]
    #[doc = "   Filters are sources that are used to modify the video/audio output of"]
    #[doc = " other sources."]
    pub fn obs_enum_filter_types(idx: size_t, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available transition source types."]
    #[doc = ""]
    #[doc = "   Transitions are sources used to transition between two or more other"]
    #[doc = " sources."]
    pub fn obs_enum_transition_types(idx: size_t, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available output types."]
    pub fn obs_enum_output_types(idx: size_t, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available encoder types."]
    pub fn obs_enum_encoder_types(idx: size_t, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enumerates all available service types."]
    pub fn obs_enum_service_types(idx: size_t, id: *mut *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Helper function for entering the OBS graphics context"]
    pub fn obs_enter_graphics();
}
extern "C" {
    #[doc = " Helper function for leaving the OBS graphics context"]
    pub fn obs_leave_graphics();
}
extern "C" {
    #[doc = " Gets the main audio output handler for this OBS context"]
    pub fn obs_get_audio() -> *mut audio_t;
}
extern "C" {
    #[doc = " Gets the main video output handler for this OBS context"]
    pub fn obs_get_video() -> *mut video_t;
}
extern "C" {
    #[doc = " Returns true if video is active, false otherwise"]
    pub fn obs_video_active() -> bool;
}
extern "C" {
    #[doc = " Sets the primary output source for a channel."]
    pub fn obs_set_output_source(channel: u32, source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Gets the primary output source for a channel and increments the reference"]
    #[doc = " counter for that source.  Use obs_source_release to release."]
    pub fn obs_get_output_source(channel: u32) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Enumerates all input sources"]
    #[doc = ""]
    #[doc = "   Callback function returns true to continue enumeration, or false to end"]
    #[doc = " enumeration."]
    #[doc = ""]
    #[doc = "   Use obs_source_get_ref or obs_source_get_weak_source if you want to retain"]
    #[doc = " a reference after obs_enum_sources finishes"]
    pub fn obs_enum_sources(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_source_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates scenes"]
    pub fn obs_enum_scenes(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_source_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates outputs"]
    pub fn obs_enum_outputs(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_output_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates encoders"]
    pub fn obs_enum_encoders(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_encoder_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates encoders"]
    pub fn obs_enum_services(
        enum_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut obs_service_t,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Gets a source by its name."]
    #[doc = ""]
    #[doc = "   Increments the source reference counter, use obs_source_release to"]
    #[doc = " release it when complete."]
    pub fn obs_get_source_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Gets an output by its name."]
    pub fn obs_get_output_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_output_t;
}
extern "C" {
    #[doc = " Gets an encoder by its name."]
    pub fn obs_get_encoder_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Gets an service by its name."]
    pub fn obs_get_service_by_name(name: *const ::std::os::raw::c_char) -> *mut obs_service_t;
}
#[doc = "< RGB/YUV"]
pub const obs_base_effect_OBS_EFFECT_DEFAULT: obs_base_effect = 0;
#[doc = "< RGB/YUV (using texture_rect)"]
pub const obs_base_effect_OBS_EFFECT_DEFAULT_RECT: obs_base_effect = 1;
#[doc = "< RGB/YUV (alpha set to 1.0)"]
pub const obs_base_effect_OBS_EFFECT_OPAQUE: obs_base_effect = 2;
#[doc = "< RGB/YUV (solid color only)"]
pub const obs_base_effect_OBS_EFFECT_SOLID: obs_base_effect = 3;
#[doc = "< Bicubic downscale"]
pub const obs_base_effect_OBS_EFFECT_BICUBIC: obs_base_effect = 4;
#[doc = "< Lanczos downscale"]
pub const obs_base_effect_OBS_EFFECT_LANCZOS: obs_base_effect = 5;
#[doc = "< Bilinear low resolution downscale"]
pub const obs_base_effect_OBS_EFFECT_BILINEAR_LOWRES: obs_base_effect = 6;
#[doc = "< Premultiplied alpha"]
pub const obs_base_effect_OBS_EFFECT_PREMULTIPLIED_ALPHA: obs_base_effect = 7;
#[doc = "< RGB/YUV (repeating)"]
pub const obs_base_effect_OBS_EFFECT_REPEAT: obs_base_effect = 8;
#[doc = "< Area rescale"]
pub const obs_base_effect_OBS_EFFECT_AREA: obs_base_effect = 9;
pub type obs_base_effect = u32;
extern "C" {
    #[doc = " Returns a commonly used base effect"]
    pub fn obs_get_base_effect(effect: obs_base_effect) -> *mut gs_effect_t;
}
extern "C" {
    pub fn obs_get_default_rect_effect() -> *mut gs_effect_t;
}
extern "C" {
    #[doc = " Returns the primary obs signal handler"]
    pub fn obs_get_signal_handler() -> *mut signal_handler_t;
}
extern "C" {
    #[doc = " Returns the primary obs procedure handler"]
    pub fn obs_get_proc_handler() -> *mut proc_handler_t;
}
extern "C" {
    #[doc = " Renders the main view"]
    pub fn obs_render_main_view();
}
extern "C" {
    #[doc = " Renders the last main output texture"]
    pub fn obs_render_main_texture();
}
extern "C" {
    #[doc = " Renders the last main output texture ignoring background color"]
    pub fn obs_render_main_texture_src_color_only();
}
extern "C" {
    #[doc = " Returns the last main output texture.  This can return NULL if the texture"]
    #[doc = " is unavailable."]
    pub fn obs_get_main_texture() -> *mut gs_texture_t;
}
extern "C" {
    #[doc = " Sets the master user volume"]
    pub fn obs_set_master_volume(volume: f32);
}
extern "C" {
    #[doc = " Gets the master user volume"]
    pub fn obs_get_master_volume() -> f32;
}
extern "C" {
    #[doc = " Saves a source to settings data"]
    pub fn obs_save_source(source: *mut obs_source_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Loads a source from settings data"]
    pub fn obs_load_source(data: *mut obs_data_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Send a save signal to sources"]
    pub fn obs_source_save(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Send a load signal to sources"]
    pub fn obs_source_load(source: *mut obs_source_t);
}
pub type obs_load_source_cb = ::std::option::Option<
    unsafe extern "C" fn(private_data: *mut ::std::os::raw::c_void, source: *mut obs_source_t),
>;
extern "C" {
    #[doc = " Loads sources from a data array"]
    pub fn obs_load_sources(
        array: *mut obs_data_array_t,
        cb: obs_load_source_cb,
        private_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Saves sources to a data array"]
    pub fn obs_save_sources() -> *mut obs_data_array_t;
}
pub type obs_save_source_filter_cb = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, source: *mut obs_source_t) -> bool,
>;
extern "C" {
    pub fn obs_save_sources_filtered(
        cb: obs_save_source_filter_cb,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut obs_data_array_t;
}
pub const obs_obj_type_OBS_OBJ_TYPE_INVALID: obs_obj_type = 0;
pub const obs_obj_type_OBS_OBJ_TYPE_SOURCE: obs_obj_type = 1;
pub const obs_obj_type_OBS_OBJ_TYPE_OUTPUT: obs_obj_type = 2;
pub const obs_obj_type_OBS_OBJ_TYPE_ENCODER: obs_obj_type = 3;
pub const obs_obj_type_OBS_OBJ_TYPE_SERVICE: obs_obj_type = 4;
pub type obs_obj_type = u32;
extern "C" {
    pub fn obs_obj_get_type(obj: *mut ::std::os::raw::c_void) -> obs_obj_type;
}
extern "C" {
    pub fn obs_obj_get_id(obj: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_obj_invalid(obj: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn obs_obj_get_data(obj: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
pub type obs_enum_audio_device_cb = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
    ) -> bool,
>;
extern "C" {
    pub fn obs_enum_audio_monitoring_devices(
        cb: obs_enum_audio_device_cb,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_set_audio_monitoring_device(
        name: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn obs_get_audio_monitoring_device(
        name: *mut *const ::std::os::raw::c_char,
        id: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_add_tick_callback(
        tick: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, seconds: f32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_remove_tick_callback(
        tick: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, seconds: f32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_add_main_render_callback(
        draw: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_remove_main_render_callback(
        draw: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_add_raw_video_callback(
        conversion: *const video_scale_info,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_remove_raw_video_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, frame: *mut video_data),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_get_video_frame_time() -> u64;
}
extern "C" {
    pub fn obs_get_active_fps() -> f64;
}
extern "C" {
    pub fn obs_get_average_frame_time_ns() -> u64;
}
extern "C" {
    pub fn obs_get_frame_interval_ns() -> u64;
}
extern "C" {
    pub fn obs_get_total_frames() -> u32;
}
extern "C" {
    pub fn obs_get_lagged_frames() -> u32;
}
extern "C" {
    pub fn obs_nv12_tex_active() -> bool;
}
extern "C" {
    pub fn obs_apply_private_data(settings: *mut obs_data_t);
}
extern "C" {
    pub fn obs_set_private_data(settings: *mut obs_data_t);
}
extern "C" {
    pub fn obs_get_private_data() -> *mut obs_data_t;
}
pub type obs_task_t =
    ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>;
pub const obs_task_type_OBS_TASK_UI: obs_task_type = 0;
pub const obs_task_type_OBS_TASK_GRAPHICS: obs_task_type = 1;
pub type obs_task_type = u32;
extern "C" {
    pub fn obs_queue_task(
        type_: obs_task_type,
        task: obs_task_t,
        param: *mut ::std::os::raw::c_void,
        wait: bool,
    );
}
pub type obs_task_handler_t = ::std::option::Option<
    unsafe extern "C" fn(task: obs_task_t, param: *mut ::std::os::raw::c_void, wait: bool),
>;
extern "C" {
    pub fn obs_set_ui_task_handler(handler: obs_task_handler_t);
}
extern "C" {
    #[doc = " Creates a view context."]
    #[doc = ""]
    #[doc = "   A view can be used for things like separate previews, or drawing"]
    #[doc = " sources separately."]
    pub fn obs_view_create() -> *mut obs_view_t;
}
extern "C" {
    #[doc = " Destroys this view context"]
    pub fn obs_view_destroy(view: *mut obs_view_t);
}
extern "C" {
    #[doc = " Sets the source to be used for this view context."]
    pub fn obs_view_set_source(view: *mut obs_view_t, channel: u32, source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Gets the source currently in use for this view context"]
    pub fn obs_view_get_source(view: *mut obs_view_t, channel: u32) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Renders the sources of this view context"]
    pub fn obs_view_render(view: *mut obs_view_t);
}
extern "C" {
    #[doc = " Adds a new window display linked to the main render pipeline.  This creates"]
    #[doc = " a new swap chain which updates every frame."]
    #[doc = ""]
    #[doc = " @param  graphics_data  The swap chain initialization data."]
    #[doc = " @return                The new display context, or NULL if failed."]
    pub fn obs_display_create(
        graphics_data: *const gs_init_data,
        backround_color: u32,
    ) -> *mut obs_display_t;
}
extern "C" {
    #[doc = " Destroys a display context"]
    pub fn obs_display_destroy(display: *mut obs_display_t);
}
extern "C" {
    #[doc = " Changes the size of this display"]
    pub fn obs_display_resize(display: *mut obs_display_t, cx: u32, cy: u32);
}
extern "C" {
    #[doc = " Adds a draw callback for this display context"]
    #[doc = ""]
    #[doc = " @param  display  The display context."]
    #[doc = " @param  draw     The draw callback which is called each time a frame"]
    #[doc = "                  updates."]
    #[doc = " @param  param    The user data to be associated with this draw callback."]
    pub fn obs_display_add_draw_callback(
        display: *mut obs_display_t,
        draw: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Removes a draw callback for this display context"]
    pub fn obs_display_remove_draw_callback(
        display: *mut obs_display_t,
        draw: ::std::option::Option<
            unsafe extern "C" fn(param: *mut ::std::os::raw::c_void, cx: u32, cy: u32),
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_display_set_enabled(display: *mut obs_display_t, enable: bool);
}
extern "C" {
    pub fn obs_display_enabled(display: *mut obs_display_t) -> bool;
}
extern "C" {
    pub fn obs_display_set_background_color(display: *mut obs_display_t, color: u32);
}
extern "C" {
    pub fn obs_display_size(display: *mut obs_display_t, width: *mut u32, height: *mut u32);
}
extern "C" {
    #[doc = " Returns the translated display name of a source"]
    pub fn obs_source_get_display_name(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a source of the specified type with the specified settings."]
    #[doc = ""]
    #[doc = "   The \"source\" context is used for anything related to presenting"]
    #[doc = " or modifying video/audio.  Use obs_source_release to release it."]
    pub fn obs_source_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_source_create_private(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
    ) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_source_duplicate(
        source: *mut obs_source_t,
        desired_name: *const ::std::os::raw::c_char,
        create_private: bool,
    ) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Adds/releases a reference to a source.  When the last reference is"]
    #[doc = " released, the source is destroyed."]
    pub fn obs_source_addref(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_release(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_weak_source_addref(weak: *mut obs_weak_source_t);
}
extern "C" {
    pub fn obs_weak_source_release(weak: *mut obs_weak_source_t);
}
extern "C" {
    pub fn obs_source_get_ref(source: *mut obs_source_t) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_source_get_weak_source(source: *mut obs_source_t) -> *mut obs_weak_source_t;
}
extern "C" {
    pub fn obs_weak_source_get_source(weak: *mut obs_weak_source_t) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_weak_source_references_source(
        weak: *mut obs_weak_source_t,
        source: *mut obs_source_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Notifies all references that the source should be released"]
    pub fn obs_source_remove(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Returns true if the source should be released"]
    pub fn obs_source_removed(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Returns capability flags of a source"]
    pub fn obs_source_get_output_flags(source: *const obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Returns capability flags of a source type"]
    pub fn obs_get_source_output_flags(id: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    #[doc = " Gets the default settings for a source type"]
    pub fn obs_get_source_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_source_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Returns whether the source has custom properties or not"]
    pub fn obs_is_source_configurable(id: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn obs_source_configurable(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Returns the properties list for a specific existing source.  Free with"]
    #[doc = " obs_properties_destroy"]
    pub fn obs_source_properties(source: *const obs_source_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Updates settings for this source"]
    pub fn obs_source_update(source: *mut obs_source_t, settings: *mut obs_data_t);
}
extern "C" {
    #[doc = " Renders a video source."]
    pub fn obs_source_video_render(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Gets the width of a source (if it has video)"]
    pub fn obs_source_get_width(source: *mut obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Gets the height of a source (if it has video)"]
    pub fn obs_source_get_height(source: *mut obs_source_t) -> u32;
}
extern "C" {
    #[doc = " If the source is a filter, returns the parent source of the filter.  Only"]
    #[doc = " guaranteed to be valid inside of the video_render, filter_audio,"]
    #[doc = " filter_video, and filter_remove callbacks."]
    pub fn obs_filter_get_parent(filter: *const obs_source_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " If the source is a filter, returns the target source of the filter.  Only"]
    #[doc = " guaranteed to be valid inside of the video_render, filter_audio,"]
    #[doc = " filter_video, and filter_remove callbacks."]
    pub fn obs_filter_get_target(filter: *const obs_source_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Used to directly render a non-async source without any filter processing"]
    pub fn obs_source_default_render(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Adds a filter to the source (which is used whenever the source is used)"]
    pub fn obs_source_filter_add(source: *mut obs_source_t, filter: *mut obs_source_t);
}
extern "C" {
    #[doc = " Removes a filter from the source"]
    pub fn obs_source_filter_remove(source: *mut obs_source_t, filter: *mut obs_source_t);
}
extern "C" {
    #[doc = " Modifies the order of a specific filter"]
    pub fn obs_source_filter_set_order(
        source: *mut obs_source_t,
        filter: *mut obs_source_t,
        movement: obs_order_movement,
    );
}
extern "C" {
    #[doc = " Gets the settings string for a source"]
    pub fn obs_source_get_settings(source: *const obs_source_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Gets the name of a source"]
    pub fn obs_source_get_name(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the name of a source"]
    pub fn obs_source_set_name(source: *mut obs_source_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets the source type"]
    pub fn obs_source_get_type(source: *const obs_source_t) -> obs_source_type;
}
extern "C" {
    #[doc = " Gets the source identifier"]
    pub fn obs_source_get_id(source: *const obs_source_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_source_get_unversioned_id(
        source: *const obs_source_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the signal handler for a source"]
    pub fn obs_source_get_signal_handler(source: *const obs_source_t) -> *mut signal_handler_t;
}
extern "C" {
    #[doc = " Returns the procedure handler for a source"]
    pub fn obs_source_get_proc_handler(source: *const obs_source_t) -> *mut proc_handler_t;
}
extern "C" {
    #[doc = " Sets the user volume for a source that has audio output"]
    pub fn obs_source_set_volume(source: *mut obs_source_t, volume: f32);
}
extern "C" {
    #[doc = " Gets the user volume for a source that has audio output"]
    pub fn obs_source_get_volume(source: *const obs_source_t) -> f32;
}
extern "C" {
    pub fn obs_source_get_speaker_layout(source: *mut obs_source_t) -> speaker_layout;
}
extern "C" {
    #[doc = " Sets the balance value for a stereo audio source"]
    pub fn obs_source_set_balance_value(source: *mut obs_source_t, balance: f32);
}
extern "C" {
    #[doc = " Gets the balance value for a stereo audio source"]
    pub fn obs_source_get_balance_value(source: *const obs_source_t) -> f32;
}
extern "C" {
    #[doc = " Sets the audio sync offset (in nanoseconds) for a source"]
    pub fn obs_source_set_sync_offset(source: *mut obs_source_t, offset: i64);
}
extern "C" {
    #[doc = " Gets the audio sync offset (in nanoseconds) for a source"]
    pub fn obs_source_get_sync_offset(source: *const obs_source_t) -> i64;
}
extern "C" {
    #[doc = " Enumerates active child sources used by this source"]
    pub fn obs_source_enum_active_sources(
        source: *mut obs_source_t,
        enum_callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enumerates the entire active child source tree used by this source"]
    pub fn obs_source_enum_active_tree(
        source: *mut obs_source_t,
        enum_callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns true if active, false if not"]
    pub fn obs_source_active(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Returns true if currently displayed somewhere (active or not), false if not"]
    pub fn obs_source_showing(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Sets source flags.  Note that these are different from the main output"]
    #[doc = " flags.  These are generally things that can be set by the source or user,"]
    #[doc = " while the output flags are more used to determine capabilities of a source."]
    pub fn obs_source_set_flags(source: *mut obs_source_t, flags: u32);
}
extern "C" {
    #[doc = " Gets source flags."]
    pub fn obs_source_get_flags(source: *const obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Sets audio mixer flags.  These flags are used to specify which mixers"]
    #[doc = " the source's audio should be applied to."]
    pub fn obs_source_set_audio_mixers(source: *mut obs_source_t, mixers: u32);
}
extern "C" {
    #[doc = " Gets audio mixer flags"]
    pub fn obs_source_get_audio_mixers(source: *const obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Increments the 'showing' reference counter to indicate that the source is"]
    #[doc = " being shown somewhere.  If the reference counter was 0, will call the 'show'"]
    #[doc = " callback."]
    pub fn obs_source_inc_showing(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Increments the 'active' reference counter to indicate that the source is"]
    #[doc = " fully active.  If the reference counter was 0, will call the 'activate'"]
    #[doc = " callback."]
    #[doc = ""]
    #[doc = " Unlike obs_source_inc_showing, this will cause children of this source to be"]
    #[doc = " considered showing as well (currently used by transition previews to make"]
    #[doc = " the stinger transition show correctly).  obs_source_inc_showing should"]
    #[doc = " generally be used instead."]
    pub fn obs_source_inc_active(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Decrements the 'showing' reference counter to indicate that the source is"]
    #[doc = " no longer being shown somewhere.  If the reference counter is set to 0,"]
    #[doc = " will call the 'hide' callback"]
    pub fn obs_source_dec_showing(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Decrements the 'active' reference counter to indicate that the source is no"]
    #[doc = " longer fully active.  If the reference counter is set to 0, will call the"]
    #[doc = " 'deactivate' callback"]
    #[doc = ""]
    #[doc = " Unlike obs_source_dec_showing, this will cause children of this source to be"]
    #[doc = " considered not showing as well.  obs_source_dec_showing should generally be"]
    #[doc = " used instead."]
    pub fn obs_source_dec_active(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Enumerates filters assigned to the source"]
    pub fn obs_source_enum_filters(
        source: *mut obs_source_t,
        callback: obs_source_enum_proc_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Gets a filter of a source by its display name."]
    pub fn obs_source_get_filter_by_name(
        source: *mut obs_source_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_source_copy_filters(dst: *mut obs_source_t, src: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_enabled(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_set_enabled(source: *mut obs_source_t, enabled: bool);
}
extern "C" {
    pub fn obs_source_muted(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_set_muted(source: *mut obs_source_t, muted: bool);
}
extern "C" {
    pub fn obs_source_push_to_mute_enabled(source: *mut obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_enable_push_to_mute(source: *mut obs_source_t, enabled: bool);
}
extern "C" {
    pub fn obs_source_get_push_to_mute_delay(source: *mut obs_source_t) -> u64;
}
extern "C" {
    pub fn obs_source_set_push_to_mute_delay(source: *mut obs_source_t, delay: u64);
}
extern "C" {
    pub fn obs_source_push_to_talk_enabled(source: *mut obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_enable_push_to_talk(source: *mut obs_source_t, enabled: bool);
}
extern "C" {
    pub fn obs_source_get_push_to_talk_delay(source: *mut obs_source_t) -> u64;
}
extern "C" {
    pub fn obs_source_set_push_to_talk_delay(source: *mut obs_source_t, delay: u64);
}
pub type obs_source_audio_capture_t = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        source: *mut obs_source_t,
        audio_data: *const audio_data,
        muted: bool,
    ),
>;
extern "C" {
    pub fn obs_source_add_audio_capture_callback(
        source: *mut obs_source_t,
        callback: obs_source_audio_capture_t,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_source_remove_audio_capture_callback(
        source: *mut obs_source_t,
        callback: obs_source_audio_capture_t,
        param: *mut ::std::os::raw::c_void,
    );
}
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_DISABLE: obs_deinterlace_mode = 0;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_DISCARD: obs_deinterlace_mode = 1;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_RETRO: obs_deinterlace_mode = 2;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_BLEND: obs_deinterlace_mode = 3;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_BLEND_2X: obs_deinterlace_mode = 4;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_LINEAR: obs_deinterlace_mode = 5;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_LINEAR_2X: obs_deinterlace_mode = 6;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_YADIF: obs_deinterlace_mode = 7;
pub const obs_deinterlace_mode_OBS_DEINTERLACE_MODE_YADIF_2X: obs_deinterlace_mode = 8;
pub type obs_deinterlace_mode = u32;
pub const obs_deinterlace_field_order_OBS_DEINTERLACE_FIELD_ORDER_TOP: obs_deinterlace_field_order =
    0;
pub const obs_deinterlace_field_order_OBS_DEINTERLACE_FIELD_ORDER_BOTTOM:
    obs_deinterlace_field_order = 1;
pub type obs_deinterlace_field_order = u32;
extern "C" {
    pub fn obs_source_set_deinterlace_mode(source: *mut obs_source_t, mode: obs_deinterlace_mode);
}
extern "C" {
    pub fn obs_source_get_deinterlace_mode(source: *const obs_source_t) -> obs_deinterlace_mode;
}
extern "C" {
    pub fn obs_source_set_deinterlace_field_order(
        source: *mut obs_source_t,
        field_order: obs_deinterlace_field_order,
    );
}
extern "C" {
    pub fn obs_source_get_deinterlace_field_order(
        source: *const obs_source_t,
    ) -> obs_deinterlace_field_order;
}
pub const obs_monitoring_type_OBS_MONITORING_TYPE_NONE: obs_monitoring_type = 0;
pub const obs_monitoring_type_OBS_MONITORING_TYPE_MONITOR_ONLY: obs_monitoring_type = 1;
pub const obs_monitoring_type_OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT: obs_monitoring_type = 2;
pub type obs_monitoring_type = u32;
extern "C" {
    pub fn obs_source_set_monitoring_type(source: *mut obs_source_t, type_: obs_monitoring_type);
}
extern "C" {
    pub fn obs_source_get_monitoring_type(source: *const obs_source_t) -> obs_monitoring_type;
}
extern "C" {
    #[doc = " Gets private front-end settings data.  This data is saved/loaded"]
    #[doc = " automatically.  Returns an incremented reference."]
    pub fn obs_source_get_private_settings(item: *mut obs_source_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_source_get_type_data(source: *mut obs_source_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Helper function to set the color matrix information when drawing the source."]
    #[doc = ""]
    #[doc = " @param  color_matrix     The color matrix.  Assigns to the 'color_matrix'"]
    #[doc = "                          effect variable."]
    #[doc = " @param  color_range_min  The minimum color range.  Assigns to the"]
    #[doc = "                          'color_range_min' effect variable.  If NULL,"]
    #[doc = "                          {0.0f, 0.0f, 0.0f} is used."]
    #[doc = " @param  color_range_max  The maximum color range.  Assigns to the"]
    #[doc = "                          'color_range_max' effect variable.  If NULL,"]
    #[doc = "                          {1.0f, 1.0f, 1.0f} is used."]
    pub fn obs_source_draw_set_color_matrix(
        color_matrix: *const matrix4,
        color_range_min: *const vec3,
        color_range_max: *const vec3,
    );
}
extern "C" {
    #[doc = " Helper function to draw sprites for a source (synchronous video)."]
    #[doc = ""]
    #[doc = " @param  image   The sprite texture to draw.  Assigns to the 'image' variable"]
    #[doc = "                 of the current effect."]
    #[doc = " @param  x       X position of the sprite."]
    #[doc = " @param  y       Y position of the sprite."]
    #[doc = " @param  cx      Width of the sprite.  If 0, uses the texture width."]
    #[doc = " @param  cy      Height of the sprite.  If 0, uses the texture height."]
    #[doc = " @param  flip    Specifies whether to flip the image vertically."]
    pub fn obs_source_draw(
        image: *mut gs_texture_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: u32,
        cy: u32,
        flip: bool,
    );
}
extern "C" {
    #[doc = " Outputs asynchronous video data.  Set to NULL to deactivate the texture"]
    #[doc = ""]
    #[doc = " NOTE: Non-YUV formats will always be treated as full range with this"]
    #[doc = " function!  Use obs_source_output_video2 instead if partial range support is"]
    #[doc = " desired for non-YUV video formats."]
    pub fn obs_source_output_video(source: *mut obs_source_t, frame: *const obs_source_frame);
}
extern "C" {
    pub fn obs_source_output_video2(source: *mut obs_source_t, frame: *const obs_source_frame2);
}
extern "C" {
    pub fn obs_source_set_async_rotation(
        source: *mut obs_source_t,
        rotation: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " Preloads asynchronous video data to allow instantaneous playback"]
    #[doc = ""]
    #[doc = " NOTE: Non-YUV formats will always be treated as full range with this"]
    #[doc = " function!  Use obs_source_preload_video2 instead if partial range support is"]
    #[doc = " desired for non-YUV video formats."]
    pub fn obs_source_preload_video(source: *mut obs_source_t, frame: *const obs_source_frame);
}
extern "C" {
    pub fn obs_source_preload_video2(source: *mut obs_source_t, frame: *const obs_source_frame2);
}
extern "C" {
    #[doc = " Shows any preloaded video data"]
    pub fn obs_source_show_preloaded_video(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Outputs audio data (always asynchronous)"]
    pub fn obs_source_output_audio(source: *mut obs_source_t, audio: *const obs_source_audio);
}
extern "C" {
    #[doc = " Signal an update to any currently used properties via 'update_properties'"]
    pub fn obs_source_update_properties(source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Gets the current async video frame"]
    pub fn obs_source_get_frame(source: *mut obs_source_t) -> *mut obs_source_frame;
}
extern "C" {
    #[doc = " Releases the current async video frame"]
    pub fn obs_source_release_frame(source: *mut obs_source_t, frame: *mut obs_source_frame);
}
extern "C" {
    #[doc = " Default RGB filter handler for generic effect filters.  Processes the"]
    #[doc = " filter chain and renders them to texture if needed, then the filter is"]
    #[doc = " drawn with"]
    #[doc = ""]
    #[doc = " After calling this, set your parameters for the effect, then call"]
    #[doc = " obs_source_process_filter_end to draw the filter."]
    #[doc = ""]
    #[doc = " Returns true if filtering should continue, false if the filter is bypassed"]
    #[doc = " for whatever reason."]
    pub fn obs_source_process_filter_begin(
        filter: *mut obs_source_t,
        format: gs_color_format,
        allow_direct: obs_allow_direct_render,
    ) -> bool;
}
extern "C" {
    #[doc = " Draws the filter."]
    #[doc = ""]
    #[doc = " Before calling this function, first call obs_source_process_filter_begin and"]
    #[doc = " then set the effect parameters, and then call this function to finalize the"]
    #[doc = " filter."]
    pub fn obs_source_process_filter_end(
        filter: *mut obs_source_t,
        effect: *mut gs_effect_t,
        width: u32,
        height: u32,
    );
}
extern "C" {
    #[doc = " Draws the filter with a specific technique."]
    #[doc = ""]
    #[doc = " Before calling this function, first call obs_source_process_filter_begin and"]
    #[doc = " then set the effect parameters, and then call this function to finalize the"]
    #[doc = " filter."]
    pub fn obs_source_process_filter_tech_end(
        filter: *mut obs_source_t,
        effect: *mut gs_effect_t,
        width: u32,
        height: u32,
        tech_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Skips the filter if the filter is invalid and cannot be rendered"]
    pub fn obs_source_skip_video_filter(filter: *mut obs_source_t);
}
extern "C" {
    #[doc = " Adds an active child source.  Must be called by parent sources on child"]
    #[doc = " sources when the child is added and active.  This ensures that the source is"]
    #[doc = " properly activated if the parent is active."]
    #[doc = ""]
    #[doc = " @returns true if source can be added, false if it causes recursion"]
    pub fn obs_source_add_active_child(parent: *mut obs_source_t, child: *mut obs_source_t)
        -> bool;
}
extern "C" {
    #[doc = " Removes an active child source.  Must be called by parent sources on child"]
    #[doc = " sources when the child is removed or inactive.  This ensures that the source"]
    #[doc = " is properly deactivated if the parent is no longer active."]
    pub fn obs_source_remove_active_child(parent: *mut obs_source_t, child: *mut obs_source_t);
}
extern "C" {
    #[doc = " Sends a mouse down/up event to a source"]
    pub fn obs_source_send_mouse_click(
        source: *mut obs_source_t,
        event: *const obs_mouse_event,
        type_: i32,
        mouse_up: bool,
        click_count: u32,
    );
}
extern "C" {
    #[doc = " Sends a mouse move event to a source."]
    pub fn obs_source_send_mouse_move(
        source: *mut obs_source_t,
        event: *const obs_mouse_event,
        mouse_leave: bool,
    );
}
extern "C" {
    #[doc = " Sends a mouse wheel event to a source"]
    pub fn obs_source_send_mouse_wheel(
        source: *mut obs_source_t,
        event: *const obs_mouse_event,
        x_delta: ::std::os::raw::c_int,
        y_delta: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sends a got-focus or lost-focus event to a source"]
    pub fn obs_source_send_focus(source: *mut obs_source_t, focus: bool);
}
extern "C" {
    #[doc = " Sends a key up/down event to a source"]
    pub fn obs_source_send_key_click(
        source: *mut obs_source_t,
        event: *const obs_key_event,
        key_up: bool,
    );
}
extern "C" {
    #[doc = " Sets the default source flags."]
    pub fn obs_source_set_default_flags(source: *mut obs_source_t, flags: u32);
}
extern "C" {
    #[doc = " Gets the base width for a source (not taking in to account filtering)"]
    pub fn obs_source_get_base_width(source: *mut obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Gets the base height for a source (not taking in to account filtering)"]
    pub fn obs_source_get_base_height(source: *mut obs_source_t) -> u32;
}
extern "C" {
    pub fn obs_source_audio_pending(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_get_audio_timestamp(source: *const obs_source_t) -> u64;
}
extern "C" {
    pub fn obs_source_get_audio_mix(source: *const obs_source_t, audio: *mut obs_source_audio_mix);
}
extern "C" {
    pub fn obs_source_set_async_unbuffered(source: *mut obs_source_t, unbuffered: bool);
}
extern "C" {
    pub fn obs_source_async_unbuffered(source: *const obs_source_t) -> bool;
}
extern "C" {
    #[doc = " Used to decouple audio from video so that audio doesn't attempt to sync up"]
    #[doc = " with video.  I.E. Audio acts independently.  Only works when in unbuffered"]
    #[doc = " mode."]
    pub fn obs_source_set_async_decoupled(source: *mut obs_source_t, decouple: bool);
}
extern "C" {
    pub fn obs_source_async_decoupled(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_set_audio_active(source: *mut obs_source_t, show: bool);
}
extern "C" {
    pub fn obs_source_audio_active(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_source_get_last_obs_version(source: *const obs_source_t) -> u32;
}
extern "C" {
    #[doc = " Media controls"]
    pub fn obs_source_media_play_pause(source: *mut obs_source_t, pause: bool);
}
extern "C" {
    pub fn obs_source_media_restart(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_stop(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_next(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_previous(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_get_duration(source: *mut obs_source_t) -> i64;
}
extern "C" {
    pub fn obs_source_media_get_time(source: *mut obs_source_t) -> i64;
}
extern "C" {
    pub fn obs_source_media_set_time(source: *mut obs_source_t, ms: i64);
}
extern "C" {
    pub fn obs_source_media_get_state(source: *mut obs_source_t) -> obs_media_state;
}
extern "C" {
    pub fn obs_source_media_started(source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_source_media_ended(source: *mut obs_source_t);
}
pub const obs_transition_target_OBS_TRANSITION_SOURCE_A: obs_transition_target = 0;
pub const obs_transition_target_OBS_TRANSITION_SOURCE_B: obs_transition_target = 1;
pub type obs_transition_target = u32;
extern "C" {
    pub fn obs_transition_get_source(
        transition: *mut obs_source_t,
        target: obs_transition_target,
    ) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_transition_clear(transition: *mut obs_source_t);
}
extern "C" {
    pub fn obs_transition_get_active_source(transition: *mut obs_source_t) -> *mut obs_source_t;
}
pub const obs_transition_mode_OBS_TRANSITION_MODE_AUTO: obs_transition_mode = 0;
pub const obs_transition_mode_OBS_TRANSITION_MODE_MANUAL: obs_transition_mode = 1;
pub type obs_transition_mode = u32;
extern "C" {
    pub fn obs_transition_start(
        transition: *mut obs_source_t,
        mode: obs_transition_mode,
        duration_ms: u32,
        dest: *mut obs_source_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_transition_set(transition: *mut obs_source_t, source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_transition_set_manual_time(transition: *mut obs_source_t, t: f32);
}
extern "C" {
    pub fn obs_transition_set_manual_torque(transition: *mut obs_source_t, torque: f32, clamp: f32);
}
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_MAX_ONLY: obs_transition_scale_type = 0;
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_ASPECT: obs_transition_scale_type = 1;
pub const obs_transition_scale_type_OBS_TRANSITION_SCALE_STRETCH: obs_transition_scale_type = 2;
pub type obs_transition_scale_type = u32;
extern "C" {
    pub fn obs_transition_set_scale_type(
        transition: *mut obs_source_t,
        type_: obs_transition_scale_type,
    );
}
extern "C" {
    pub fn obs_transition_get_scale_type(
        transition: *const obs_source_t,
    ) -> obs_transition_scale_type;
}
extern "C" {
    pub fn obs_transition_set_alignment(transition: *mut obs_source_t, alignment: u32);
}
extern "C" {
    pub fn obs_transition_get_alignment(transition: *const obs_source_t) -> u32;
}
extern "C" {
    pub fn obs_transition_set_size(transition: *mut obs_source_t, cx: u32, cy: u32);
}
extern "C" {
    pub fn obs_transition_get_size(transition: *const obs_source_t, cx: *mut u32, cy: *mut u32);
}
extern "C" {
    #[doc = " Enables fixed transitions (videos or specific types of transitions that"]
    #[doc = " are of fixed duration and linearly interpolated"]
    pub fn obs_transition_enable_fixed(
        transition: *mut obs_source_t,
        enable: bool,
        duration_ms: u32,
    );
}
extern "C" {
    pub fn obs_transition_fixed(transition: *mut obs_source_t) -> bool;
}
pub type obs_transition_video_render_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        a: *mut gs_texture_t,
        b: *mut gs_texture_t,
        t: f32,
        cx: u32,
        cy: u32,
    ),
>;
pub type obs_transition_audio_mix_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, t: f32) -> f32>;
extern "C" {
    pub fn obs_transition_get_time(transition: *mut obs_source_t) -> f32;
}
extern "C" {
    pub fn obs_transition_force_stop(transition: *mut obs_source_t);
}
extern "C" {
    pub fn obs_transition_video_render(
        transition: *mut obs_source_t,
        callback: obs_transition_video_render_callback_t,
    );
}
extern "C" {
    #[doc = " Directly renders its sub-source instead of to texture.  Returns false if no"]
    #[doc = " longer transitioning"]
    pub fn obs_transition_video_render_direct(
        transition: *mut obs_source_t,
        target: obs_transition_target,
    ) -> bool;
}
extern "C" {
    pub fn obs_transition_audio_render(
        transition: *mut obs_source_t,
        ts_out: *mut u64,
        audio: *mut obs_source_audio_mix,
        mixers: u32,
        channels: size_t,
        sample_rate: size_t,
        mix_a_callback: obs_transition_audio_mix_callback_t,
        mix_b_callback: obs_transition_audio_mix_callback_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_transition_swap_begin(tr_dest: *mut obs_source_t, tr_source: *mut obs_source_t);
}
extern "C" {
    pub fn obs_transition_swap_end(tr_dest: *mut obs_source_t, tr_source: *mut obs_source_t);
}
extern "C" {
    #[doc = " Creates a scene."]
    #[doc = ""]
    #[doc = "   A scene is a source which is a container of other sources with specific"]
    #[doc = " display orientations.  Scenes can also be used like any other source."]
    pub fn obs_scene_create(name: *const ::std::os::raw::c_char) -> *mut obs_scene_t;
}
extern "C" {
    pub fn obs_scene_create_private(name: *const ::std::os::raw::c_char) -> *mut obs_scene_t;
}
#[doc = "< Source refs only"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_REFS: obs_scene_duplicate_type = 0;
#[doc = "< Fully duplicate"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_COPY: obs_scene_duplicate_type = 1;
#[doc = "< Source refs only (as private)"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_PRIVATE_REFS: obs_scene_duplicate_type = 2;
#[doc = "< Fully duplicate (as private)"]
pub const obs_scene_duplicate_type_OBS_SCENE_DUP_PRIVATE_COPY: obs_scene_duplicate_type = 3;
pub type obs_scene_duplicate_type = u32;
extern "C" {
    #[doc = " Duplicates a scene."]
    pub fn obs_scene_duplicate(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        type_: obs_scene_duplicate_type,
    ) -> *mut obs_scene_t;
}
extern "C" {
    pub fn obs_scene_addref(scene: *mut obs_scene_t);
}
extern "C" {
    pub fn obs_scene_release(scene: *mut obs_scene_t);
}
extern "C" {
    #[doc = " Gets the scene's source context"]
    pub fn obs_scene_get_source(scene: *const obs_scene_t) -> *mut obs_source_t;
}
extern "C" {
    #[doc = " Gets the scene from its source, or NULL if not a scene"]
    pub fn obs_scene_from_source(source: *const obs_source_t) -> *mut obs_scene_t;
}
extern "C" {
    #[doc = " Determines whether a source is within a scene"]
    pub fn obs_scene_find_source(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_find_source_recursive(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_find_sceneitem_by_id(scene: *mut obs_scene_t, id: i64)
        -> *mut obs_sceneitem_t;
}
extern "C" {
    #[doc = " Enumerates sources within a scene"]
    pub fn obs_scene_enum_items(
        scene: *mut obs_scene_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut obs_scene_t,
                arg2: *mut obs_sceneitem_t,
                arg3: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_scene_reorder_items(
        scene: *mut obs_scene_t,
        item_order: *const *mut obs_sceneitem_t,
        item_order_size: size_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_sceneitem_order_info {
    pub group: *mut obs_sceneitem_t,
    pub item: *mut obs_sceneitem_t,
}
#[test]
fn bindgen_test_layout_obs_sceneitem_order_info() {
    assert_eq!(
        ::std::mem::size_of::<obs_sceneitem_order_info>(),
        16usize,
        concat!("Size of: ", stringify!(obs_sceneitem_order_info))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_sceneitem_order_info>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_sceneitem_order_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_sceneitem_order_info>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_order_info),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_sceneitem_order_info>())).item as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_order_info),
            "::",
            stringify!(item)
        )
    );
}
impl Default for obs_sceneitem_order_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn obs_scene_reorder_items2(
        scene: *mut obs_scene_t,
        item_order: *mut obs_sceneitem_order_info,
        item_order_size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Adds/creates a new scene item for a source"]
    pub fn obs_scene_add(
        scene: *mut obs_scene_t,
        source: *mut obs_source_t,
    ) -> *mut obs_sceneitem_t;
}
pub type obs_scene_atomic_update_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, scene: *mut obs_scene_t),
>;
extern "C" {
    pub fn obs_scene_atomic_update(
        scene: *mut obs_scene_t,
        func: obs_scene_atomic_update_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn obs_sceneitem_addref(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_release(item: *mut obs_sceneitem_t);
}
extern "C" {
    #[doc = " Removes a scene item."]
    pub fn obs_sceneitem_remove(item: *mut obs_sceneitem_t);
}
extern "C" {
    #[doc = " Gets the scene parent associated with the scene item."]
    pub fn obs_sceneitem_get_scene(item: *const obs_sceneitem_t) -> *mut obs_scene_t;
}
extern "C" {
    #[doc = " Gets the source of a scene item."]
    pub fn obs_sceneitem_get_source(item: *const obs_sceneitem_t) -> *mut obs_source_t;
}
extern "C" {
    pub fn obs_sceneitem_select(item: *mut obs_sceneitem_t, select: bool);
}
extern "C" {
    pub fn obs_sceneitem_selected(item: *const obs_sceneitem_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_locked(item: *const obs_sceneitem_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_set_locked(item: *mut obs_sceneitem_t, lock: bool) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_set_pos(item: *mut obs_sceneitem_t, pos: *const vec2);
}
extern "C" {
    pub fn obs_sceneitem_set_rot(item: *mut obs_sceneitem_t, rot_deg: f32);
}
extern "C" {
    pub fn obs_sceneitem_set_scale(item: *mut obs_sceneitem_t, scale: *const vec2);
}
extern "C" {
    pub fn obs_sceneitem_set_alignment(item: *mut obs_sceneitem_t, alignment: u32);
}
extern "C" {
    pub fn obs_sceneitem_set_order(item: *mut obs_sceneitem_t, movement: obs_order_movement);
}
extern "C" {
    pub fn obs_sceneitem_set_order_position(
        item: *mut obs_sceneitem_t,
        position: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn obs_sceneitem_set_bounds_type(item: *mut obs_sceneitem_t, type_: obs_bounds_type);
}
extern "C" {
    pub fn obs_sceneitem_set_bounds_alignment(item: *mut obs_sceneitem_t, alignment: u32);
}
extern "C" {
    pub fn obs_sceneitem_set_bounds(item: *mut obs_sceneitem_t, bounds: *const vec2);
}
extern "C" {
    pub fn obs_sceneitem_get_id(item: *const obs_sceneitem_t) -> i64;
}
extern "C" {
    pub fn obs_sceneitem_get_pos(item: *const obs_sceneitem_t, pos: *mut vec2);
}
extern "C" {
    pub fn obs_sceneitem_get_rot(item: *const obs_sceneitem_t) -> f32;
}
extern "C" {
    pub fn obs_sceneitem_get_scale(item: *const obs_sceneitem_t, scale: *mut vec2);
}
extern "C" {
    pub fn obs_sceneitem_get_alignment(item: *const obs_sceneitem_t) -> u32;
}
extern "C" {
    pub fn obs_sceneitem_get_bounds_type(item: *const obs_sceneitem_t) -> obs_bounds_type;
}
extern "C" {
    pub fn obs_sceneitem_get_bounds_alignment(item: *const obs_sceneitem_t) -> u32;
}
extern "C" {
    pub fn obs_sceneitem_get_bounds(item: *const obs_sceneitem_t, bounds: *mut vec2);
}
extern "C" {
    pub fn obs_sceneitem_get_info(item: *const obs_sceneitem_t, info: *mut obs_transform_info);
}
extern "C" {
    pub fn obs_sceneitem_set_info(item: *mut obs_sceneitem_t, info: *const obs_transform_info);
}
extern "C" {
    pub fn obs_sceneitem_get_draw_transform(item: *const obs_sceneitem_t, transform: *mut matrix4);
}
extern "C" {
    pub fn obs_sceneitem_get_box_transform(item: *const obs_sceneitem_t, transform: *mut matrix4);
}
extern "C" {
    pub fn obs_sceneitem_get_box_scale(item: *const obs_sceneitem_t, scale: *mut vec2);
}
extern "C" {
    pub fn obs_sceneitem_visible(item: *const obs_sceneitem_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_set_visible(item: *mut obs_sceneitem_t, visible: bool) -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct obs_sceneitem_crop {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_obs_sceneitem_crop() {
    assert_eq!(
        ::std::mem::size_of::<obs_sceneitem_crop>(),
        16usize,
        concat!("Size of: ", stringify!(obs_sceneitem_crop))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_sceneitem_crop>(),
        4usize,
        concat!("Alignment of ", stringify!(obs_sceneitem_crop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_sceneitem_crop>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_crop),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_sceneitem_crop>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_crop),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_sceneitem_crop>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_crop),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_sceneitem_crop>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_sceneitem_crop),
            "::",
            stringify!(bottom)
        )
    );
}
extern "C" {
    pub fn obs_sceneitem_set_crop(item: *mut obs_sceneitem_t, crop: *const obs_sceneitem_crop);
}
extern "C" {
    pub fn obs_sceneitem_get_crop(item: *const obs_sceneitem_t, crop: *mut obs_sceneitem_crop);
}
extern "C" {
    pub fn obs_sceneitem_set_scale_filter(item: *mut obs_sceneitem_t, filter: obs_scale_type);
}
extern "C" {
    pub fn obs_sceneitem_get_scale_filter(item: *mut obs_sceneitem_t) -> obs_scale_type;
}
extern "C" {
    pub fn obs_sceneitem_force_update_transform(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_defer_update_begin(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_defer_update_end(item: *mut obs_sceneitem_t);
}
extern "C" {
    #[doc = " Gets private front-end settings data.  This data is saved/loaded"]
    #[doc = " automatically.  Returns an incremented reference."]
    pub fn obs_sceneitem_get_private_settings(item: *mut obs_sceneitem_t) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_scene_add_group(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_insert_group(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        items: *mut *mut obs_sceneitem_t,
        count: size_t,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_add_group2(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        signal: bool,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_insert_group2(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
        items: *mut *mut obs_sceneitem_t,
        count: size_t,
        signal: bool,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_scene_get_group(
        scene: *mut obs_scene_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_sceneitem_is_group(item: *mut obs_sceneitem_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_group_get_scene(group: *const obs_sceneitem_t) -> *mut obs_scene_t;
}
extern "C" {
    pub fn obs_sceneitem_group_ungroup(group: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_group_ungroup2(group: *mut obs_sceneitem_t, signal: bool);
}
extern "C" {
    pub fn obs_sceneitem_group_add_item(group: *mut obs_sceneitem_t, item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_group_remove_item(group: *mut obs_sceneitem_t, item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_get_group(
        scene: *mut obs_scene_t,
        item: *mut obs_sceneitem_t,
    ) -> *mut obs_sceneitem_t;
}
extern "C" {
    pub fn obs_source_is_group(source: *const obs_source_t) -> bool;
}
extern "C" {
    pub fn obs_scene_is_group(scene: *const obs_scene_t) -> bool;
}
extern "C" {
    pub fn obs_sceneitem_group_enum_items(
        group: *mut obs_sceneitem_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut obs_scene_t,
                arg2: *mut obs_sceneitem_t,
                arg3: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        param: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Gets the group from its source, or NULL if not a group"]
    pub fn obs_group_from_source(source: *const obs_source_t) -> *mut obs_scene_t;
}
extern "C" {
    pub fn obs_sceneitem_defer_group_resize_begin(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_sceneitem_defer_group_resize_end(item: *mut obs_sceneitem_t);
}
extern "C" {
    pub fn obs_output_get_display_name(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates an output."]
    #[doc = ""]
    #[doc = "   Outputs allow outputting to file, outputting to network, outputting to"]
    #[doc = " directshow, or other custom outputs."]
    pub fn obs_output_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_output_t;
}
extern "C" {
    #[doc = " Adds/releases a reference to an output.  When the last reference is"]
    #[doc = " released, the output is destroyed."]
    pub fn obs_output_addref(output: *mut obs_output_t);
}
extern "C" {
    pub fn obs_output_release(output: *mut obs_output_t);
}
extern "C" {
    pub fn obs_weak_output_addref(weak: *mut obs_weak_output_t);
}
extern "C" {
    pub fn obs_weak_output_release(weak: *mut obs_weak_output_t);
}
extern "C" {
    pub fn obs_output_get_ref(output: *mut obs_output_t) -> *mut obs_output_t;
}
extern "C" {
    pub fn obs_output_get_weak_output(output: *mut obs_output_t) -> *mut obs_weak_output_t;
}
extern "C" {
    pub fn obs_weak_output_get_output(weak: *mut obs_weak_output_t) -> *mut obs_output_t;
}
extern "C" {
    pub fn obs_weak_output_references_output(
        weak: *mut obs_weak_output_t,
        output: *mut obs_output_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_output_get_name(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Starts the output."]
    pub fn obs_output_start(output: *mut obs_output_t) -> bool;
}
extern "C" {
    #[doc = " Stops the output."]
    pub fn obs_output_stop(output: *mut obs_output_t);
}
extern "C" {
    #[doc = " Sets the current output delay, in seconds (if the output supports delay)."]
    #[doc = ""]
    #[doc = " If delay is currently active, it will set the delay value, but will not"]
    #[doc = " affect the current delay, it will only affect the next time the output is"]
    #[doc = " activated."]
    pub fn obs_output_set_delay(output: *mut obs_output_t, delay_sec: u32, flags: u32);
}
extern "C" {
    #[doc = " Gets the currently set delay value, in seconds."]
    pub fn obs_output_get_delay(output: *const obs_output_t) -> u32;
}
extern "C" {
    #[doc = " If delay is active, gets the currently active delay value, in seconds."]
    pub fn obs_output_get_active_delay(output: *const obs_output_t) -> u32;
}
extern "C" {
    #[doc = " Forces the output to stop.  Usually only used with delay."]
    pub fn obs_output_force_stop(output: *mut obs_output_t);
}
extern "C" {
    #[doc = " Returns whether the output is active"]
    pub fn obs_output_active(output: *const obs_output_t) -> bool;
}
extern "C" {
    #[doc = " Returns output capability flags"]
    pub fn obs_output_get_flags(output: *const obs_output_t) -> u32;
}
extern "C" {
    #[doc = " Returns output capability flags"]
    pub fn obs_get_output_flags(id: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    #[doc = " Gets the default settings for an output type"]
    pub fn obs_output_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_output_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Returns the property list of an existing output, if any.  Free with"]
    #[doc = " obs_properties_destroy"]
    pub fn obs_output_properties(output: *const obs_output_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Updates the settings for this output context"]
    pub fn obs_output_update(output: *mut obs_output_t, settings: *mut obs_data_t);
}
extern "C" {
    #[doc = " Specifies whether the output can be paused"]
    pub fn obs_output_can_pause(output: *const obs_output_t) -> bool;
}
extern "C" {
    #[doc = " Pauses the output (if the functionality is allowed by the output"]
    pub fn obs_output_pause(output: *mut obs_output_t, pause: bool) -> bool;
}
extern "C" {
    #[doc = " Returns whether output is paused"]
    pub fn obs_output_paused(output: *const obs_output_t) -> bool;
}
extern "C" {
    pub fn obs_output_get_settings(output: *const obs_output_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the signal handler for an output"]
    pub fn obs_output_get_signal_handler(output: *const obs_output_t) -> *mut signal_handler_t;
}
extern "C" {
    #[doc = " Returns the procedure handler for an output"]
    pub fn obs_output_get_proc_handler(output: *const obs_output_t) -> *mut proc_handler_t;
}
extern "C" {
    #[doc = " Sets the current audio/video media contexts associated with this output,"]
    #[doc = " required for non-encoded outputs.  Can be null."]
    pub fn obs_output_set_media(
        output: *mut obs_output_t,
        video: *mut video_t,
        audio: *mut audio_t,
    );
}
extern "C" {
    #[doc = " Returns the video media context associated with this output"]
    pub fn obs_output_video(output: *const obs_output_t) -> *mut video_t;
}
extern "C" {
    #[doc = " Returns the audio media context associated with this output"]
    pub fn obs_output_audio(output: *const obs_output_t) -> *mut audio_t;
}
extern "C" {
    #[doc = " Sets the current audio mixer for non-encoded outputs"]
    pub fn obs_output_set_mixer(output: *mut obs_output_t, mixer_idx: size_t);
}
extern "C" {
    #[doc = " Gets the current audio mixer for non-encoded outputs"]
    pub fn obs_output_get_mixer(output: *const obs_output_t) -> size_t;
}
extern "C" {
    #[doc = " Sets the current audio mixes (mask) for a non-encoded multi-track output"]
    pub fn obs_output_set_mixers(output: *mut obs_output_t, mixers: size_t);
}
extern "C" {
    #[doc = " Gets the current audio mixes (mask) for a non-encoded multi-track output"]
    pub fn obs_output_get_mixers(output: *const obs_output_t) -> size_t;
}
extern "C" {
    #[doc = " Sets the current video encoder associated with this output,"]
    #[doc = " required for encoded outputs"]
    pub fn obs_output_set_video_encoder(output: *mut obs_output_t, encoder: *mut obs_encoder_t);
}
extern "C" {
    #[doc = " Sets the current audio encoder associated with this output,"]
    #[doc = " required for encoded outputs."]
    #[doc = ""]
    #[doc = " The idx parameter specifies the audio encoder index to set the encoder to."]
    #[doc = " Only used with outputs that have multiple audio outputs (RTMP typically),"]
    #[doc = " otherwise the parameter is ignored."]
    pub fn obs_output_set_audio_encoder(
        output: *mut obs_output_t,
        encoder: *mut obs_encoder_t,
        idx: size_t,
    );
}
extern "C" {
    #[doc = " Returns the current video encoder associated with this output"]
    pub fn obs_output_get_video_encoder(output: *const obs_output_t) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Returns the current audio encoder associated with this output"]
    #[doc = ""]
    #[doc = " The idx parameter specifies the audio encoder index.  Only used with"]
    #[doc = " outputs that have multiple audio outputs, otherwise the parameter is"]
    #[doc = " ignored."]
    pub fn obs_output_get_audio_encoder(
        output: *const obs_output_t,
        idx: size_t,
    ) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Sets the current service associated with this output."]
    pub fn obs_output_set_service(output: *mut obs_output_t, service: *mut obs_service_t);
}
extern "C" {
    #[doc = " Gets the current service associated with this output."]
    pub fn obs_output_get_service(output: *const obs_output_t) -> *mut obs_service_t;
}
extern "C" {
    #[doc = " Sets the reconnect settings.  Set retry_count to 0 to disable reconnecting."]
    pub fn obs_output_set_reconnect_settings(
        output: *mut obs_output_t,
        retry_count: ::std::os::raw::c_int,
        retry_sec: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn obs_output_get_total_bytes(output: *const obs_output_t) -> u64;
}
extern "C" {
    pub fn obs_output_get_frames_dropped(output: *const obs_output_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_output_get_total_frames(output: *const obs_output_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the preferred scaled resolution for this output.  Set width and height"]
    #[doc = " to 0 to disable scaling."]
    #[doc = ""]
    #[doc = " If this output uses an encoder, it will call obs_encoder_set_scaled_size on"]
    #[doc = " the encoder before the stream is started.  If the encoder is already active,"]
    #[doc = " then this function will trigger a warning and do nothing."]
    pub fn obs_output_set_preferred_size(output: *mut obs_output_t, width: u32, height: u32);
}
extern "C" {
    #[doc = " For video outputs, returns the width of the encoded image"]
    pub fn obs_output_get_width(output: *const obs_output_t) -> u32;
}
extern "C" {
    #[doc = " For video outputs, returns the height of the encoded image"]
    pub fn obs_output_get_height(output: *const obs_output_t) -> u32;
}
extern "C" {
    pub fn obs_output_get_id(output: *const obs_output_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_get_congestion(output: *mut obs_output_t) -> f32;
}
extern "C" {
    pub fn obs_output_get_connect_time_ms(output: *mut obs_output_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obs_output_reconnecting(output: *const obs_output_t) -> bool;
}
extern "C" {
    #[doc = " Pass a string of the last output error, for UI use"]
    pub fn obs_output_set_last_error(
        output: *mut obs_output_t,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_output_get_last_error(output: *mut obs_output_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_get_supported_video_codecs(
        output: *const obs_output_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_get_supported_audio_codecs(
        output: *const obs_output_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_output_get_type_data(output: *mut obs_output_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Optionally sets the video conversion info.  Used only for raw output"]
    pub fn obs_output_set_video_conversion(
        output: *mut obs_output_t,
        conversion: *const video_scale_info,
    );
}
extern "C" {
    #[doc = " Optionally sets the audio conversion info.  Used only for raw output"]
    pub fn obs_output_set_audio_conversion(
        output: *mut obs_output_t,
        conversion: *const audio_convert_info,
    );
}
extern "C" {
    #[doc = " Returns whether data capture can begin with the specified flags"]
    pub fn obs_output_can_begin_data_capture(output: *const obs_output_t, flags: u32) -> bool;
}
extern "C" {
    #[doc = " Initializes encoders (if any)"]
    pub fn obs_output_initialize_encoders(output: *mut obs_output_t, flags: u32) -> bool;
}
extern "C" {
    #[doc = " Begins data capture from media/encoders."]
    #[doc = ""]
    #[doc = " @param  output  Output context"]
    #[doc = " @param  flags   Set this to 0 to use default output flags set in the"]
    #[doc = "                 obs_output_info structure, otherwise set to a either"]
    #[doc = "                 OBS_OUTPUT_VIDEO or OBS_OUTPUT_AUDIO to specify whether to"]
    #[doc = "                 connect audio or video.  This is useful for things like"]
    #[doc = "                 ffmpeg which may or may not always want to use both audio"]
    #[doc = "                 and video."]
    #[doc = " @return         true if successful, false otherwise."]
    pub fn obs_output_begin_data_capture(output: *mut obs_output_t, flags: u32) -> bool;
}
extern "C" {
    #[doc = " Ends data capture from media/encoders"]
    pub fn obs_output_end_data_capture(output: *mut obs_output_t);
}
extern "C" {
    #[doc = " Signals that the output has stopped itself."]
    #[doc = ""]
    #[doc = " @param  output  Output context"]
    #[doc = " @param  code    Error code (or OBS_OUTPUT_SUCCESS if not an error)"]
    pub fn obs_output_signal_stop(output: *mut obs_output_t, code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn obs_output_get_pause_offset(output: *mut obs_output_t) -> u64;
}
extern "C" {
    pub fn obs_encoder_get_display_name(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a video encoder context"]
    #[doc = ""]
    #[doc = " @param  id        Video encoder ID"]
    #[doc = " @param  name      Name to assign to this context"]
    #[doc = " @param  settings  Settings"]
    #[doc = " @return           The video encoder context, or NULL if failed or not found."]
    pub fn obs_video_encoder_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Creates an audio encoder context"]
    #[doc = ""]
    #[doc = " @param  id        Audio Encoder ID"]
    #[doc = " @param  name      Name to assign to this context"]
    #[doc = " @param  settings  Settings"]
    #[doc = " @param  mixer_idx Index of the mixer to use for this audio encoder"]
    #[doc = " @return           The video encoder context, or NULL if failed or not found."]
    pub fn obs_audio_encoder_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        mixer_idx: size_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_encoder_t;
}
extern "C" {
    #[doc = " Adds/releases a reference to an encoder.  When the last reference is"]
    #[doc = " released, the encoder is destroyed."]
    pub fn obs_encoder_addref(encoder: *mut obs_encoder_t);
}
extern "C" {
    pub fn obs_encoder_release(encoder: *mut obs_encoder_t);
}
extern "C" {
    pub fn obs_weak_encoder_addref(weak: *mut obs_weak_encoder_t);
}
extern "C" {
    pub fn obs_weak_encoder_release(weak: *mut obs_weak_encoder_t);
}
extern "C" {
    pub fn obs_encoder_get_ref(encoder: *mut obs_encoder_t) -> *mut obs_encoder_t;
}
extern "C" {
    pub fn obs_encoder_get_weak_encoder(encoder: *mut obs_encoder_t) -> *mut obs_weak_encoder_t;
}
extern "C" {
    pub fn obs_weak_encoder_get_encoder(weak: *mut obs_weak_encoder_t) -> *mut obs_encoder_t;
}
extern "C" {
    pub fn obs_weak_encoder_references_encoder(
        weak: *mut obs_weak_encoder_t,
        encoder: *mut obs_encoder_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_encoder_set_name(encoder: *mut obs_encoder_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn obs_encoder_get_name(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the codec of an encoder by the id"]
    pub fn obs_get_encoder_codec(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the type of an encoder by the id"]
    pub fn obs_get_encoder_type(id: *const ::std::os::raw::c_char) -> obs_encoder_type;
}
extern "C" {
    #[doc = " Returns the codec of the encoder"]
    pub fn obs_encoder_get_codec(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the type of an encoder"]
    pub fn obs_encoder_get_type(encoder: *const obs_encoder_t) -> obs_encoder_type;
}
extern "C" {
    #[doc = " Sets the scaled resolution for a video encoder.  Set width and height to 0"]
    #[doc = " to disable scaling.  If the encoder is active, this function will trigger"]
    #[doc = " a warning, and do nothing."]
    pub fn obs_encoder_set_scaled_size(encoder: *mut obs_encoder_t, width: u32, height: u32);
}
extern "C" {
    #[doc = " For video encoders, returns true if pre-encode scaling is enabled"]
    pub fn obs_encoder_scaling_enabled(encoder: *const obs_encoder_t) -> bool;
}
extern "C" {
    #[doc = " For video encoders, returns the width of the encoded image"]
    pub fn obs_encoder_get_width(encoder: *const obs_encoder_t) -> u32;
}
extern "C" {
    #[doc = " For video encoders, returns the height of the encoded image"]
    pub fn obs_encoder_get_height(encoder: *const obs_encoder_t) -> u32;
}
extern "C" {
    #[doc = " For audio encoders, returns the sample rate of the audio"]
    pub fn obs_encoder_get_sample_rate(encoder: *const obs_encoder_t) -> u32;
}
extern "C" {
    #[doc = " Sets the preferred video format for a video encoder.  If the encoder can use"]
    #[doc = " the format specified, it will force a conversion to that format if the"]
    #[doc = " obs output format does not match the preferred format."]
    #[doc = ""]
    #[doc = " If the format is set to VIDEO_FORMAT_NONE, will revert to the default"]
    #[doc = " functionality of converting only when absolutely necessary."]
    pub fn obs_encoder_set_preferred_video_format(
        encoder: *mut obs_encoder_t,
        format: video_format,
    );
}
extern "C" {
    pub fn obs_encoder_get_preferred_video_format(encoder: *const obs_encoder_t) -> video_format;
}
extern "C" {
    #[doc = " Gets the default settings for an encoder type"]
    pub fn obs_encoder_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
}
extern "C" {
    pub fn obs_encoder_get_defaults(encoder: *const obs_encoder_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_encoder_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Returns the property list of an existing encoder, if any.  Free with"]
    #[doc = " obs_properties_destroy"]
    pub fn obs_encoder_properties(encoder: *const obs_encoder_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Updates the settings of the encoder context.  Usually used for changing"]
    #[doc = " bitrate while active"]
    pub fn obs_encoder_update(encoder: *mut obs_encoder_t, settings: *mut obs_data_t);
}
extern "C" {
    #[doc = " Gets extra data (headers) associated with this context"]
    pub fn obs_encoder_get_extra_data(
        encoder: *const obs_encoder_t,
        extra_data: *mut *mut u8,
        size: *mut size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the current settings for this encoder"]
    pub fn obs_encoder_get_settings(encoder: *const obs_encoder_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Sets the video output context to be used with this encoder"]
    pub fn obs_encoder_set_video(encoder: *mut obs_encoder_t, video: *mut video_t);
}
extern "C" {
    #[doc = " Sets the audio output context to be used with this encoder"]
    pub fn obs_encoder_set_audio(encoder: *mut obs_encoder_t, audio: *mut audio_t);
}
extern "C" {
    #[doc = " Returns the video output context used with this encoder, or NULL if not"]
    #[doc = " a video context"]
    pub fn obs_encoder_video(encoder: *const obs_encoder_t) -> *mut video_t;
}
extern "C" {
    #[doc = " Returns the audio output context used with this encoder, or NULL if not"]
    #[doc = " a audio context"]
    pub fn obs_encoder_audio(encoder: *const obs_encoder_t) -> *mut audio_t;
}
extern "C" {
    #[doc = " Returns true if encoder is active, false otherwise"]
    pub fn obs_encoder_active(encoder: *const obs_encoder_t) -> bool;
}
extern "C" {
    pub fn obs_encoder_get_type_data(encoder: *mut obs_encoder_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_encoder_get_id(encoder: *const obs_encoder_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_get_encoder_caps(encoder_id: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn obs_encoder_get_caps(encoder: *const obs_encoder_t) -> u32;
}
extern "C" {
    #[doc = " Duplicates an encoder packet"]
    pub fn obs_duplicate_encoder_packet(dst: *mut encoder_packet, src: *const encoder_packet);
}
extern "C" {
    pub fn obs_free_encoder_packet(packet: *mut encoder_packet);
}
extern "C" {
    pub fn obs_encoder_packet_ref(dst: *mut encoder_packet, src: *mut encoder_packet);
}
extern "C" {
    pub fn obs_encoder_packet_release(packet: *mut encoder_packet);
}
extern "C" {
    pub fn obs_encoder_create_rerouted(
        encoder: *mut obs_encoder_t,
        reroute_id: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns whether encoder is paused"]
    pub fn obs_encoder_paused(output: *const obs_encoder_t) -> bool;
}
extern "C" {
    pub fn obs_encoder_get_last_error(encoder: *mut obs_encoder_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_encoder_set_last_error(
        encoder: *mut obs_encoder_t,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn obs_service_get_display_name(
        id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_create(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
        hotkey_data: *mut obs_data_t,
    ) -> *mut obs_service_t;
}
extern "C" {
    pub fn obs_service_create_private(
        id: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        settings: *mut obs_data_t,
    ) -> *mut obs_service_t;
}
extern "C" {
    #[doc = " Adds/releases a reference to a service.  When the last reference is"]
    #[doc = " released, the service is destroyed."]
    pub fn obs_service_addref(service: *mut obs_service_t);
}
extern "C" {
    pub fn obs_service_release(service: *mut obs_service_t);
}
extern "C" {
    pub fn obs_weak_service_addref(weak: *mut obs_weak_service_t);
}
extern "C" {
    pub fn obs_weak_service_release(weak: *mut obs_weak_service_t);
}
extern "C" {
    pub fn obs_service_get_ref(service: *mut obs_service_t) -> *mut obs_service_t;
}
extern "C" {
    pub fn obs_service_get_weak_service(service: *mut obs_service_t) -> *mut obs_weak_service_t;
}
extern "C" {
    pub fn obs_weak_service_get_service(weak: *mut obs_weak_service_t) -> *mut obs_service_t;
}
extern "C" {
    pub fn obs_weak_service_references_service(
        weak: *mut obs_weak_service_t,
        service: *mut obs_service_t,
    ) -> bool;
}
extern "C" {
    pub fn obs_service_get_name(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the default settings for a service"]
    pub fn obs_service_defaults(id: *const ::std::os::raw::c_char) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the property list, if any.  Free with obs_properties_destroy"]
    pub fn obs_get_service_properties(id: *const ::std::os::raw::c_char) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Returns the property list of an existing service context, if any.  Free with"]
    #[doc = " obs_properties_destroy"]
    pub fn obs_service_properties(service: *const obs_service_t) -> *mut obs_properties_t;
}
extern "C" {
    #[doc = " Gets the service type"]
    pub fn obs_service_get_type(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Updates the settings of the service context"]
    pub fn obs_service_update(service: *mut obs_service_t, settings: *mut obs_data_t);
}
extern "C" {
    #[doc = " Returns the current settings for this service"]
    pub fn obs_service_get_settings(service: *const obs_service_t) -> *mut obs_data_t;
}
extern "C" {
    #[doc = " Returns the URL for this service context"]
    pub fn obs_service_get_url(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the stream key (if any) for this service context"]
    pub fn obs_service_get_key(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the username (if any) for this service context"]
    pub fn obs_service_get_username(service: *const obs_service_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the password (if any) for this service context"]
    pub fn obs_service_get_password(service: *const obs_service_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Applies service-specific video encoder settings."]
    #[doc = ""]
    #[doc = " @param  video_encoder_settings  Video encoder settings.  Optional."]
    #[doc = " @param  audio_encoder_settings  Audio encoder settings.  Optional."]
    pub fn obs_service_apply_encoder_settings(
        service: *mut obs_service_t,
        video_encoder_settings: *mut obs_data_t,
        audio_encoder_settings: *mut obs_data_t,
    );
}
extern "C" {
    pub fn obs_service_get_type_data(service: *mut obs_service_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn obs_service_get_id(service: *const obs_service_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_service_get_output_type(
        service: *const obs_service_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn obs_source_frame_init(
        frame: *mut obs_source_frame,
        format: video_format,
        width: u32,
        height: u32,
    );
}
extern "C" {
    pub fn obs_source_frame_copy(dst: *mut obs_source_frame, src: *const obs_source_frame);
}
extern "C" {
    pub fn obs_source_get_icon_type(id: *const ::std::os::raw::c_char) -> obs_icon_type;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
